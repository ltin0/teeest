
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type api_requestPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "api_request"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    request: Prisma.JsonValue
    response: Prisma.JsonValue
    created_at: Date
  }, ExtArgs["result"]["api_request"]>
  composites: {}
}

/**
 * Model api_request
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type api_request = runtime.Types.DefaultSelection<api_requestPayload>
export type auth_userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "auth_user"
  objects: {
    client_auth_user: client_auth_userPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    email: string
    roles: Prisma.JsonValue
    password: string
    created_at: Date
    updated_at: Date
    username: string
  }, ExtArgs["result"]["auth_user"]>
  composites: {}
}

/**
 * Model auth_user
 * 
 */
export type auth_user = runtime.Types.DefaultSelection<auth_userPayload>
export type banner_more_profitablePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "banner_more_profitable"
  objects: {
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file: banner_more_profitable_filePayload<ExtArgs> | null
    slot_settings: slot_settingsPayload<ExtArgs> | null
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file: banner_more_profitable_filePayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    banner_id: number | null
    slot_settings_id: number | null
    banner_file_id: number | null
    name: string
    game_url: string
    created_at: Date
    updated_at: Date
    active: boolean
  }, ExtArgs["result"]["banner_more_profitable"]>
  composites: {}
}

/**
 * Model banner_more_profitable
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type banner_more_profitable = runtime.Types.DefaultSelection<banner_more_profitablePayload>
export type banner_more_profitable_filePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "banner_more_profitable_file"
  objects: {
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file: banner_more_profitablePayload<ExtArgs> | null
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file: banner_more_profitablePayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    file: string
    upload_at: Date
  }, ExtArgs["result"]["banner_more_profitable_file"]>
  composites: {}
}

/**
 * Model banner_more_profitable_file
 * 
 */
export type banner_more_profitable_file = runtime.Types.DefaultSelection<banner_more_profitable_filePayload>
export type bet_operationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "bet_operations"
  objects: {
    user: userPayload<ExtArgs>
    slot_games: slot_gamesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    user_id: number
    slot_game_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id: string | null
    created_at: Date
    updated_at: Date
  }, ExtArgs["result"]["bet_operations"]>
  composites: {}
}

/**
 * Model bet_operations
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bet_operations = runtime.Types.DefaultSelection<bet_operationsPayload>
export type casino_most_popularPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "casino_most_popular"
  objects: {
    casino_most_popular_slot_games: casino_most_popular_slot_gamesPayload<ExtArgs>[]
    slot_settings: slot_settingsPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    qty_lines: number
    qty_columns: number
  }, ExtArgs["result"]["casino_most_popular"]>
  composites: {}
}

/**
 * Model casino_most_popular
 * 
 */
export type casino_most_popular = runtime.Types.DefaultSelection<casino_most_popularPayload>
export type casino_most_popular_slot_gamesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "casino_most_popular_slot_games"
  objects: {
    slot_games: slot_gamesPayload<ExtArgs>
    casino_most_popular: casino_most_popularPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    casino_most_popular_id: number
    slot_games_id: number
  }, ExtArgs["result"]["casino_most_popular_slot_games"]>
  composites: {}
}

/**
 * Model casino_most_popular_slot_games
 * 
 */
export type casino_most_popular_slot_games = runtime.Types.DefaultSelection<casino_most_popular_slot_gamesPayload>
export type clientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "client"
  objects: {
    settings_client_settings_idTosettings: settingsPayload<ExtArgs> | null
    client_auth_user: client_auth_userPayload<ExtArgs>[]
    settings_settings_client_idToclient: settingsPayload<ExtArgs>[]
    user: userPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    settings_id: number | null
    key_id_prod: string | null
    key_secret_prod: string | null
    key_id_stage: string | null
    key_secret_stage: string | null
    currency: string | null
    language: string | null
    url_return: string | null
    created_at: Date
    updated_at: Date
    name: string | null
    prod_callback: string | null
    stage_callback: string | null
  }, ExtArgs["result"]["client"]>
  composites: {}
}

/**
 * Model client
 * 
 */
export type client = runtime.Types.DefaultSelection<clientPayload>
export type client_auth_userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "client_auth_user"
  objects: {
    client: clientPayload<ExtArgs>
    auth_user: auth_userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    client_id: number
    auth_user_id: number
  }, ExtArgs["result"]["client_auth_user"]>
  composites: {}
}

/**
 * Model client_auth_user
 * 
 */
export type client_auth_user = runtime.Types.DefaultSelection<client_auth_userPayload>
export type doctrine_migration_versionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "doctrine_migration_versions"
  objects: {}
  scalars: $Extensions.GetResult<{
    version: string
    executed_at: Date | null
    execution_time: number | null
  }, ExtArgs["result"]["doctrine_migration_versions"]>
  composites: {}
}

/**
 * Model doctrine_migration_versions
 * 
 */
export type doctrine_migration_versions = runtime.Types.DefaultSelection<doctrine_migration_versionsPayload>
export type filePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "file"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    file: string
    upload_at: Date
  }, ExtArgs["result"]["file"]>
  composites: {}
}

/**
 * Model file
 * 
 */
export type file = runtime.Types.DefaultSelection<filePayload>
export type layout_colorsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "layout_colors"
  objects: {
    settings: settingsPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    settings_id: number | null
    name: string
    hexadecimal: string
  }, ExtArgs["result"]["layout_colors"]>
  composites: {}
}

/**
 * Model layout_colors
 * 
 */
export type layout_colors = runtime.Types.DefaultSelection<layout_colorsPayload>
export type live_casino_most_popularPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "live_casino_most_popular"
  objects: {
    live_casino_most_popular_slot_games: live_casino_most_popular_slot_gamesPayload<ExtArgs>[]
    slot_settings: slot_settingsPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    qty_lines: number
    qty_columns: number
  }, ExtArgs["result"]["live_casino_most_popular"]>
  composites: {}
}

/**
 * Model live_casino_most_popular
 * 
 */
export type live_casino_most_popular = runtime.Types.DefaultSelection<live_casino_most_popularPayload>
export type live_casino_most_popular_slot_gamesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "live_casino_most_popular_slot_games"
  objects: {
    live_casino_most_popular: live_casino_most_popularPayload<ExtArgs>
    slot_games: slot_gamesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    live_casino_most_popular_id: number
    slot_games_id: number
  }, ExtArgs["result"]["live_casino_most_popular_slot_games"]>
  composites: {}
}

/**
 * Model live_casino_most_popular_slot_games
 * 
 */
export type live_casino_most_popular_slot_games = runtime.Types.DefaultSelection<live_casino_most_popular_slot_gamesPayload>
export type messenger_messagesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "messenger_messages"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: bigint
    body: string
    headers: string
    queue_name: string
    created_at: Date
    available_at: Date
    delivered_at: Date | null
  }, ExtArgs["result"]["messenger_messages"]>
  composites: {}
}

/**
 * Model messenger_messages
 * 
 */
export type messenger_messages = runtime.Types.DefaultSelection<messenger_messagesPayload>
export type operationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "operations"
  objects: {
    settings: settingsPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    active: boolean
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: Date
    updated_at: Date
  }, ExtArgs["result"]["operations"]>
  composites: {}
}

/**
 * Model operations
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type operations = runtime.Types.DefaultSelection<operationsPayload>
export type providerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "provider"
  objects: {
    slot_games: slot_gamesPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    client_percent: number | null
    base_percent: number | null
  }, ExtArgs["result"]["provider"]>
  composites: {}
}

/**
 * Model provider
 * 
 */
export type provider = runtime.Types.DefaultSelection<providerPayload>
export type referral_historyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "referral_history"
  objects: {
    user_referral_history_referral_idTouser: userPayload<ExtArgs>
    user_referral_history_user_idTouser: userPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    referral_id: number
    user_id: number | null
    game: string | null
    amount: number | null
    type: string | null
    available: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }, ExtArgs["result"]["referral_history"]>
  composites: {}
}

/**
 * Model referral_history
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type referral_history = runtime.Types.DefaultSelection<referral_historyPayload>
export type referral_settingsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "referral_settings"
  objects: {
    user: userPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    cpa: number | null
    rev_share_percent: number | null
    referral_type: string | null
  }, ExtArgs["result"]["referral_settings"]>
  composites: {}
}

/**
 * Model referral_settings
 * 
 */
export type referral_settings = runtime.Types.DefaultSelection<referral_settingsPayload>
export type settingsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "settings"
  objects: {
    client_client_settings_idTosettings: clientPayload<ExtArgs> | null
    layout_colors: layout_colorsPayload<ExtArgs>[]
    client_settings_client_idToclient: clientPayload<ExtArgs>
    operations: operationsPayload<ExtArgs> | null
    slot_settings: slot_settingsPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    operations_id: number | null
    slot_settings_id: number | null
    client_id: number
    created_at: Date
    updated_at: Date
  }, ExtArgs["result"]["settings"]>
  composites: {}
}

/**
 * Model settings
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type settings = runtime.Types.DefaultSelection<settingsPayload>
export type slot_gamesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "slot_games"
  objects: {
    bet_operations: bet_operationsPayload<ExtArgs>[]
    casino_most_popular_slot_games: casino_most_popular_slot_gamesPayload<ExtArgs>[]
    live_casino_most_popular_slot_games: live_casino_most_popular_slot_gamesPayload<ExtArgs>[]
    provider: providerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    provider_id: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug: string | null
  }, ExtArgs["result"]["slot_games"]>
  composites: {}
}

/**
 * Model slot_games
 * 
 */
export type slot_games = runtime.Types.DefaultSelection<slot_gamesPayload>
export type slot_settingsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "slot_settings"
  objects: {
    banner_more_profitable: banner_more_profitablePayload<ExtArgs>[]
    settings: settingsPayload<ExtArgs> | null
    live_casino_most_popular: live_casino_most_popularPayload<ExtArgs> | null
    casino_most_popular: casino_most_popularPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    casino_most_popular_id: number | null
    live_casino_most_popular_id: number | null
  }, ExtArgs["result"]["slot_settings"]>
  composites: {}
}

/**
 * Model slot_settings
 * 
 */
export type slot_settings = runtime.Types.DefaultSelection<slot_settingsPayload>
export type userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "user"
  objects: {
    bet_operations: bet_operationsPayload<ExtArgs>[]
    referral_history_referral_history_referral_idTouser: referral_historyPayload<ExtArgs>[]
    referral_history_referral_history_user_idTouser: referral_historyPayload<ExtArgs>[]
    client: clientPayload<ExtArgs>
    user: userPayload<ExtArgs> | null
    other_user: userPayload<ExtArgs>[]
    referral_settings: referral_settingsPayload<ExtArgs> | null
    wallet: walletPayload<ExtArgs>
    wallet_transaction: wallet_transactionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    wallet_id: number
    client_id: number
    referral_id: number | null
    referral_settings_id: number | null
    external_id: number
    username: string
    balance: Prisma.Decimal | null
    created_at: Date
    updated_at: Date
    session: string | null
    cpa_collected: boolean | null
    is_referrer: boolean | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model user
 * 
 */
export type user = runtime.Types.DefaultSelection<userPayload>
export type walletPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "wallet"
  objects: {
    user: userPayload<ExtArgs> | null
    wallet_transaction: wallet_transactionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    balance: number | null
    bonus: number | null
    bet: number | null
    withdraw: number | null
    deposit: number | null
  }, ExtArgs["result"]["wallet"]>
  composites: {}
}

/**
 * Model wallet
 * 
 */
export type wallet = runtime.Types.DefaultSelection<walletPayload>
export type wallet_transactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "wallet_transaction"
  objects: {
    wallet: walletPayload<ExtArgs>
    user: userPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    wallet_id: number
    amount: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    type: string
    api_collected: boolean | null
    user_id: number | null
    uuid: string
  }, ExtArgs["result"]["wallet_transaction"]>
  composites: {}
}

/**
 * Model wallet_transaction
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type wallet_transaction = runtime.Types.DefaultSelection<wallet_transactionPayload>
export type salsa_gamesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "salsa_games"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    code: string
    isSlot: boolean
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
  }, ExtArgs["result"]["salsa_games"]>
  composites: {}
}

/**
 * Model salsa_games
 * 
 */
export type salsa_games = runtime.Types.DefaultSelection<salsa_gamesPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Api_requests
 * const api_requests = await prisma.api_request.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Api_requests
   * const api_requests = await prisma.api_request.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.api_request`: Exposes CRUD operations for the **api_request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Api_requests
    * const api_requests = await prisma.api_request.findMany()
    * ```
    */
  get api_request(): Prisma.api_requestDelegate<ExtArgs>;

  /**
   * `prisma.auth_user`: Exposes CRUD operations for the **auth_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_users
    * const auth_users = await prisma.auth_user.findMany()
    * ```
    */
  get auth_user(): Prisma.auth_userDelegate<ExtArgs>;

  /**
   * `prisma.banner_more_profitable`: Exposes CRUD operations for the **banner_more_profitable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banner_more_profitables
    * const banner_more_profitables = await prisma.banner_more_profitable.findMany()
    * ```
    */
  get banner_more_profitable(): Prisma.banner_more_profitableDelegate<ExtArgs>;

  /**
   * `prisma.banner_more_profitable_file`: Exposes CRUD operations for the **banner_more_profitable_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banner_more_profitable_files
    * const banner_more_profitable_files = await prisma.banner_more_profitable_file.findMany()
    * ```
    */
  get banner_more_profitable_file(): Prisma.banner_more_profitable_fileDelegate<ExtArgs>;

  /**
   * `prisma.bet_operations`: Exposes CRUD operations for the **bet_operations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bet_operations
    * const bet_operations = await prisma.bet_operations.findMany()
    * ```
    */
  get bet_operations(): Prisma.bet_operationsDelegate<ExtArgs>;

  /**
   * `prisma.casino_most_popular`: Exposes CRUD operations for the **casino_most_popular** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Casino_most_populars
    * const casino_most_populars = await prisma.casino_most_popular.findMany()
    * ```
    */
  get casino_most_popular(): Prisma.casino_most_popularDelegate<ExtArgs>;

  /**
   * `prisma.casino_most_popular_slot_games`: Exposes CRUD operations for the **casino_most_popular_slot_games** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Casino_most_popular_slot_games
    * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.findMany()
    * ```
    */
  get casino_most_popular_slot_games(): Prisma.casino_most_popular_slot_gamesDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.clientDelegate<ExtArgs>;

  /**
   * `prisma.client_auth_user`: Exposes CRUD operations for the **client_auth_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Client_auth_users
    * const client_auth_users = await prisma.client_auth_user.findMany()
    * ```
    */
  get client_auth_user(): Prisma.client_auth_userDelegate<ExtArgs>;

  /**
   * `prisma.doctrine_migration_versions`: Exposes CRUD operations for the **doctrine_migration_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctrine_migration_versions
    * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany()
    * ```
    */
  get doctrine_migration_versions(): Prisma.doctrine_migration_versionsDelegate<ExtArgs>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.fileDelegate<ExtArgs>;

  /**
   * `prisma.layout_colors`: Exposes CRUD operations for the **layout_colors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Layout_colors
    * const layout_colors = await prisma.layout_colors.findMany()
    * ```
    */
  get layout_colors(): Prisma.layout_colorsDelegate<ExtArgs>;

  /**
   * `prisma.live_casino_most_popular`: Exposes CRUD operations for the **live_casino_most_popular** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Live_casino_most_populars
    * const live_casino_most_populars = await prisma.live_casino_most_popular.findMany()
    * ```
    */
  get live_casino_most_popular(): Prisma.live_casino_most_popularDelegate<ExtArgs>;

  /**
   * `prisma.live_casino_most_popular_slot_games`: Exposes CRUD operations for the **live_casino_most_popular_slot_games** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Live_casino_most_popular_slot_games
    * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.findMany()
    * ```
    */
  get live_casino_most_popular_slot_games(): Prisma.live_casino_most_popular_slot_gamesDelegate<ExtArgs>;

  /**
   * `prisma.messenger_messages`: Exposes CRUD operations for the **messenger_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messenger_messages
    * const messenger_messages = await prisma.messenger_messages.findMany()
    * ```
    */
  get messenger_messages(): Prisma.messenger_messagesDelegate<ExtArgs>;

  /**
   * `prisma.operations`: Exposes CRUD operations for the **operations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operations
    * const operations = await prisma.operations.findMany()
    * ```
    */
  get operations(): Prisma.operationsDelegate<ExtArgs>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.providerDelegate<ExtArgs>;

  /**
   * `prisma.referral_history`: Exposes CRUD operations for the **referral_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_histories
    * const referral_histories = await prisma.referral_history.findMany()
    * ```
    */
  get referral_history(): Prisma.referral_historyDelegate<ExtArgs>;

  /**
   * `prisma.referral_settings`: Exposes CRUD operations for the **referral_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_settings
    * const referral_settings = await prisma.referral_settings.findMany()
    * ```
    */
  get referral_settings(): Prisma.referral_settingsDelegate<ExtArgs>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<ExtArgs>;

  /**
   * `prisma.slot_games`: Exposes CRUD operations for the **slot_games** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slot_games
    * const slot_games = await prisma.slot_games.findMany()
    * ```
    */
  get slot_games(): Prisma.slot_gamesDelegate<ExtArgs>;

  /**
   * `prisma.slot_settings`: Exposes CRUD operations for the **slot_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slot_settings
    * const slot_settings = await prisma.slot_settings.findMany()
    * ```
    */
  get slot_settings(): Prisma.slot_settingsDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.walletDelegate<ExtArgs>;

  /**
   * `prisma.wallet_transaction`: Exposes CRUD operations for the **wallet_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_transactions
    * const wallet_transactions = await prisma.wallet_transaction.findMany()
    * ```
    */
  get wallet_transaction(): Prisma.wallet_transactionDelegate<ExtArgs>;

  /**
   * `prisma.salsa_games`: Exposes CRUD operations for the **salsa_games** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salsa_games
    * const salsa_games = await prisma.salsa_games.findMany()
    * ```
    */
  get salsa_games(): Prisma.salsa_gamesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 5.0.0
   * Query Engine version: 6b0aef69b7cdfc787f822ecd7cdc76d5f1991584
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    api_request: 'api_request',
    auth_user: 'auth_user',
    banner_more_profitable: 'banner_more_profitable',
    banner_more_profitable_file: 'banner_more_profitable_file',
    bet_operations: 'bet_operations',
    casino_most_popular: 'casino_most_popular',
    casino_most_popular_slot_games: 'casino_most_popular_slot_games',
    client: 'client',
    client_auth_user: 'client_auth_user',
    doctrine_migration_versions: 'doctrine_migration_versions',
    file: 'file',
    layout_colors: 'layout_colors',
    live_casino_most_popular: 'live_casino_most_popular',
    live_casino_most_popular_slot_games: 'live_casino_most_popular_slot_games',
    messenger_messages: 'messenger_messages',
    operations: 'operations',
    provider: 'provider',
    referral_history: 'referral_history',
    referral_settings: 'referral_settings',
    settings: 'settings',
    slot_games: 'slot_games',
    slot_settings: 'slot_settings',
    user: 'user',
    wallet: 'wallet',
    wallet_transaction: 'wallet_transaction',
    salsa_games: 'salsa_games'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'api_request' | 'auth_user' | 'banner_more_profitable' | 'banner_more_profitable_file' | 'bet_operations' | 'casino_most_popular' | 'casino_most_popular_slot_games' | 'client' | 'client_auth_user' | 'doctrine_migration_versions' | 'file' | 'layout_colors' | 'live_casino_most_popular' | 'live_casino_most_popular_slot_games' | 'messenger_messages' | 'operations' | 'provider' | 'referral_history' | 'referral_settings' | 'settings' | 'slot_games' | 'slot_settings' | 'user' | 'wallet' | 'wallet_transaction' | 'salsa_games'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      api_request: {
        payload: api_requestPayload<ExtArgs>
        fields: Prisma.api_requestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.api_requestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.api_requestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload>
          }
          findFirst: {
            args: Prisma.api_requestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.api_requestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload>
          }
          findMany: {
            args: Prisma.api_requestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload>[]
          }
          create: {
            args: Prisma.api_requestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload>
          }
          createMany: {
            args: Prisma.api_requestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.api_requestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload>
          }
          update: {
            args: Prisma.api_requestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload>
          }
          deleteMany: {
            args: Prisma.api_requestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.api_requestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.api_requestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<api_requestPayload>
          }
          aggregate: {
            args: Prisma.Api_requestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApi_request>
          }
          groupBy: {
            args: Prisma.api_requestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Api_requestGroupByOutputType>[]
          }
          count: {
            args: Prisma.api_requestCountArgs<ExtArgs>,
            result: $Utils.Optional<Api_requestCountAggregateOutputType> | number
          }
        }
      }
      auth_user: {
        payload: auth_userPayload<ExtArgs>
        fields: Prisma.auth_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auth_userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auth_userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload>
          }
          findFirst: {
            args: Prisma.auth_userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auth_userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload>
          }
          findMany: {
            args: Prisma.auth_userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload>[]
          }
          create: {
            args: Prisma.auth_userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload>
          }
          createMany: {
            args: Prisma.auth_userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.auth_userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload>
          }
          update: {
            args: Prisma.auth_userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload>
          }
          deleteMany: {
            args: Prisma.auth_userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.auth_userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.auth_userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auth_userPayload>
          }
          aggregate: {
            args: Prisma.Auth_userAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuth_user>
          }
          groupBy: {
            args: Prisma.auth_userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Auth_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.auth_userCountArgs<ExtArgs>,
            result: $Utils.Optional<Auth_userCountAggregateOutputType> | number
          }
        }
      }
      banner_more_profitable: {
        payload: banner_more_profitablePayload<ExtArgs>
        fields: Prisma.banner_more_profitableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banner_more_profitableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banner_more_profitableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload>
          }
          findFirst: {
            args: Prisma.banner_more_profitableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banner_more_profitableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload>
          }
          findMany: {
            args: Prisma.banner_more_profitableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload>[]
          }
          create: {
            args: Prisma.banner_more_profitableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload>
          }
          createMany: {
            args: Prisma.banner_more_profitableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.banner_more_profitableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload>
          }
          update: {
            args: Prisma.banner_more_profitableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload>
          }
          deleteMany: {
            args: Prisma.banner_more_profitableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.banner_more_profitableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.banner_more_profitableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitablePayload>
          }
          aggregate: {
            args: Prisma.Banner_more_profitableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanner_more_profitable>
          }
          groupBy: {
            args: Prisma.banner_more_profitableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Banner_more_profitableGroupByOutputType>[]
          }
          count: {
            args: Prisma.banner_more_profitableCountArgs<ExtArgs>,
            result: $Utils.Optional<Banner_more_profitableCountAggregateOutputType> | number
          }
        }
      }
      banner_more_profitable_file: {
        payload: banner_more_profitable_filePayload<ExtArgs>
        fields: Prisma.banner_more_profitable_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banner_more_profitable_fileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banner_more_profitable_fileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload>
          }
          findFirst: {
            args: Prisma.banner_more_profitable_fileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banner_more_profitable_fileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload>
          }
          findMany: {
            args: Prisma.banner_more_profitable_fileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload>[]
          }
          create: {
            args: Prisma.banner_more_profitable_fileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload>
          }
          createMany: {
            args: Prisma.banner_more_profitable_fileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.banner_more_profitable_fileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload>
          }
          update: {
            args: Prisma.banner_more_profitable_fileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload>
          }
          deleteMany: {
            args: Prisma.banner_more_profitable_fileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.banner_more_profitable_fileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.banner_more_profitable_fileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<banner_more_profitable_filePayload>
          }
          aggregate: {
            args: Prisma.Banner_more_profitable_fileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanner_more_profitable_file>
          }
          groupBy: {
            args: Prisma.banner_more_profitable_fileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Banner_more_profitable_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.banner_more_profitable_fileCountArgs<ExtArgs>,
            result: $Utils.Optional<Banner_more_profitable_fileCountAggregateOutputType> | number
          }
        }
      }
      bet_operations: {
        payload: bet_operationsPayload<ExtArgs>
        fields: Prisma.bet_operationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bet_operationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bet_operationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload>
          }
          findFirst: {
            args: Prisma.bet_operationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bet_operationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload>
          }
          findMany: {
            args: Prisma.bet_operationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload>[]
          }
          create: {
            args: Prisma.bet_operationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload>
          }
          createMany: {
            args: Prisma.bet_operationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bet_operationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload>
          }
          update: {
            args: Prisma.bet_operationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload>
          }
          deleteMany: {
            args: Prisma.bet_operationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bet_operationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bet_operationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bet_operationsPayload>
          }
          aggregate: {
            args: Prisma.Bet_operationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBet_operations>
          }
          groupBy: {
            args: Prisma.bet_operationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bet_operationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bet_operationsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bet_operationsCountAggregateOutputType> | number
          }
        }
      }
      casino_most_popular: {
        payload: casino_most_popularPayload<ExtArgs>
        fields: Prisma.casino_most_popularFieldRefs
        operations: {
          findUnique: {
            args: Prisma.casino_most_popularFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.casino_most_popularFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload>
          }
          findFirst: {
            args: Prisma.casino_most_popularFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.casino_most_popularFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload>
          }
          findMany: {
            args: Prisma.casino_most_popularFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload>[]
          }
          create: {
            args: Prisma.casino_most_popularCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload>
          }
          createMany: {
            args: Prisma.casino_most_popularCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.casino_most_popularDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload>
          }
          update: {
            args: Prisma.casino_most_popularUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload>
          }
          deleteMany: {
            args: Prisma.casino_most_popularDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.casino_most_popularUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.casino_most_popularUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popularPayload>
          }
          aggregate: {
            args: Prisma.Casino_most_popularAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCasino_most_popular>
          }
          groupBy: {
            args: Prisma.casino_most_popularGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Casino_most_popularGroupByOutputType>[]
          }
          count: {
            args: Prisma.casino_most_popularCountArgs<ExtArgs>,
            result: $Utils.Optional<Casino_most_popularCountAggregateOutputType> | number
          }
        }
      }
      casino_most_popular_slot_games: {
        payload: casino_most_popular_slot_gamesPayload<ExtArgs>
        fields: Prisma.casino_most_popular_slot_gamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload>
          }
          findFirst: {
            args: Prisma.casino_most_popular_slot_gamesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload>
          }
          findMany: {
            args: Prisma.casino_most_popular_slot_gamesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload>[]
          }
          create: {
            args: Prisma.casino_most_popular_slot_gamesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload>
          }
          createMany: {
            args: Prisma.casino_most_popular_slot_gamesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.casino_most_popular_slot_gamesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload>
          }
          update: {
            args: Prisma.casino_most_popular_slot_gamesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload>
          }
          deleteMany: {
            args: Prisma.casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.casino_most_popular_slot_gamesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<casino_most_popular_slot_gamesPayload>
          }
          aggregate: {
            args: Prisma.Casino_most_popular_slot_gamesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCasino_most_popular_slot_games>
          }
          groupBy: {
            args: Prisma.casino_most_popular_slot_gamesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Casino_most_popular_slot_gamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.casino_most_popular_slot_gamesCountArgs<ExtArgs>,
            result: $Utils.Optional<Casino_most_popular_slot_gamesCountAggregateOutputType> | number
          }
        }
      }
      client: {
        payload: clientPayload<ExtArgs>
        fields: Prisma.clientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload>
          }
          findFirst: {
            args: Prisma.clientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload>
          }
          findMany: {
            args: Prisma.clientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload>[]
          }
          create: {
            args: Prisma.clientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload>
          }
          createMany: {
            args: Prisma.clientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.clientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload>
          }
          update: {
            args: Prisma.clientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload>
          }
          deleteMany: {
            args: Prisma.clientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.clientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.clientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<clientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.clientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      client_auth_user: {
        payload: client_auth_userPayload<ExtArgs>
        fields: Prisma.client_auth_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.client_auth_userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.client_auth_userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload>
          }
          findFirst: {
            args: Prisma.client_auth_userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.client_auth_userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload>
          }
          findMany: {
            args: Prisma.client_auth_userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload>[]
          }
          create: {
            args: Prisma.client_auth_userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload>
          }
          createMany: {
            args: Prisma.client_auth_userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.client_auth_userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload>
          }
          update: {
            args: Prisma.client_auth_userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload>
          }
          deleteMany: {
            args: Prisma.client_auth_userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.client_auth_userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.client_auth_userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<client_auth_userPayload>
          }
          aggregate: {
            args: Prisma.Client_auth_userAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient_auth_user>
          }
          groupBy: {
            args: Prisma.client_auth_userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Client_auth_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.client_auth_userCountArgs<ExtArgs>,
            result: $Utils.Optional<Client_auth_userCountAggregateOutputType> | number
          }
        }
      }
      doctrine_migration_versions: {
        payload: doctrine_migration_versionsPayload<ExtArgs>
        fields: Prisma.doctrine_migration_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.doctrine_migration_versionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload>
          }
          findFirst: {
            args: Prisma.doctrine_migration_versionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload>
          }
          findMany: {
            args: Prisma.doctrine_migration_versionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload>[]
          }
          create: {
            args: Prisma.doctrine_migration_versionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload>
          }
          createMany: {
            args: Prisma.doctrine_migration_versionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.doctrine_migration_versionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload>
          }
          update: {
            args: Prisma.doctrine_migration_versionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload>
          }
          deleteMany: {
            args: Prisma.doctrine_migration_versionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.doctrine_migration_versionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.doctrine_migration_versionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<doctrine_migration_versionsPayload>
          }
          aggregate: {
            args: Prisma.Doctrine_migration_versionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDoctrine_migration_versions>
          }
          groupBy: {
            args: Prisma.doctrine_migration_versionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Doctrine_migration_versionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.doctrine_migration_versionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Doctrine_migration_versionsCountAggregateOutputType> | number
          }
        }
      }
      file: {
        payload: filePayload<ExtArgs>
        fields: Prisma.fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload>
          }
          findFirst: {
            args: Prisma.fileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload>
          }
          findMany: {
            args: Prisma.fileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload>[]
          }
          create: {
            args: Prisma.fileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload>
          }
          createMany: {
            args: Prisma.fileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload>
          }
          update: {
            args: Prisma.fileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload>
          }
          deleteMany: {
            args: Prisma.fileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<filePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.fileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.fileCountArgs<ExtArgs>,
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      layout_colors: {
        payload: layout_colorsPayload<ExtArgs>
        fields: Prisma.layout_colorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.layout_colorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.layout_colorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload>
          }
          findFirst: {
            args: Prisma.layout_colorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.layout_colorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload>
          }
          findMany: {
            args: Prisma.layout_colorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload>[]
          }
          create: {
            args: Prisma.layout_colorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload>
          }
          createMany: {
            args: Prisma.layout_colorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.layout_colorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload>
          }
          update: {
            args: Prisma.layout_colorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload>
          }
          deleteMany: {
            args: Prisma.layout_colorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.layout_colorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.layout_colorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<layout_colorsPayload>
          }
          aggregate: {
            args: Prisma.Layout_colorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLayout_colors>
          }
          groupBy: {
            args: Prisma.layout_colorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Layout_colorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.layout_colorsCountArgs<ExtArgs>,
            result: $Utils.Optional<Layout_colorsCountAggregateOutputType> | number
          }
        }
      }
      live_casino_most_popular: {
        payload: live_casino_most_popularPayload<ExtArgs>
        fields: Prisma.live_casino_most_popularFieldRefs
        operations: {
          findUnique: {
            args: Prisma.live_casino_most_popularFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.live_casino_most_popularFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload>
          }
          findFirst: {
            args: Prisma.live_casino_most_popularFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.live_casino_most_popularFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload>
          }
          findMany: {
            args: Prisma.live_casino_most_popularFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload>[]
          }
          create: {
            args: Prisma.live_casino_most_popularCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload>
          }
          createMany: {
            args: Prisma.live_casino_most_popularCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.live_casino_most_popularDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload>
          }
          update: {
            args: Prisma.live_casino_most_popularUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload>
          }
          deleteMany: {
            args: Prisma.live_casino_most_popularDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.live_casino_most_popularUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.live_casino_most_popularUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popularPayload>
          }
          aggregate: {
            args: Prisma.Live_casino_most_popularAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLive_casino_most_popular>
          }
          groupBy: {
            args: Prisma.live_casino_most_popularGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Live_casino_most_popularGroupByOutputType>[]
          }
          count: {
            args: Prisma.live_casino_most_popularCountArgs<ExtArgs>,
            result: $Utils.Optional<Live_casino_most_popularCountAggregateOutputType> | number
          }
        }
      }
      live_casino_most_popular_slot_games: {
        payload: live_casino_most_popular_slot_gamesPayload<ExtArgs>
        fields: Prisma.live_casino_most_popular_slot_gamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.live_casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.live_casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload>
          }
          findFirst: {
            args: Prisma.live_casino_most_popular_slot_gamesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.live_casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload>
          }
          findMany: {
            args: Prisma.live_casino_most_popular_slot_gamesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload>[]
          }
          create: {
            args: Prisma.live_casino_most_popular_slot_gamesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload>
          }
          createMany: {
            args: Prisma.live_casino_most_popular_slot_gamesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.live_casino_most_popular_slot_gamesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload>
          }
          update: {
            args: Prisma.live_casino_most_popular_slot_gamesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload>
          }
          deleteMany: {
            args: Prisma.live_casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.live_casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.live_casino_most_popular_slot_gamesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<live_casino_most_popular_slot_gamesPayload>
          }
          aggregate: {
            args: Prisma.Live_casino_most_popular_slot_gamesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLive_casino_most_popular_slot_games>
          }
          groupBy: {
            args: Prisma.live_casino_most_popular_slot_gamesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Live_casino_most_popular_slot_gamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.live_casino_most_popular_slot_gamesCountArgs<ExtArgs>,
            result: $Utils.Optional<Live_casino_most_popular_slot_gamesCountAggregateOutputType> | number
          }
        }
      }
      messenger_messages: {
        payload: messenger_messagesPayload<ExtArgs>
        fields: Prisma.messenger_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messenger_messagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messenger_messagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload>
          }
          findFirst: {
            args: Prisma.messenger_messagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messenger_messagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload>
          }
          findMany: {
            args: Prisma.messenger_messagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload>[]
          }
          create: {
            args: Prisma.messenger_messagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload>
          }
          createMany: {
            args: Prisma.messenger_messagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.messenger_messagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload>
          }
          update: {
            args: Prisma.messenger_messagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload>
          }
          deleteMany: {
            args: Prisma.messenger_messagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.messenger_messagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.messenger_messagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messenger_messagesPayload>
          }
          aggregate: {
            args: Prisma.Messenger_messagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessenger_messages>
          }
          groupBy: {
            args: Prisma.messenger_messagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Messenger_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messenger_messagesCountArgs<ExtArgs>,
            result: $Utils.Optional<Messenger_messagesCountAggregateOutputType> | number
          }
        }
      }
      operations: {
        payload: operationsPayload<ExtArgs>
        fields: Prisma.operationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.operationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.operationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload>
          }
          findFirst: {
            args: Prisma.operationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.operationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload>
          }
          findMany: {
            args: Prisma.operationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload>[]
          }
          create: {
            args: Prisma.operationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload>
          }
          createMany: {
            args: Prisma.operationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.operationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload>
          }
          update: {
            args: Prisma.operationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload>
          }
          deleteMany: {
            args: Prisma.operationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.operationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.operationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operationsPayload>
          }
          aggregate: {
            args: Prisma.OperationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOperations>
          }
          groupBy: {
            args: Prisma.operationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OperationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.operationsCountArgs<ExtArgs>,
            result: $Utils.Optional<OperationsCountAggregateOutputType> | number
          }
        }
      }
      provider: {
        payload: providerPayload<ExtArgs>
        fields: Prisma.providerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.providerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.providerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload>
          }
          findFirst: {
            args: Prisma.providerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.providerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload>
          }
          findMany: {
            args: Prisma.providerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload>[]
          }
          create: {
            args: Prisma.providerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload>
          }
          createMany: {
            args: Prisma.providerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.providerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload>
          }
          update: {
            args: Prisma.providerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload>
          }
          deleteMany: {
            args: Prisma.providerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.providerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.providerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<providerPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.providerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.providerCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      referral_history: {
        payload: referral_historyPayload<ExtArgs>
        fields: Prisma.referral_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_historyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_historyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload>
          }
          findFirst: {
            args: Prisma.referral_historyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_historyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload>
          }
          findMany: {
            args: Prisma.referral_historyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload>[]
          }
          create: {
            args: Prisma.referral_historyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload>
          }
          createMany: {
            args: Prisma.referral_historyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.referral_historyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload>
          }
          update: {
            args: Prisma.referral_historyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload>
          }
          deleteMany: {
            args: Prisma.referral_historyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.referral_historyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.referral_historyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_historyPayload>
          }
          aggregate: {
            args: Prisma.Referral_historyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReferral_history>
          }
          groupBy: {
            args: Prisma.referral_historyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Referral_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_historyCountArgs<ExtArgs>,
            result: $Utils.Optional<Referral_historyCountAggregateOutputType> | number
          }
        }
      }
      referral_settings: {
        payload: referral_settingsPayload<ExtArgs>
        fields: Prisma.referral_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_settingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_settingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload>
          }
          findFirst: {
            args: Prisma.referral_settingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_settingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload>
          }
          findMany: {
            args: Prisma.referral_settingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload>[]
          }
          create: {
            args: Prisma.referral_settingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload>
          }
          createMany: {
            args: Prisma.referral_settingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.referral_settingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload>
          }
          update: {
            args: Prisma.referral_settingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload>
          }
          deleteMany: {
            args: Prisma.referral_settingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.referral_settingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.referral_settingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<referral_settingsPayload>
          }
          aggregate: {
            args: Prisma.Referral_settingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReferral_settings>
          }
          groupBy: {
            args: Prisma.referral_settingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Referral_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_settingsCountArgs<ExtArgs>,
            result: $Utils.Optional<Referral_settingsCountAggregateOutputType> | number
          }
        }
      }
      settings: {
        payload: settingsPayload<ExtArgs>
        fields: Prisma.settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload>
          }
          findFirst: {
            args: Prisma.settingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload>
          }
          findMany: {
            args: Prisma.settingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload>[]
          }
          create: {
            args: Prisma.settingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload>
          }
          createMany: {
            args: Prisma.settingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.settingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload>
          }
          update: {
            args: Prisma.settingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload>
          }
          deleteMany: {
            args: Prisma.settingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.settingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.settingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<settingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.settingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingsCountArgs<ExtArgs>,
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      slot_games: {
        payload: slot_gamesPayload<ExtArgs>
        fields: Prisma.slot_gamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.slot_gamesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.slot_gamesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload>
          }
          findFirst: {
            args: Prisma.slot_gamesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.slot_gamesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload>
          }
          findMany: {
            args: Prisma.slot_gamesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload>[]
          }
          create: {
            args: Prisma.slot_gamesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload>
          }
          createMany: {
            args: Prisma.slot_gamesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.slot_gamesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload>
          }
          update: {
            args: Prisma.slot_gamesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload>
          }
          deleteMany: {
            args: Prisma.slot_gamesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.slot_gamesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.slot_gamesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_gamesPayload>
          }
          aggregate: {
            args: Prisma.Slot_gamesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSlot_games>
          }
          groupBy: {
            args: Prisma.slot_gamesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Slot_gamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.slot_gamesCountArgs<ExtArgs>,
            result: $Utils.Optional<Slot_gamesCountAggregateOutputType> | number
          }
        }
      }
      slot_settings: {
        payload: slot_settingsPayload<ExtArgs>
        fields: Prisma.slot_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.slot_settingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.slot_settingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload>
          }
          findFirst: {
            args: Prisma.slot_settingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.slot_settingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload>
          }
          findMany: {
            args: Prisma.slot_settingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload>[]
          }
          create: {
            args: Prisma.slot_settingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload>
          }
          createMany: {
            args: Prisma.slot_settingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.slot_settingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload>
          }
          update: {
            args: Prisma.slot_settingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload>
          }
          deleteMany: {
            args: Prisma.slot_settingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.slot_settingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.slot_settingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<slot_settingsPayload>
          }
          aggregate: {
            args: Prisma.Slot_settingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSlot_settings>
          }
          groupBy: {
            args: Prisma.slot_settingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Slot_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.slot_settingsCountArgs<ExtArgs>,
            result: $Utils.Optional<Slot_settingsCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      wallet: {
        payload: walletPayload<ExtArgs>
        fields: Prisma.walletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          findFirst: {
            args: Prisma.walletFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          findMany: {
            args: Prisma.walletFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>[]
          }
          create: {
            args: Prisma.walletCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          createMany: {
            args: Prisma.walletCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.walletDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          update: {
            args: Prisma.walletUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          deleteMany: {
            args: Prisma.walletDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.walletUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.walletUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<walletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.walletGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletCountArgs<ExtArgs>,
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      wallet_transaction: {
        payload: wallet_transactionPayload<ExtArgs>
        fields: Prisma.wallet_transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_transactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_transactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload>
          }
          findFirst: {
            args: Prisma.wallet_transactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_transactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload>
          }
          findMany: {
            args: Prisma.wallet_transactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload>[]
          }
          create: {
            args: Prisma.wallet_transactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload>
          }
          createMany: {
            args: Prisma.wallet_transactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.wallet_transactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload>
          }
          update: {
            args: Prisma.wallet_transactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload>
          }
          deleteMany: {
            args: Prisma.wallet_transactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_transactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.wallet_transactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<wallet_transactionPayload>
          }
          aggregate: {
            args: Prisma.Wallet_transactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWallet_transaction>
          }
          groupBy: {
            args: Prisma.wallet_transactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Wallet_transactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_transactionCountArgs<ExtArgs>,
            result: $Utils.Optional<Wallet_transactionCountAggregateOutputType> | number
          }
        }
      }
      salsa_games: {
        payload: salsa_gamesPayload<ExtArgs>
        fields: Prisma.salsa_gamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.salsa_gamesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.salsa_gamesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload>
          }
          findFirst: {
            args: Prisma.salsa_gamesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.salsa_gamesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload>
          }
          findMany: {
            args: Prisma.salsa_gamesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload>[]
          }
          create: {
            args: Prisma.salsa_gamesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload>
          }
          createMany: {
            args: Prisma.salsa_gamesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.salsa_gamesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload>
          }
          update: {
            args: Prisma.salsa_gamesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload>
          }
          deleteMany: {
            args: Prisma.salsa_gamesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.salsa_gamesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.salsa_gamesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salsa_gamesPayload>
          }
          aggregate: {
            args: Prisma.Salsa_gamesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSalsa_games>
          }
          groupBy: {
            args: Prisma.salsa_gamesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Salsa_gamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.salsa_gamesCountArgs<ExtArgs>,
            result: $Utils.Optional<Salsa_gamesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Auth_userCountOutputType
   */


  export type Auth_userCountOutputType = {
    client_auth_user: number
  }

  export type Auth_userCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client_auth_user?: boolean | Auth_userCountOutputTypeCountClient_auth_userArgs
  }

  // Custom InputTypes

  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth_userCountOutputType
     */
    select?: Auth_userCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountClient_auth_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: client_auth_userWhereInput
  }



  /**
   * Count Type Casino_most_popularCountOutputType
   */


  export type Casino_most_popularCountOutputType = {
    casino_most_popular_slot_games: number
  }

  export type Casino_most_popularCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    casino_most_popular_slot_games?: boolean | Casino_most_popularCountOutputTypeCountCasino_most_popular_slot_gamesArgs
  }

  // Custom InputTypes

  /**
   * Casino_most_popularCountOutputType without action
   */
  export type Casino_most_popularCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Casino_most_popularCountOutputType
     */
    select?: Casino_most_popularCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Casino_most_popularCountOutputType without action
   */
  export type Casino_most_popularCountOutputTypeCountCasino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: casino_most_popular_slot_gamesWhereInput
  }



  /**
   * Count Type ClientCountOutputType
   */


  export type ClientCountOutputType = {
    client_auth_user: number
    settings_settings_client_idToclient: number
    user: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client_auth_user?: boolean | ClientCountOutputTypeCountClient_auth_userArgs
    settings_settings_client_idToclient?: boolean | ClientCountOutputTypeCountSettings_settings_client_idToclientArgs
    user?: boolean | ClientCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClient_auth_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: client_auth_userWhereInput
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountSettings_settings_client_idToclientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type Live_casino_most_popularCountOutputType
   */


  export type Live_casino_most_popularCountOutputType = {
    live_casino_most_popular_slot_games: number
  }

  export type Live_casino_most_popularCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    live_casino_most_popular_slot_games?: boolean | Live_casino_most_popularCountOutputTypeCountLive_casino_most_popular_slot_gamesArgs
  }

  // Custom InputTypes

  /**
   * Live_casino_most_popularCountOutputType without action
   */
  export type Live_casino_most_popularCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live_casino_most_popularCountOutputType
     */
    select?: Live_casino_most_popularCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Live_casino_most_popularCountOutputType without action
   */
  export type Live_casino_most_popularCountOutputTypeCountLive_casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: live_casino_most_popular_slot_gamesWhereInput
  }



  /**
   * Count Type ProviderCountOutputType
   */


  export type ProviderCountOutputType = {
    slot_games: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    slot_games?: boolean | ProviderCountOutputTypeCountSlot_gamesArgs
  }

  // Custom InputTypes

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountSlot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: slot_gamesWhereInput
  }



  /**
   * Count Type SettingsCountOutputType
   */


  export type SettingsCountOutputType = {
    layout_colors: number
  }

  export type SettingsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    layout_colors?: boolean | SettingsCountOutputTypeCountLayout_colorsArgs
  }

  // Custom InputTypes

  /**
   * SettingsCountOutputType without action
   */
  export type SettingsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsCountOutputType
     */
    select?: SettingsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SettingsCountOutputType without action
   */
  export type SettingsCountOutputTypeCountLayout_colorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: layout_colorsWhereInput
  }



  /**
   * Count Type Slot_gamesCountOutputType
   */


  export type Slot_gamesCountOutputType = {
    bet_operations: number
    casino_most_popular_slot_games: number
    live_casino_most_popular_slot_games: number
  }

  export type Slot_gamesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bet_operations?: boolean | Slot_gamesCountOutputTypeCountBet_operationsArgs
    casino_most_popular_slot_games?: boolean | Slot_gamesCountOutputTypeCountCasino_most_popular_slot_gamesArgs
    live_casino_most_popular_slot_games?: boolean | Slot_gamesCountOutputTypeCountLive_casino_most_popular_slot_gamesArgs
  }

  // Custom InputTypes

  /**
   * Slot_gamesCountOutputType without action
   */
  export type Slot_gamesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot_gamesCountOutputType
     */
    select?: Slot_gamesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Slot_gamesCountOutputType without action
   */
  export type Slot_gamesCountOutputTypeCountBet_operationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bet_operationsWhereInput
  }


  /**
   * Slot_gamesCountOutputType without action
   */
  export type Slot_gamesCountOutputTypeCountCasino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: casino_most_popular_slot_gamesWhereInput
  }


  /**
   * Slot_gamesCountOutputType without action
   */
  export type Slot_gamesCountOutputTypeCountLive_casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: live_casino_most_popular_slot_gamesWhereInput
  }



  /**
   * Count Type Slot_settingsCountOutputType
   */


  export type Slot_settingsCountOutputType = {
    banner_more_profitable: number
  }

  export type Slot_settingsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    banner_more_profitable?: boolean | Slot_settingsCountOutputTypeCountBanner_more_profitableArgs
  }

  // Custom InputTypes

  /**
   * Slot_settingsCountOutputType without action
   */
  export type Slot_settingsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot_settingsCountOutputType
     */
    select?: Slot_settingsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Slot_settingsCountOutputType without action
   */
  export type Slot_settingsCountOutputTypeCountBanner_more_profitableArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: banner_more_profitableWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    bet_operations: number
    referral_history_referral_history_referral_idTouser: number
    referral_history_referral_history_user_idTouser: number
    other_user: number
    wallet_transaction: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bet_operations?: boolean | UserCountOutputTypeCountBet_operationsArgs
    referral_history_referral_history_referral_idTouser?: boolean | UserCountOutputTypeCountReferral_history_referral_history_referral_idTouserArgs
    referral_history_referral_history_user_idTouser?: boolean | UserCountOutputTypeCountReferral_history_referral_history_user_idTouserArgs
    other_user?: boolean | UserCountOutputTypeCountOther_userArgs
    wallet_transaction?: boolean | UserCountOutputTypeCountWallet_transactionArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBet_operationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bet_operationsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferral_history_referral_history_referral_idTouserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: referral_historyWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferral_history_referral_history_user_idTouserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: referral_historyWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOther_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWallet_transactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: wallet_transactionWhereInput
  }



  /**
   * Count Type WalletCountOutputType
   */


  export type WalletCountOutputType = {
    wallet_transaction: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    wallet_transaction?: boolean | WalletCountOutputTypeCountWallet_transactionArgs
  }

  // Custom InputTypes

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountWallet_transactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: wallet_transactionWhereInput
  }



  /**
   * Models
   */

  /**
   * Model api_request
   */


  export type AggregateApi_request = {
    _count: Api_requestCountAggregateOutputType | null
    _avg: Api_requestAvgAggregateOutputType | null
    _sum: Api_requestSumAggregateOutputType | null
    _min: Api_requestMinAggregateOutputType | null
    _max: Api_requestMaxAggregateOutputType | null
  }

  export type Api_requestAvgAggregateOutputType = {
    id: number | null
  }

  export type Api_requestSumAggregateOutputType = {
    id: number | null
  }

  export type Api_requestMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type Api_requestMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type Api_requestCountAggregateOutputType = {
    id: number
    name: number
    request: number
    response: number
    created_at: number
    _all: number
  }


  export type Api_requestAvgAggregateInputType = {
    id?: true
  }

  export type Api_requestSumAggregateInputType = {
    id?: true
  }

  export type Api_requestMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type Api_requestMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type Api_requestCountAggregateInputType = {
    id?: true
    name?: true
    request?: true
    response?: true
    created_at?: true
    _all?: true
  }

  export type Api_requestAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_request to aggregate.
     */
    where?: api_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_requests to fetch.
     */
    orderBy?: api_requestOrderByWithRelationInput | api_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: api_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned api_requests
    **/
    _count?: true | Api_requestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Api_requestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Api_requestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Api_requestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Api_requestMaxAggregateInputType
  }

  export type GetApi_requestAggregateType<T extends Api_requestAggregateArgs> = {
        [P in keyof T & keyof AggregateApi_request]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApi_request[P]>
      : GetScalarType<T[P], AggregateApi_request[P]>
  }




  export type api_requestGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: api_requestWhereInput
    orderBy?: api_requestOrderByWithAggregationInput | api_requestOrderByWithAggregationInput[]
    by: Api_requestScalarFieldEnum[] | Api_requestScalarFieldEnum
    having?: api_requestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Api_requestCountAggregateInputType | true
    _avg?: Api_requestAvgAggregateInputType
    _sum?: Api_requestSumAggregateInputType
    _min?: Api_requestMinAggregateInputType
    _max?: Api_requestMaxAggregateInputType
  }


  export type Api_requestGroupByOutputType = {
    id: number
    name: string
    request: JsonValue
    response: JsonValue
    created_at: Date
    _count: Api_requestCountAggregateOutputType | null
    _avg: Api_requestAvgAggregateOutputType | null
    _sum: Api_requestSumAggregateOutputType | null
    _min: Api_requestMinAggregateOutputType | null
    _max: Api_requestMaxAggregateOutputType | null
  }

  type GetApi_requestGroupByPayload<T extends api_requestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Api_requestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Api_requestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Api_requestGroupByOutputType[P]>
            : GetScalarType<T[P], Api_requestGroupByOutputType[P]>
        }
      >
    >


  export type api_requestSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    request?: boolean
    response?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["api_request"]>

  export type api_requestSelectScalar = {
    id?: boolean
    name?: boolean
    request?: boolean
    response?: boolean
    created_at?: boolean
  }


  type api_requestGetPayload<S extends boolean | null | undefined | api_requestArgs> = $Types.GetResult<api_requestPayload, S>

  type api_requestCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<api_requestFindManyArgs, 'select' | 'include'> & {
      select?: Api_requestCountAggregateInputType | true
    }

  export interface api_requestDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['api_request'], meta: { name: 'api_request' } }
    /**
     * Find zero or one Api_request that matches the filter.
     * @param {api_requestFindUniqueArgs} args - Arguments to find a Api_request
     * @example
     * // Get one Api_request
     * const api_request = await prisma.api_request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends api_requestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, api_requestFindUniqueArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Api_request that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {api_requestFindUniqueOrThrowArgs} args - Arguments to find a Api_request
     * @example
     * // Get one Api_request
     * const api_request = await prisma.api_request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends api_requestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, api_requestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Api_request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_requestFindFirstArgs} args - Arguments to find a Api_request
     * @example
     * // Get one Api_request
     * const api_request = await prisma.api_request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends api_requestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, api_requestFindFirstArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Api_request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_requestFindFirstOrThrowArgs} args - Arguments to find a Api_request
     * @example
     * // Get one Api_request
     * const api_request = await prisma.api_request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends api_requestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, api_requestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Api_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_requestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Api_requests
     * const api_requests = await prisma.api_request.findMany()
     * 
     * // Get first 10 Api_requests
     * const api_requests = await prisma.api_request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const api_requestWithIdOnly = await prisma.api_request.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends api_requestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, api_requestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Api_request.
     * @param {api_requestCreateArgs} args - Arguments to create a Api_request.
     * @example
     * // Create one Api_request
     * const Api_request = await prisma.api_request.create({
     *   data: {
     *     // ... data to create a Api_request
     *   }
     * })
     * 
    **/
    create<T extends api_requestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, api_requestCreateArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Api_requests.
     *     @param {api_requestCreateManyArgs} args - Arguments to create many Api_requests.
     *     @example
     *     // Create many Api_requests
     *     const api_request = await prisma.api_request.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends api_requestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, api_requestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Api_request.
     * @param {api_requestDeleteArgs} args - Arguments to delete one Api_request.
     * @example
     * // Delete one Api_request
     * const Api_request = await prisma.api_request.delete({
     *   where: {
     *     // ... filter to delete one Api_request
     *   }
     * })
     * 
    **/
    delete<T extends api_requestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, api_requestDeleteArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Api_request.
     * @param {api_requestUpdateArgs} args - Arguments to update one Api_request.
     * @example
     * // Update one Api_request
     * const api_request = await prisma.api_request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends api_requestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, api_requestUpdateArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Api_requests.
     * @param {api_requestDeleteManyArgs} args - Arguments to filter Api_requests to delete.
     * @example
     * // Delete a few Api_requests
     * const { count } = await prisma.api_request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends api_requestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, api_requestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_requestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Api_requests
     * const api_request = await prisma.api_request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends api_requestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, api_requestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Api_request.
     * @param {api_requestUpsertArgs} args - Arguments to update or create a Api_request.
     * @example
     * // Update or create a Api_request
     * const api_request = await prisma.api_request.upsert({
     *   create: {
     *     // ... data to create a Api_request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Api_request we want to update
     *   }
     * })
    **/
    upsert<T extends api_requestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, api_requestUpsertArgs<ExtArgs>>
    ): Prisma__api_requestClient<$Types.GetResult<api_requestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Api_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_requestCountArgs} args - Arguments to filter Api_requests to count.
     * @example
     * // Count the number of Api_requests
     * const count = await prisma.api_request.count({
     *   where: {
     *     // ... the filter for the Api_requests we want to count
     *   }
     * })
    **/
    count<T extends api_requestCountArgs>(
      args?: Subset<T, api_requestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Api_requestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Api_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_requestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Api_requestAggregateArgs>(args: Subset<T, Api_requestAggregateArgs>): Prisma.PrismaPromise<GetApi_requestAggregateType<T>>

    /**
     * Group by Api_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_requestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends api_requestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: api_requestGroupByArgs['orderBy'] }
        : { orderBy?: api_requestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, api_requestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApi_requestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the api_request model
   */
  readonly fields: api_requestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for api_request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__api_requestClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the api_request model
   */ 
  interface api_requestFieldRefs {
    readonly id: FieldRef<"api_request", 'Int'>
    readonly name: FieldRef<"api_request", 'String'>
    readonly request: FieldRef<"api_request", 'Json'>
    readonly response: FieldRef<"api_request", 'Json'>
    readonly created_at: FieldRef<"api_request", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * api_request findUnique
   */
  export type api_requestFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * Filter, which api_request to fetch.
     */
    where: api_requestWhereUniqueInput
  }


  /**
   * api_request findUniqueOrThrow
   */
  export type api_requestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * Filter, which api_request to fetch.
     */
    where: api_requestWhereUniqueInput
  }


  /**
   * api_request findFirst
   */
  export type api_requestFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * Filter, which api_request to fetch.
     */
    where?: api_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_requests to fetch.
     */
    orderBy?: api_requestOrderByWithRelationInput | api_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_requests.
     */
    cursor?: api_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_requests.
     */
    distinct?: Api_requestScalarFieldEnum | Api_requestScalarFieldEnum[]
  }


  /**
   * api_request findFirstOrThrow
   */
  export type api_requestFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * Filter, which api_request to fetch.
     */
    where?: api_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_requests to fetch.
     */
    orderBy?: api_requestOrderByWithRelationInput | api_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_requests.
     */
    cursor?: api_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_requests.
     */
    distinct?: Api_requestScalarFieldEnum | Api_requestScalarFieldEnum[]
  }


  /**
   * api_request findMany
   */
  export type api_requestFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * Filter, which api_requests to fetch.
     */
    where?: api_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_requests to fetch.
     */
    orderBy?: api_requestOrderByWithRelationInput | api_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing api_requests.
     */
    cursor?: api_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_requests.
     */
    skip?: number
    distinct?: Api_requestScalarFieldEnum | Api_requestScalarFieldEnum[]
  }


  /**
   * api_request create
   */
  export type api_requestCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * The data needed to create a api_request.
     */
    data: XOR<api_requestCreateInput, api_requestUncheckedCreateInput>
  }


  /**
   * api_request createMany
   */
  export type api_requestCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many api_requests.
     */
    data: api_requestCreateManyInput | api_requestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * api_request update
   */
  export type api_requestUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * The data needed to update a api_request.
     */
    data: XOR<api_requestUpdateInput, api_requestUncheckedUpdateInput>
    /**
     * Choose, which api_request to update.
     */
    where: api_requestWhereUniqueInput
  }


  /**
   * api_request updateMany
   */
  export type api_requestUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update api_requests.
     */
    data: XOR<api_requestUpdateManyMutationInput, api_requestUncheckedUpdateManyInput>
    /**
     * Filter which api_requests to update
     */
    where?: api_requestWhereInput
  }


  /**
   * api_request upsert
   */
  export type api_requestUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * The filter to search for the api_request to update in case it exists.
     */
    where: api_requestWhereUniqueInput
    /**
     * In case the api_request found by the `where` argument doesn't exist, create a new api_request with this data.
     */
    create: XOR<api_requestCreateInput, api_requestUncheckedCreateInput>
    /**
     * In case the api_request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<api_requestUpdateInput, api_requestUncheckedUpdateInput>
  }


  /**
   * api_request delete
   */
  export type api_requestDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
    /**
     * Filter which api_request to delete.
     */
    where: api_requestWhereUniqueInput
  }


  /**
   * api_request deleteMany
   */
  export type api_requestDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_requests to delete
     */
    where?: api_requestWhereInput
  }


  /**
   * api_request without action
   */
  export type api_requestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_request
     */
    select?: api_requestSelect<ExtArgs> | null
  }



  /**
   * Model auth_user
   */


  export type AggregateAuth_user = {
    _count: Auth_userCountAggregateOutputType | null
    _avg: Auth_userAvgAggregateOutputType | null
    _sum: Auth_userSumAggregateOutputType | null
    _min: Auth_userMinAggregateOutputType | null
    _max: Auth_userMaxAggregateOutputType | null
  }

  export type Auth_userAvgAggregateOutputType = {
    id: number | null
  }

  export type Auth_userSumAggregateOutputType = {
    id: number | null
  }

  export type Auth_userMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
    username: string | null
  }

  export type Auth_userMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
    username: string | null
  }

  export type Auth_userCountAggregateOutputType = {
    id: number
    email: number
    roles: number
    password: number
    created_at: number
    updated_at: number
    username: number
    _all: number
  }


  export type Auth_userAvgAggregateInputType = {
    id?: true
  }

  export type Auth_userSumAggregateInputType = {
    id?: true
  }

  export type Auth_userMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    created_at?: true
    updated_at?: true
    username?: true
  }

  export type Auth_userMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    created_at?: true
    updated_at?: true
    username?: true
  }

  export type Auth_userCountAggregateInputType = {
    id?: true
    email?: true
    roles?: true
    password?: true
    created_at?: true
    updated_at?: true
    username?: true
    _all?: true
  }

  export type Auth_userAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_user to aggregate.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_users
    **/
    _count?: true | Auth_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_userMaxAggregateInputType
  }

  export type GetAuth_userAggregateType<T extends Auth_userAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_user[P]>
      : GetScalarType<T[P], AggregateAuth_user[P]>
  }




  export type auth_userGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: auth_userWhereInput
    orderBy?: auth_userOrderByWithAggregationInput | auth_userOrderByWithAggregationInput[]
    by: Auth_userScalarFieldEnum[] | Auth_userScalarFieldEnum
    having?: auth_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_userCountAggregateInputType | true
    _avg?: Auth_userAvgAggregateInputType
    _sum?: Auth_userSumAggregateInputType
    _min?: Auth_userMinAggregateInputType
    _max?: Auth_userMaxAggregateInputType
  }


  export type Auth_userGroupByOutputType = {
    id: number
    email: string
    roles: JsonValue
    password: string
    created_at: Date
    updated_at: Date
    username: string
    _count: Auth_userCountAggregateOutputType | null
    _avg: Auth_userAvgAggregateOutputType | null
    _sum: Auth_userSumAggregateOutputType | null
    _min: Auth_userMinAggregateOutputType | null
    _max: Auth_userMaxAggregateOutputType | null
  }

  type GetAuth_userGroupByPayload<T extends auth_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auth_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_userGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_userGroupByOutputType[P]>
        }
      >
    >


  export type auth_userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    roles?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
    username?: boolean
    client_auth_user?: boolean | auth_user$client_auth_userArgs<ExtArgs>
    _count?: boolean | Auth_userCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["auth_user"]>

  export type auth_userSelectScalar = {
    id?: boolean
    email?: boolean
    roles?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
    username?: boolean
  }

  export type auth_userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client_auth_user?: boolean | auth_user$client_auth_userArgs<ExtArgs>
    _count?: boolean | Auth_userCountOutputTypeArgs<ExtArgs>
  }


  type auth_userGetPayload<S extends boolean | null | undefined | auth_userArgs> = $Types.GetResult<auth_userPayload, S>

  type auth_userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<auth_userFindManyArgs, 'select' | 'include'> & {
      select?: Auth_userCountAggregateInputType | true
    }

  export interface auth_userDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth_user'], meta: { name: 'auth_user' } }
    /**
     * Find zero or one Auth_user that matches the filter.
     * @param {auth_userFindUniqueArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auth_userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, auth_userFindUniqueArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Auth_user that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auth_userFindUniqueOrThrowArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auth_userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, auth_userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Auth_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindFirstArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auth_userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, auth_userFindFirstArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Auth_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindFirstOrThrowArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auth_userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, auth_userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Auth_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_users
     * const auth_users = await prisma.auth_user.findMany()
     * 
     * // Get first 10 Auth_users
     * const auth_users = await prisma.auth_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_userWithIdOnly = await prisma.auth_user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends auth_userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auth_userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Auth_user.
     * @param {auth_userCreateArgs} args - Arguments to create a Auth_user.
     * @example
     * // Create one Auth_user
     * const Auth_user = await prisma.auth_user.create({
     *   data: {
     *     // ... data to create a Auth_user
     *   }
     * })
     * 
    **/
    create<T extends auth_userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, auth_userCreateArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Auth_users.
     *     @param {auth_userCreateManyArgs} args - Arguments to create many Auth_users.
     *     @example
     *     // Create many Auth_users
     *     const auth_user = await prisma.auth_user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auth_userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auth_userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth_user.
     * @param {auth_userDeleteArgs} args - Arguments to delete one Auth_user.
     * @example
     * // Delete one Auth_user
     * const Auth_user = await prisma.auth_user.delete({
     *   where: {
     *     // ... filter to delete one Auth_user
     *   }
     * })
     * 
    **/
    delete<T extends auth_userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, auth_userDeleteArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Auth_user.
     * @param {auth_userUpdateArgs} args - Arguments to update one Auth_user.
     * @example
     * // Update one Auth_user
     * const auth_user = await prisma.auth_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auth_userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, auth_userUpdateArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Auth_users.
     * @param {auth_userDeleteManyArgs} args - Arguments to filter Auth_users to delete.
     * @example
     * // Delete a few Auth_users
     * const { count } = await prisma.auth_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auth_userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auth_userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_users
     * const auth_user = await prisma.auth_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auth_userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, auth_userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth_user.
     * @param {auth_userUpsertArgs} args - Arguments to update or create a Auth_user.
     * @example
     * // Update or create a Auth_user
     * const auth_user = await prisma.auth_user.upsert({
     *   create: {
     *     // ... data to create a Auth_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_user we want to update
     *   }
     * })
    **/
    upsert<T extends auth_userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, auth_userUpsertArgs<ExtArgs>>
    ): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userCountArgs} args - Arguments to filter Auth_users to count.
     * @example
     * // Count the number of Auth_users
     * const count = await prisma.auth_user.count({
     *   where: {
     *     // ... the filter for the Auth_users we want to count
     *   }
     * })
    **/
    count<T extends auth_userCountArgs>(
      args?: Subset<T, auth_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_userAggregateArgs>(args: Subset<T, Auth_userAggregateArgs>): Prisma.PrismaPromise<GetAuth_userAggregateType<T>>

    /**
     * Group by Auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auth_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auth_userGroupByArgs['orderBy'] }
        : { orderBy?: auth_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auth_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth_user model
   */
  readonly fields: auth_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auth_userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client_auth_user<T extends auth_user$client_auth_userArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$client_auth_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the auth_user model
   */ 
  interface auth_userFieldRefs {
    readonly id: FieldRef<"auth_user", 'Int'>
    readonly email: FieldRef<"auth_user", 'String'>
    readonly roles: FieldRef<"auth_user", 'Json'>
    readonly password: FieldRef<"auth_user", 'String'>
    readonly created_at: FieldRef<"auth_user", 'DateTime'>
    readonly updated_at: FieldRef<"auth_user", 'DateTime'>
    readonly username: FieldRef<"auth_user", 'String'>
  }
    

  // Custom InputTypes

  /**
   * auth_user findUnique
   */
  export type auth_userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where: auth_userWhereUniqueInput
  }


  /**
   * auth_user findUniqueOrThrow
   */
  export type auth_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where: auth_userWhereUniqueInput
  }


  /**
   * auth_user findFirst
   */
  export type auth_userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_users.
     */
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }


  /**
   * auth_user findFirstOrThrow
   */
  export type auth_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_users.
     */
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }


  /**
   * auth_user findMany
   */
  export type auth_userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_users to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }


  /**
   * auth_user create
   */
  export type auth_userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * The data needed to create a auth_user.
     */
    data: XOR<auth_userCreateInput, auth_userUncheckedCreateInput>
  }


  /**
   * auth_user createMany
   */
  export type auth_userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auth_users.
     */
    data: auth_userCreateManyInput | auth_userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * auth_user update
   */
  export type auth_userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * The data needed to update a auth_user.
     */
    data: XOR<auth_userUpdateInput, auth_userUncheckedUpdateInput>
    /**
     * Choose, which auth_user to update.
     */
    where: auth_userWhereUniqueInput
  }


  /**
   * auth_user updateMany
   */
  export type auth_userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auth_users.
     */
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyInput>
    /**
     * Filter which auth_users to update
     */
    where?: auth_userWhereInput
  }


  /**
   * auth_user upsert
   */
  export type auth_userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * The filter to search for the auth_user to update in case it exists.
     */
    where: auth_userWhereUniqueInput
    /**
     * In case the auth_user found by the `where` argument doesn't exist, create a new auth_user with this data.
     */
    create: XOR<auth_userCreateInput, auth_userUncheckedCreateInput>
    /**
     * In case the auth_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_userUpdateInput, auth_userUncheckedUpdateInput>
  }


  /**
   * auth_user delete
   */
  export type auth_userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter which auth_user to delete.
     */
    where: auth_userWhereUniqueInput
  }


  /**
   * auth_user deleteMany
   */
  export type auth_userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_users to delete
     */
    where?: auth_userWhereInput
  }


  /**
   * auth_user.client_auth_user
   */
  export type auth_user$client_auth_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    where?: client_auth_userWhereInput
    orderBy?: client_auth_userOrderByWithRelationInput | client_auth_userOrderByWithRelationInput[]
    cursor?: client_auth_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_auth_userScalarFieldEnum | Client_auth_userScalarFieldEnum[]
  }


  /**
   * auth_user without action
   */
  export type auth_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude<ExtArgs> | null
  }



  /**
   * Model banner_more_profitable
   */


  export type AggregateBanner_more_profitable = {
    _count: Banner_more_profitableCountAggregateOutputType | null
    _avg: Banner_more_profitableAvgAggregateOutputType | null
    _sum: Banner_more_profitableSumAggregateOutputType | null
    _min: Banner_more_profitableMinAggregateOutputType | null
    _max: Banner_more_profitableMaxAggregateOutputType | null
  }

  export type Banner_more_profitableAvgAggregateOutputType = {
    id: number | null
    banner_id: number | null
    slot_settings_id: number | null
    banner_file_id: number | null
  }

  export type Banner_more_profitableSumAggregateOutputType = {
    id: number | null
    banner_id: number | null
    slot_settings_id: number | null
    banner_file_id: number | null
  }

  export type Banner_more_profitableMinAggregateOutputType = {
    id: number | null
    banner_id: number | null
    slot_settings_id: number | null
    banner_file_id: number | null
    name: string | null
    game_url: string | null
    created_at: Date | null
    updated_at: Date | null
    active: boolean | null
  }

  export type Banner_more_profitableMaxAggregateOutputType = {
    id: number | null
    banner_id: number | null
    slot_settings_id: number | null
    banner_file_id: number | null
    name: string | null
    game_url: string | null
    created_at: Date | null
    updated_at: Date | null
    active: boolean | null
  }

  export type Banner_more_profitableCountAggregateOutputType = {
    id: number
    banner_id: number
    slot_settings_id: number
    banner_file_id: number
    name: number
    game_url: number
    created_at: number
    updated_at: number
    active: number
    _all: number
  }


  export type Banner_more_profitableAvgAggregateInputType = {
    id?: true
    banner_id?: true
    slot_settings_id?: true
    banner_file_id?: true
  }

  export type Banner_more_profitableSumAggregateInputType = {
    id?: true
    banner_id?: true
    slot_settings_id?: true
    banner_file_id?: true
  }

  export type Banner_more_profitableMinAggregateInputType = {
    id?: true
    banner_id?: true
    slot_settings_id?: true
    banner_file_id?: true
    name?: true
    game_url?: true
    created_at?: true
    updated_at?: true
    active?: true
  }

  export type Banner_more_profitableMaxAggregateInputType = {
    id?: true
    banner_id?: true
    slot_settings_id?: true
    banner_file_id?: true
    name?: true
    game_url?: true
    created_at?: true
    updated_at?: true
    active?: true
  }

  export type Banner_more_profitableCountAggregateInputType = {
    id?: true
    banner_id?: true
    slot_settings_id?: true
    banner_file_id?: true
    name?: true
    game_url?: true
    created_at?: true
    updated_at?: true
    active?: true
    _all?: true
  }

  export type Banner_more_profitableAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which banner_more_profitable to aggregate.
     */
    where?: banner_more_profitableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitables to fetch.
     */
    orderBy?: banner_more_profitableOrderByWithRelationInput | banner_more_profitableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banner_more_profitableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banner_more_profitables
    **/
    _count?: true | Banner_more_profitableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Banner_more_profitableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Banner_more_profitableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Banner_more_profitableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Banner_more_profitableMaxAggregateInputType
  }

  export type GetBanner_more_profitableAggregateType<T extends Banner_more_profitableAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner_more_profitable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner_more_profitable[P]>
      : GetScalarType<T[P], AggregateBanner_more_profitable[P]>
  }




  export type banner_more_profitableGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: banner_more_profitableWhereInput
    orderBy?: banner_more_profitableOrderByWithAggregationInput | banner_more_profitableOrderByWithAggregationInput[]
    by: Banner_more_profitableScalarFieldEnum[] | Banner_more_profitableScalarFieldEnum
    having?: banner_more_profitableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Banner_more_profitableCountAggregateInputType | true
    _avg?: Banner_more_profitableAvgAggregateInputType
    _sum?: Banner_more_profitableSumAggregateInputType
    _min?: Banner_more_profitableMinAggregateInputType
    _max?: Banner_more_profitableMaxAggregateInputType
  }


  export type Banner_more_profitableGroupByOutputType = {
    id: number
    banner_id: number | null
    slot_settings_id: number | null
    banner_file_id: number | null
    name: string
    game_url: string
    created_at: Date
    updated_at: Date
    active: boolean
    _count: Banner_more_profitableCountAggregateOutputType | null
    _avg: Banner_more_profitableAvgAggregateOutputType | null
    _sum: Banner_more_profitableSumAggregateOutputType | null
    _min: Banner_more_profitableMinAggregateOutputType | null
    _max: Banner_more_profitableMaxAggregateOutputType | null
  }

  type GetBanner_more_profitableGroupByPayload<T extends banner_more_profitableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Banner_more_profitableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Banner_more_profitableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Banner_more_profitableGroupByOutputType[P]>
            : GetScalarType<T[P], Banner_more_profitableGroupByOutputType[P]>
        }
      >
    >


  export type banner_more_profitableSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banner_id?: boolean
    slot_settings_id?: boolean
    banner_file_id?: boolean
    name?: boolean
    game_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    active?: boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: boolean | banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs>
    slot_settings?: boolean | banner_more_profitable$slot_settingsArgs<ExtArgs>
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: boolean | banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs>
  }, ExtArgs["result"]["banner_more_profitable"]>

  export type banner_more_profitableSelectScalar = {
    id?: boolean
    banner_id?: boolean
    slot_settings_id?: boolean
    banner_file_id?: boolean
    name?: boolean
    game_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    active?: boolean
  }

  export type banner_more_profitableInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: boolean | banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs>
    slot_settings?: boolean | banner_more_profitable$slot_settingsArgs<ExtArgs>
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: boolean | banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs>
  }


  type banner_more_profitableGetPayload<S extends boolean | null | undefined | banner_more_profitableArgs> = $Types.GetResult<banner_more_profitablePayload, S>

  type banner_more_profitableCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<banner_more_profitableFindManyArgs, 'select' | 'include'> & {
      select?: Banner_more_profitableCountAggregateInputType | true
    }

  export interface banner_more_profitableDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banner_more_profitable'], meta: { name: 'banner_more_profitable' } }
    /**
     * Find zero or one Banner_more_profitable that matches the filter.
     * @param {banner_more_profitableFindUniqueArgs} args - Arguments to find a Banner_more_profitable
     * @example
     * // Get one Banner_more_profitable
     * const banner_more_profitable = await prisma.banner_more_profitable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends banner_more_profitableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitableFindUniqueArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banner_more_profitable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {banner_more_profitableFindUniqueOrThrowArgs} args - Arguments to find a Banner_more_profitable
     * @example
     * // Get one Banner_more_profitable
     * const banner_more_profitable = await prisma.banner_more_profitable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends banner_more_profitableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banner_more_profitable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitableFindFirstArgs} args - Arguments to find a Banner_more_profitable
     * @example
     * // Get one Banner_more_profitable
     * const banner_more_profitable = await prisma.banner_more_profitable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends banner_more_profitableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitableFindFirstArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banner_more_profitable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitableFindFirstOrThrowArgs} args - Arguments to find a Banner_more_profitable
     * @example
     * // Get one Banner_more_profitable
     * const banner_more_profitable = await prisma.banner_more_profitable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends banner_more_profitableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banner_more_profitables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banner_more_profitables
     * const banner_more_profitables = await prisma.banner_more_profitable.findMany()
     * 
     * // Get first 10 Banner_more_profitables
     * const banner_more_profitables = await prisma.banner_more_profitable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banner_more_profitableWithIdOnly = await prisma.banner_more_profitable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends banner_more_profitableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banner_more_profitable.
     * @param {banner_more_profitableCreateArgs} args - Arguments to create a Banner_more_profitable.
     * @example
     * // Create one Banner_more_profitable
     * const Banner_more_profitable = await prisma.banner_more_profitable.create({
     *   data: {
     *     // ... data to create a Banner_more_profitable
     *   }
     * })
     * 
    **/
    create<T extends banner_more_profitableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitableCreateArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banner_more_profitables.
     *     @param {banner_more_profitableCreateManyArgs} args - Arguments to create many Banner_more_profitables.
     *     @example
     *     // Create many Banner_more_profitables
     *     const banner_more_profitable = await prisma.banner_more_profitable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends banner_more_profitableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner_more_profitable.
     * @param {banner_more_profitableDeleteArgs} args - Arguments to delete one Banner_more_profitable.
     * @example
     * // Delete one Banner_more_profitable
     * const Banner_more_profitable = await prisma.banner_more_profitable.delete({
     *   where: {
     *     // ... filter to delete one Banner_more_profitable
     *   }
     * })
     * 
    **/
    delete<T extends banner_more_profitableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitableDeleteArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banner_more_profitable.
     * @param {banner_more_profitableUpdateArgs} args - Arguments to update one Banner_more_profitable.
     * @example
     * // Update one Banner_more_profitable
     * const banner_more_profitable = await prisma.banner_more_profitable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends banner_more_profitableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitableUpdateArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banner_more_profitables.
     * @param {banner_more_profitableDeleteManyArgs} args - Arguments to filter Banner_more_profitables to delete.
     * @example
     * // Delete a few Banner_more_profitables
     * const { count } = await prisma.banner_more_profitable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends banner_more_profitableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banner_more_profitables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banner_more_profitables
     * const banner_more_profitable = await prisma.banner_more_profitable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends banner_more_profitableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner_more_profitable.
     * @param {banner_more_profitableUpsertArgs} args - Arguments to update or create a Banner_more_profitable.
     * @example
     * // Update or create a Banner_more_profitable
     * const banner_more_profitable = await prisma.banner_more_profitable.upsert({
     *   create: {
     *     // ... data to create a Banner_more_profitable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner_more_profitable we want to update
     *   }
     * })
    **/
    upsert<T extends banner_more_profitableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitableUpsertArgs<ExtArgs>>
    ): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banner_more_profitables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitableCountArgs} args - Arguments to filter Banner_more_profitables to count.
     * @example
     * // Count the number of Banner_more_profitables
     * const count = await prisma.banner_more_profitable.count({
     *   where: {
     *     // ... the filter for the Banner_more_profitables we want to count
     *   }
     * })
    **/
    count<T extends banner_more_profitableCountArgs>(
      args?: Subset<T, banner_more_profitableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Banner_more_profitableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner_more_profitable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Banner_more_profitableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Banner_more_profitableAggregateArgs>(args: Subset<T, Banner_more_profitableAggregateArgs>): Prisma.PrismaPromise<GetBanner_more_profitableAggregateType<T>>

    /**
     * Group by Banner_more_profitable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banner_more_profitableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banner_more_profitableGroupByArgs['orderBy'] }
        : { orderBy?: banner_more_profitableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banner_more_profitableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanner_more_profitableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banner_more_profitable model
   */
  readonly fields: banner_more_profitableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banner_more_profitable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__banner_more_profitableClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file<T extends banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs> = {}>(args?: Subset<T, banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs>>): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    slot_settings<T extends banner_more_profitable$slot_settingsArgs<ExtArgs> = {}>(args?: Subset<T, banner_more_profitable$slot_settingsArgs<ExtArgs>>): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file<T extends banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs> = {}>(args?: Subset<T, banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs>>): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the banner_more_profitable model
   */ 
  interface banner_more_profitableFieldRefs {
    readonly id: FieldRef<"banner_more_profitable", 'Int'>
    readonly banner_id: FieldRef<"banner_more_profitable", 'Int'>
    readonly slot_settings_id: FieldRef<"banner_more_profitable", 'Int'>
    readonly banner_file_id: FieldRef<"banner_more_profitable", 'Int'>
    readonly name: FieldRef<"banner_more_profitable", 'String'>
    readonly game_url: FieldRef<"banner_more_profitable", 'String'>
    readonly created_at: FieldRef<"banner_more_profitable", 'DateTime'>
    readonly updated_at: FieldRef<"banner_more_profitable", 'DateTime'>
    readonly active: FieldRef<"banner_more_profitable", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * banner_more_profitable findUnique
   */
  export type banner_more_profitableFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable to fetch.
     */
    where: banner_more_profitableWhereUniqueInput
  }


  /**
   * banner_more_profitable findUniqueOrThrow
   */
  export type banner_more_profitableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable to fetch.
     */
    where: banner_more_profitableWhereUniqueInput
  }


  /**
   * banner_more_profitable findFirst
   */
  export type banner_more_profitableFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable to fetch.
     */
    where?: banner_more_profitableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitables to fetch.
     */
    orderBy?: banner_more_profitableOrderByWithRelationInput | banner_more_profitableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banner_more_profitables.
     */
    cursor?: banner_more_profitableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banner_more_profitables.
     */
    distinct?: Banner_more_profitableScalarFieldEnum | Banner_more_profitableScalarFieldEnum[]
  }


  /**
   * banner_more_profitable findFirstOrThrow
   */
  export type banner_more_profitableFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable to fetch.
     */
    where?: banner_more_profitableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitables to fetch.
     */
    orderBy?: banner_more_profitableOrderByWithRelationInput | banner_more_profitableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banner_more_profitables.
     */
    cursor?: banner_more_profitableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banner_more_profitables.
     */
    distinct?: Banner_more_profitableScalarFieldEnum | Banner_more_profitableScalarFieldEnum[]
  }


  /**
   * banner_more_profitable findMany
   */
  export type banner_more_profitableFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitables to fetch.
     */
    where?: banner_more_profitableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitables to fetch.
     */
    orderBy?: banner_more_profitableOrderByWithRelationInput | banner_more_profitableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banner_more_profitables.
     */
    cursor?: banner_more_profitableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitables.
     */
    skip?: number
    distinct?: Banner_more_profitableScalarFieldEnum | Banner_more_profitableScalarFieldEnum[]
  }


  /**
   * banner_more_profitable create
   */
  export type banner_more_profitableCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * The data needed to create a banner_more_profitable.
     */
    data: XOR<banner_more_profitableCreateInput, banner_more_profitableUncheckedCreateInput>
  }


  /**
   * banner_more_profitable createMany
   */
  export type banner_more_profitableCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banner_more_profitables.
     */
    data: banner_more_profitableCreateManyInput | banner_more_profitableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * banner_more_profitable update
   */
  export type banner_more_profitableUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * The data needed to update a banner_more_profitable.
     */
    data: XOR<banner_more_profitableUpdateInput, banner_more_profitableUncheckedUpdateInput>
    /**
     * Choose, which banner_more_profitable to update.
     */
    where: banner_more_profitableWhereUniqueInput
  }


  /**
   * banner_more_profitable updateMany
   */
  export type banner_more_profitableUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banner_more_profitables.
     */
    data: XOR<banner_more_profitableUpdateManyMutationInput, banner_more_profitableUncheckedUpdateManyInput>
    /**
     * Filter which banner_more_profitables to update
     */
    where?: banner_more_profitableWhereInput
  }


  /**
   * banner_more_profitable upsert
   */
  export type banner_more_profitableUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * The filter to search for the banner_more_profitable to update in case it exists.
     */
    where: banner_more_profitableWhereUniqueInput
    /**
     * In case the banner_more_profitable found by the `where` argument doesn't exist, create a new banner_more_profitable with this data.
     */
    create: XOR<banner_more_profitableCreateInput, banner_more_profitableUncheckedCreateInput>
    /**
     * In case the banner_more_profitable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banner_more_profitableUpdateInput, banner_more_profitableUncheckedUpdateInput>
  }


  /**
   * banner_more_profitable delete
   */
  export type banner_more_profitableDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    /**
     * Filter which banner_more_profitable to delete.
     */
    where: banner_more_profitableWhereUniqueInput
  }


  /**
   * banner_more_profitable deleteMany
   */
  export type banner_more_profitableDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which banner_more_profitables to delete
     */
    where?: banner_more_profitableWhereInput
  }


  /**
   * banner_more_profitable.banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file
   */
  export type banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    where?: banner_more_profitable_fileWhereInput
  }


  /**
   * banner_more_profitable.slot_settings
   */
  export type banner_more_profitable$slot_settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    where?: slot_settingsWhereInput
  }


  /**
   * banner_more_profitable.banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file
   */
  export type banner_more_profitable$banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    where?: banner_more_profitable_fileWhereInput
  }


  /**
   * banner_more_profitable without action
   */
  export type banner_more_profitableArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
  }



  /**
   * Model banner_more_profitable_file
   */


  export type AggregateBanner_more_profitable_file = {
    _count: Banner_more_profitable_fileCountAggregateOutputType | null
    _avg: Banner_more_profitable_fileAvgAggregateOutputType | null
    _sum: Banner_more_profitable_fileSumAggregateOutputType | null
    _min: Banner_more_profitable_fileMinAggregateOutputType | null
    _max: Banner_more_profitable_fileMaxAggregateOutputType | null
  }

  export type Banner_more_profitable_fileAvgAggregateOutputType = {
    id: number | null
  }

  export type Banner_more_profitable_fileSumAggregateOutputType = {
    id: number | null
  }

  export type Banner_more_profitable_fileMinAggregateOutputType = {
    id: number | null
    file: string | null
    upload_at: Date | null
  }

  export type Banner_more_profitable_fileMaxAggregateOutputType = {
    id: number | null
    file: string | null
    upload_at: Date | null
  }

  export type Banner_more_profitable_fileCountAggregateOutputType = {
    id: number
    file: number
    upload_at: number
    _all: number
  }


  export type Banner_more_profitable_fileAvgAggregateInputType = {
    id?: true
  }

  export type Banner_more_profitable_fileSumAggregateInputType = {
    id?: true
  }

  export type Banner_more_profitable_fileMinAggregateInputType = {
    id?: true
    file?: true
    upload_at?: true
  }

  export type Banner_more_profitable_fileMaxAggregateInputType = {
    id?: true
    file?: true
    upload_at?: true
  }

  export type Banner_more_profitable_fileCountAggregateInputType = {
    id?: true
    file?: true
    upload_at?: true
    _all?: true
  }

  export type Banner_more_profitable_fileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which banner_more_profitable_file to aggregate.
     */
    where?: banner_more_profitable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitable_files to fetch.
     */
    orderBy?: banner_more_profitable_fileOrderByWithRelationInput | banner_more_profitable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banner_more_profitable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitable_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banner_more_profitable_files
    **/
    _count?: true | Banner_more_profitable_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Banner_more_profitable_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Banner_more_profitable_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Banner_more_profitable_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Banner_more_profitable_fileMaxAggregateInputType
  }

  export type GetBanner_more_profitable_fileAggregateType<T extends Banner_more_profitable_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner_more_profitable_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner_more_profitable_file[P]>
      : GetScalarType<T[P], AggregateBanner_more_profitable_file[P]>
  }




  export type banner_more_profitable_fileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: banner_more_profitable_fileWhereInput
    orderBy?: banner_more_profitable_fileOrderByWithAggregationInput | banner_more_profitable_fileOrderByWithAggregationInput[]
    by: Banner_more_profitable_fileScalarFieldEnum[] | Banner_more_profitable_fileScalarFieldEnum
    having?: banner_more_profitable_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Banner_more_profitable_fileCountAggregateInputType | true
    _avg?: Banner_more_profitable_fileAvgAggregateInputType
    _sum?: Banner_more_profitable_fileSumAggregateInputType
    _min?: Banner_more_profitable_fileMinAggregateInputType
    _max?: Banner_more_profitable_fileMaxAggregateInputType
  }


  export type Banner_more_profitable_fileGroupByOutputType = {
    id: number
    file: string
    upload_at: Date
    _count: Banner_more_profitable_fileCountAggregateOutputType | null
    _avg: Banner_more_profitable_fileAvgAggregateOutputType | null
    _sum: Banner_more_profitable_fileSumAggregateOutputType | null
    _min: Banner_more_profitable_fileMinAggregateOutputType | null
    _max: Banner_more_profitable_fileMaxAggregateOutputType | null
  }

  type GetBanner_more_profitable_fileGroupByPayload<T extends banner_more_profitable_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Banner_more_profitable_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Banner_more_profitable_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Banner_more_profitable_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Banner_more_profitable_fileGroupByOutputType[P]>
        }
      >
    >


  export type banner_more_profitable_fileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file?: boolean
    upload_at?: boolean
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: boolean | banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs>
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: boolean | banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs>
  }, ExtArgs["result"]["banner_more_profitable_file"]>

  export type banner_more_profitable_fileSelectScalar = {
    id?: boolean
    file?: boolean
    upload_at?: boolean
  }

  export type banner_more_profitable_fileInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: boolean | banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs>
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: boolean | banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs>
  }


  type banner_more_profitable_fileGetPayload<S extends boolean | null | undefined | banner_more_profitable_fileArgs> = $Types.GetResult<banner_more_profitable_filePayload, S>

  type banner_more_profitable_fileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<banner_more_profitable_fileFindManyArgs, 'select' | 'include'> & {
      select?: Banner_more_profitable_fileCountAggregateInputType | true
    }

  export interface banner_more_profitable_fileDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banner_more_profitable_file'], meta: { name: 'banner_more_profitable_file' } }
    /**
     * Find zero or one Banner_more_profitable_file that matches the filter.
     * @param {banner_more_profitable_fileFindUniqueArgs} args - Arguments to find a Banner_more_profitable_file
     * @example
     * // Get one Banner_more_profitable_file
     * const banner_more_profitable_file = await prisma.banner_more_profitable_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends banner_more_profitable_fileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitable_fileFindUniqueArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banner_more_profitable_file that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {banner_more_profitable_fileFindUniqueOrThrowArgs} args - Arguments to find a Banner_more_profitable_file
     * @example
     * // Get one Banner_more_profitable_file
     * const banner_more_profitable_file = await prisma.banner_more_profitable_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends banner_more_profitable_fileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitable_fileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banner_more_profitable_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitable_fileFindFirstArgs} args - Arguments to find a Banner_more_profitable_file
     * @example
     * // Get one Banner_more_profitable_file
     * const banner_more_profitable_file = await prisma.banner_more_profitable_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends banner_more_profitable_fileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitable_fileFindFirstArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banner_more_profitable_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitable_fileFindFirstOrThrowArgs} args - Arguments to find a Banner_more_profitable_file
     * @example
     * // Get one Banner_more_profitable_file
     * const banner_more_profitable_file = await prisma.banner_more_profitable_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends banner_more_profitable_fileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitable_fileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banner_more_profitable_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitable_fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banner_more_profitable_files
     * const banner_more_profitable_files = await prisma.banner_more_profitable_file.findMany()
     * 
     * // Get first 10 Banner_more_profitable_files
     * const banner_more_profitable_files = await prisma.banner_more_profitable_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banner_more_profitable_fileWithIdOnly = await prisma.banner_more_profitable_file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends banner_more_profitable_fileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitable_fileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banner_more_profitable_file.
     * @param {banner_more_profitable_fileCreateArgs} args - Arguments to create a Banner_more_profitable_file.
     * @example
     * // Create one Banner_more_profitable_file
     * const Banner_more_profitable_file = await prisma.banner_more_profitable_file.create({
     *   data: {
     *     // ... data to create a Banner_more_profitable_file
     *   }
     * })
     * 
    **/
    create<T extends banner_more_profitable_fileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitable_fileCreateArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banner_more_profitable_files.
     *     @param {banner_more_profitable_fileCreateManyArgs} args - Arguments to create many Banner_more_profitable_files.
     *     @example
     *     // Create many Banner_more_profitable_files
     *     const banner_more_profitable_file = await prisma.banner_more_profitable_file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends banner_more_profitable_fileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitable_fileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner_more_profitable_file.
     * @param {banner_more_profitable_fileDeleteArgs} args - Arguments to delete one Banner_more_profitable_file.
     * @example
     * // Delete one Banner_more_profitable_file
     * const Banner_more_profitable_file = await prisma.banner_more_profitable_file.delete({
     *   where: {
     *     // ... filter to delete one Banner_more_profitable_file
     *   }
     * })
     * 
    **/
    delete<T extends banner_more_profitable_fileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitable_fileDeleteArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banner_more_profitable_file.
     * @param {banner_more_profitable_fileUpdateArgs} args - Arguments to update one Banner_more_profitable_file.
     * @example
     * // Update one Banner_more_profitable_file
     * const banner_more_profitable_file = await prisma.banner_more_profitable_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends banner_more_profitable_fileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitable_fileUpdateArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banner_more_profitable_files.
     * @param {banner_more_profitable_fileDeleteManyArgs} args - Arguments to filter Banner_more_profitable_files to delete.
     * @example
     * // Delete a few Banner_more_profitable_files
     * const { count } = await prisma.banner_more_profitable_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends banner_more_profitable_fileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, banner_more_profitable_fileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banner_more_profitable_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitable_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banner_more_profitable_files
     * const banner_more_profitable_file = await prisma.banner_more_profitable_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends banner_more_profitable_fileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitable_fileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner_more_profitable_file.
     * @param {banner_more_profitable_fileUpsertArgs} args - Arguments to update or create a Banner_more_profitable_file.
     * @example
     * // Update or create a Banner_more_profitable_file
     * const banner_more_profitable_file = await prisma.banner_more_profitable_file.upsert({
     *   create: {
     *     // ... data to create a Banner_more_profitable_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner_more_profitable_file we want to update
     *   }
     * })
    **/
    upsert<T extends banner_more_profitable_fileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, banner_more_profitable_fileUpsertArgs<ExtArgs>>
    ): Prisma__banner_more_profitable_fileClient<$Types.GetResult<banner_more_profitable_filePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banner_more_profitable_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitable_fileCountArgs} args - Arguments to filter Banner_more_profitable_files to count.
     * @example
     * // Count the number of Banner_more_profitable_files
     * const count = await prisma.banner_more_profitable_file.count({
     *   where: {
     *     // ... the filter for the Banner_more_profitable_files we want to count
     *   }
     * })
    **/
    count<T extends banner_more_profitable_fileCountArgs>(
      args?: Subset<T, banner_more_profitable_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Banner_more_profitable_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner_more_profitable_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Banner_more_profitable_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Banner_more_profitable_fileAggregateArgs>(args: Subset<T, Banner_more_profitable_fileAggregateArgs>): Prisma.PrismaPromise<GetBanner_more_profitable_fileAggregateType<T>>

    /**
     * Group by Banner_more_profitable_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banner_more_profitable_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banner_more_profitable_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banner_more_profitable_fileGroupByArgs['orderBy'] }
        : { orderBy?: banner_more_profitable_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banner_more_profitable_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanner_more_profitable_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banner_more_profitable_file model
   */
  readonly fields: banner_more_profitable_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banner_more_profitable_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__banner_more_profitable_fileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file<T extends banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs> = {}>(args?: Subset<T, banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs>>): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file<T extends banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs> = {}>(args?: Subset<T, banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs>>): Prisma__banner_more_profitableClient<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the banner_more_profitable_file model
   */ 
  interface banner_more_profitable_fileFieldRefs {
    readonly id: FieldRef<"banner_more_profitable_file", 'Int'>
    readonly file: FieldRef<"banner_more_profitable_file", 'String'>
    readonly upload_at: FieldRef<"banner_more_profitable_file", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * banner_more_profitable_file findUnique
   */
  export type banner_more_profitable_fileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable_file to fetch.
     */
    where: banner_more_profitable_fileWhereUniqueInput
  }


  /**
   * banner_more_profitable_file findUniqueOrThrow
   */
  export type banner_more_profitable_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable_file to fetch.
     */
    where: banner_more_profitable_fileWhereUniqueInput
  }


  /**
   * banner_more_profitable_file findFirst
   */
  export type banner_more_profitable_fileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable_file to fetch.
     */
    where?: banner_more_profitable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitable_files to fetch.
     */
    orderBy?: banner_more_profitable_fileOrderByWithRelationInput | banner_more_profitable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banner_more_profitable_files.
     */
    cursor?: banner_more_profitable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitable_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banner_more_profitable_files.
     */
    distinct?: Banner_more_profitable_fileScalarFieldEnum | Banner_more_profitable_fileScalarFieldEnum[]
  }


  /**
   * banner_more_profitable_file findFirstOrThrow
   */
  export type banner_more_profitable_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable_file to fetch.
     */
    where?: banner_more_profitable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitable_files to fetch.
     */
    orderBy?: banner_more_profitable_fileOrderByWithRelationInput | banner_more_profitable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banner_more_profitable_files.
     */
    cursor?: banner_more_profitable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitable_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banner_more_profitable_files.
     */
    distinct?: Banner_more_profitable_fileScalarFieldEnum | Banner_more_profitable_fileScalarFieldEnum[]
  }


  /**
   * banner_more_profitable_file findMany
   */
  export type banner_more_profitable_fileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * Filter, which banner_more_profitable_files to fetch.
     */
    where?: banner_more_profitable_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banner_more_profitable_files to fetch.
     */
    orderBy?: banner_more_profitable_fileOrderByWithRelationInput | banner_more_profitable_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banner_more_profitable_files.
     */
    cursor?: banner_more_profitable_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banner_more_profitable_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banner_more_profitable_files.
     */
    skip?: number
    distinct?: Banner_more_profitable_fileScalarFieldEnum | Banner_more_profitable_fileScalarFieldEnum[]
  }


  /**
   * banner_more_profitable_file create
   */
  export type banner_more_profitable_fileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * The data needed to create a banner_more_profitable_file.
     */
    data: XOR<banner_more_profitable_fileCreateInput, banner_more_profitable_fileUncheckedCreateInput>
  }


  /**
   * banner_more_profitable_file createMany
   */
  export type banner_more_profitable_fileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banner_more_profitable_files.
     */
    data: banner_more_profitable_fileCreateManyInput | banner_more_profitable_fileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * banner_more_profitable_file update
   */
  export type banner_more_profitable_fileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * The data needed to update a banner_more_profitable_file.
     */
    data: XOR<banner_more_profitable_fileUpdateInput, banner_more_profitable_fileUncheckedUpdateInput>
    /**
     * Choose, which banner_more_profitable_file to update.
     */
    where: banner_more_profitable_fileWhereUniqueInput
  }


  /**
   * banner_more_profitable_file updateMany
   */
  export type banner_more_profitable_fileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banner_more_profitable_files.
     */
    data: XOR<banner_more_profitable_fileUpdateManyMutationInput, banner_more_profitable_fileUncheckedUpdateManyInput>
    /**
     * Filter which banner_more_profitable_files to update
     */
    where?: banner_more_profitable_fileWhereInput
  }


  /**
   * banner_more_profitable_file upsert
   */
  export type banner_more_profitable_fileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * The filter to search for the banner_more_profitable_file to update in case it exists.
     */
    where: banner_more_profitable_fileWhereUniqueInput
    /**
     * In case the banner_more_profitable_file found by the `where` argument doesn't exist, create a new banner_more_profitable_file with this data.
     */
    create: XOR<banner_more_profitable_fileCreateInput, banner_more_profitable_fileUncheckedCreateInput>
    /**
     * In case the banner_more_profitable_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banner_more_profitable_fileUpdateInput, banner_more_profitable_fileUncheckedUpdateInput>
  }


  /**
   * banner_more_profitable_file delete
   */
  export type banner_more_profitable_fileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
    /**
     * Filter which banner_more_profitable_file to delete.
     */
    where: banner_more_profitable_fileWhereUniqueInput
  }


  /**
   * banner_more_profitable_file deleteMany
   */
  export type banner_more_profitable_fileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which banner_more_profitable_files to delete
     */
    where?: banner_more_profitable_fileWhereInput
  }


  /**
   * banner_more_profitable_file.banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file
   */
  export type banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    where?: banner_more_profitableWhereInput
  }


  /**
   * banner_more_profitable_file.banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file
   */
  export type banner_more_profitable_file$banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    where?: banner_more_profitableWhereInput
  }


  /**
   * banner_more_profitable_file without action
   */
  export type banner_more_profitable_fileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable_file
     */
    select?: banner_more_profitable_fileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitable_fileInclude<ExtArgs> | null
  }



  /**
   * Model bet_operations
   */


  export type AggregateBet_operations = {
    _count: Bet_operationsCountAggregateOutputType | null
    _avg: Bet_operationsAvgAggregateOutputType | null
    _sum: Bet_operationsSumAggregateOutputType | null
    _min: Bet_operationsMinAggregateOutputType | null
    _max: Bet_operationsMaxAggregateOutputType | null
  }

  export type Bet_operationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    slot_game_id: number | null
    amount: number | null
  }

  export type Bet_operationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    slot_game_id: number | null
    amount: number | null
  }

  export type Bet_operationsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    slot_game_id: number | null
    bet_transaction_id: string | null
    status: string | null
    amount: number | null
    round_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bet_operationsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    slot_game_id: number | null
    bet_transaction_id: string | null
    status: string | null
    amount: number | null
    round_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bet_operationsCountAggregateOutputType = {
    id: number
    user_id: number
    slot_game_id: number
    bet_transaction_id: number
    status: number
    amount: number
    round_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bet_operationsAvgAggregateInputType = {
    id?: true
    user_id?: true
    slot_game_id?: true
    amount?: true
  }

  export type Bet_operationsSumAggregateInputType = {
    id?: true
    user_id?: true
    slot_game_id?: true
    amount?: true
  }

  export type Bet_operationsMinAggregateInputType = {
    id?: true
    user_id?: true
    slot_game_id?: true
    bet_transaction_id?: true
    status?: true
    amount?: true
    round_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Bet_operationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    slot_game_id?: true
    bet_transaction_id?: true
    status?: true
    amount?: true
    round_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Bet_operationsCountAggregateInputType = {
    id?: true
    user_id?: true
    slot_game_id?: true
    bet_transaction_id?: true
    status?: true
    amount?: true
    round_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bet_operationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bet_operations to aggregate.
     */
    where?: bet_operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bet_operations to fetch.
     */
    orderBy?: bet_operationsOrderByWithRelationInput | bet_operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bet_operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bet_operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bet_operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bet_operations
    **/
    _count?: true | Bet_operationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bet_operationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bet_operationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bet_operationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bet_operationsMaxAggregateInputType
  }

  export type GetBet_operationsAggregateType<T extends Bet_operationsAggregateArgs> = {
        [P in keyof T & keyof AggregateBet_operations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBet_operations[P]>
      : GetScalarType<T[P], AggregateBet_operations[P]>
  }




  export type bet_operationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bet_operationsWhereInput
    orderBy?: bet_operationsOrderByWithAggregationInput | bet_operationsOrderByWithAggregationInput[]
    by: Bet_operationsScalarFieldEnum[] | Bet_operationsScalarFieldEnum
    having?: bet_operationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bet_operationsCountAggregateInputType | true
    _avg?: Bet_operationsAvgAggregateInputType
    _sum?: Bet_operationsSumAggregateInputType
    _min?: Bet_operationsMinAggregateInputType
    _max?: Bet_operationsMaxAggregateInputType
  }


  export type Bet_operationsGroupByOutputType = {
    id: number
    user_id: number
    slot_game_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id: string | null
    created_at: Date
    updated_at: Date
    _count: Bet_operationsCountAggregateOutputType | null
    _avg: Bet_operationsAvgAggregateOutputType | null
    _sum: Bet_operationsSumAggregateOutputType | null
    _min: Bet_operationsMinAggregateOutputType | null
    _max: Bet_operationsMaxAggregateOutputType | null
  }

  type GetBet_operationsGroupByPayload<T extends bet_operationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bet_operationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bet_operationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bet_operationsGroupByOutputType[P]>
            : GetScalarType<T[P], Bet_operationsGroupByOutputType[P]>
        }
      >
    >


  export type bet_operationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    slot_game_id?: boolean
    bet_transaction_id?: boolean
    status?: boolean
    amount?: boolean
    round_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userArgs<ExtArgs>
    slot_games?: boolean | slot_gamesArgs<ExtArgs>
  }, ExtArgs["result"]["bet_operations"]>

  export type bet_operationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    slot_game_id?: boolean
    bet_transaction_id?: boolean
    status?: boolean
    amount?: boolean
    round_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type bet_operationsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
    slot_games?: boolean | slot_gamesArgs<ExtArgs>
  }


  type bet_operationsGetPayload<S extends boolean | null | undefined | bet_operationsArgs> = $Types.GetResult<bet_operationsPayload, S>

  type bet_operationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bet_operationsFindManyArgs, 'select' | 'include'> & {
      select?: Bet_operationsCountAggregateInputType | true
    }

  export interface bet_operationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bet_operations'], meta: { name: 'bet_operations' } }
    /**
     * Find zero or one Bet_operations that matches the filter.
     * @param {bet_operationsFindUniqueArgs} args - Arguments to find a Bet_operations
     * @example
     * // Get one Bet_operations
     * const bet_operations = await prisma.bet_operations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bet_operationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bet_operationsFindUniqueArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bet_operations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bet_operationsFindUniqueOrThrowArgs} args - Arguments to find a Bet_operations
     * @example
     * // Get one Bet_operations
     * const bet_operations = await prisma.bet_operations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bet_operationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bet_operationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bet_operations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bet_operationsFindFirstArgs} args - Arguments to find a Bet_operations
     * @example
     * // Get one Bet_operations
     * const bet_operations = await prisma.bet_operations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bet_operationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bet_operationsFindFirstArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bet_operations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bet_operationsFindFirstOrThrowArgs} args - Arguments to find a Bet_operations
     * @example
     * // Get one Bet_operations
     * const bet_operations = await prisma.bet_operations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bet_operationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bet_operationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bet_operations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bet_operationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bet_operations
     * const bet_operations = await prisma.bet_operations.findMany()
     * 
     * // Get first 10 Bet_operations
     * const bet_operations = await prisma.bet_operations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bet_operationsWithIdOnly = await prisma.bet_operations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bet_operationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bet_operationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bet_operations.
     * @param {bet_operationsCreateArgs} args - Arguments to create a Bet_operations.
     * @example
     * // Create one Bet_operations
     * const Bet_operations = await prisma.bet_operations.create({
     *   data: {
     *     // ... data to create a Bet_operations
     *   }
     * })
     * 
    **/
    create<T extends bet_operationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bet_operationsCreateArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bet_operations.
     *     @param {bet_operationsCreateManyArgs} args - Arguments to create many Bet_operations.
     *     @example
     *     // Create many Bet_operations
     *     const bet_operations = await prisma.bet_operations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bet_operationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bet_operationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bet_operations.
     * @param {bet_operationsDeleteArgs} args - Arguments to delete one Bet_operations.
     * @example
     * // Delete one Bet_operations
     * const Bet_operations = await prisma.bet_operations.delete({
     *   where: {
     *     // ... filter to delete one Bet_operations
     *   }
     * })
     * 
    **/
    delete<T extends bet_operationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bet_operationsDeleteArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bet_operations.
     * @param {bet_operationsUpdateArgs} args - Arguments to update one Bet_operations.
     * @example
     * // Update one Bet_operations
     * const bet_operations = await prisma.bet_operations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bet_operationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bet_operationsUpdateArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bet_operations.
     * @param {bet_operationsDeleteManyArgs} args - Arguments to filter Bet_operations to delete.
     * @example
     * // Delete a few Bet_operations
     * const { count } = await prisma.bet_operations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bet_operationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bet_operationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bet_operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bet_operationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bet_operations
     * const bet_operations = await prisma.bet_operations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bet_operationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bet_operationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bet_operations.
     * @param {bet_operationsUpsertArgs} args - Arguments to update or create a Bet_operations.
     * @example
     * // Update or create a Bet_operations
     * const bet_operations = await prisma.bet_operations.upsert({
     *   create: {
     *     // ... data to create a Bet_operations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bet_operations we want to update
     *   }
     * })
    **/
    upsert<T extends bet_operationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bet_operationsUpsertArgs<ExtArgs>>
    ): Prisma__bet_operationsClient<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bet_operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bet_operationsCountArgs} args - Arguments to filter Bet_operations to count.
     * @example
     * // Count the number of Bet_operations
     * const count = await prisma.bet_operations.count({
     *   where: {
     *     // ... the filter for the Bet_operations we want to count
     *   }
     * })
    **/
    count<T extends bet_operationsCountArgs>(
      args?: Subset<T, bet_operationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bet_operationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bet_operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bet_operationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bet_operationsAggregateArgs>(args: Subset<T, Bet_operationsAggregateArgs>): Prisma.PrismaPromise<GetBet_operationsAggregateType<T>>

    /**
     * Group by Bet_operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bet_operationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bet_operationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bet_operationsGroupByArgs['orderBy'] }
        : { orderBy?: bet_operationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bet_operationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBet_operationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bet_operations model
   */
  readonly fields: bet_operationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bet_operations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__bet_operationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    slot_games<T extends slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, slot_gamesArgs<ExtArgs>>): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the bet_operations model
   */ 
  interface bet_operationsFieldRefs {
    readonly id: FieldRef<"bet_operations", 'Int'>
    readonly user_id: FieldRef<"bet_operations", 'Int'>
    readonly slot_game_id: FieldRef<"bet_operations", 'Int'>
    readonly bet_transaction_id: FieldRef<"bet_operations", 'String'>
    readonly status: FieldRef<"bet_operations", 'String'>
    readonly amount: FieldRef<"bet_operations", 'Float'>
    readonly round_id: FieldRef<"bet_operations", 'String'>
    readonly created_at: FieldRef<"bet_operations", 'DateTime'>
    readonly updated_at: FieldRef<"bet_operations", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bet_operations findUnique
   */
  export type bet_operationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * Filter, which bet_operations to fetch.
     */
    where: bet_operationsWhereUniqueInput
  }


  /**
   * bet_operations findUniqueOrThrow
   */
  export type bet_operationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * Filter, which bet_operations to fetch.
     */
    where: bet_operationsWhereUniqueInput
  }


  /**
   * bet_operations findFirst
   */
  export type bet_operationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * Filter, which bet_operations to fetch.
     */
    where?: bet_operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bet_operations to fetch.
     */
    orderBy?: bet_operationsOrderByWithRelationInput | bet_operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bet_operations.
     */
    cursor?: bet_operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bet_operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bet_operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bet_operations.
     */
    distinct?: Bet_operationsScalarFieldEnum | Bet_operationsScalarFieldEnum[]
  }


  /**
   * bet_operations findFirstOrThrow
   */
  export type bet_operationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * Filter, which bet_operations to fetch.
     */
    where?: bet_operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bet_operations to fetch.
     */
    orderBy?: bet_operationsOrderByWithRelationInput | bet_operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bet_operations.
     */
    cursor?: bet_operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bet_operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bet_operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bet_operations.
     */
    distinct?: Bet_operationsScalarFieldEnum | Bet_operationsScalarFieldEnum[]
  }


  /**
   * bet_operations findMany
   */
  export type bet_operationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * Filter, which bet_operations to fetch.
     */
    where?: bet_operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bet_operations to fetch.
     */
    orderBy?: bet_operationsOrderByWithRelationInput | bet_operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bet_operations.
     */
    cursor?: bet_operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bet_operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bet_operations.
     */
    skip?: number
    distinct?: Bet_operationsScalarFieldEnum | Bet_operationsScalarFieldEnum[]
  }


  /**
   * bet_operations create
   */
  export type bet_operationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * The data needed to create a bet_operations.
     */
    data: XOR<bet_operationsCreateInput, bet_operationsUncheckedCreateInput>
  }


  /**
   * bet_operations createMany
   */
  export type bet_operationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bet_operations.
     */
    data: bet_operationsCreateManyInput | bet_operationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bet_operations update
   */
  export type bet_operationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * The data needed to update a bet_operations.
     */
    data: XOR<bet_operationsUpdateInput, bet_operationsUncheckedUpdateInput>
    /**
     * Choose, which bet_operations to update.
     */
    where: bet_operationsWhereUniqueInput
  }


  /**
   * bet_operations updateMany
   */
  export type bet_operationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bet_operations.
     */
    data: XOR<bet_operationsUpdateManyMutationInput, bet_operationsUncheckedUpdateManyInput>
    /**
     * Filter which bet_operations to update
     */
    where?: bet_operationsWhereInput
  }


  /**
   * bet_operations upsert
   */
  export type bet_operationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * The filter to search for the bet_operations to update in case it exists.
     */
    where: bet_operationsWhereUniqueInput
    /**
     * In case the bet_operations found by the `where` argument doesn't exist, create a new bet_operations with this data.
     */
    create: XOR<bet_operationsCreateInput, bet_operationsUncheckedCreateInput>
    /**
     * In case the bet_operations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bet_operationsUpdateInput, bet_operationsUncheckedUpdateInput>
  }


  /**
   * bet_operations delete
   */
  export type bet_operationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    /**
     * Filter which bet_operations to delete.
     */
    where: bet_operationsWhereUniqueInput
  }


  /**
   * bet_operations deleteMany
   */
  export type bet_operationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bet_operations to delete
     */
    where?: bet_operationsWhereInput
  }


  /**
   * bet_operations without action
   */
  export type bet_operationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
  }



  /**
   * Model casino_most_popular
   */


  export type AggregateCasino_most_popular = {
    _count: Casino_most_popularCountAggregateOutputType | null
    _avg: Casino_most_popularAvgAggregateOutputType | null
    _sum: Casino_most_popularSumAggregateOutputType | null
    _min: Casino_most_popularMinAggregateOutputType | null
    _max: Casino_most_popularMaxAggregateOutputType | null
  }

  export type Casino_most_popularAvgAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Casino_most_popularSumAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Casino_most_popularMinAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Casino_most_popularMaxAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Casino_most_popularCountAggregateOutputType = {
    id: number
    qty_lines: number
    qty_columns: number
    _all: number
  }


  export type Casino_most_popularAvgAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Casino_most_popularSumAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Casino_most_popularMinAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Casino_most_popularMaxAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Casino_most_popularCountAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
    _all?: true
  }

  export type Casino_most_popularAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which casino_most_popular to aggregate.
     */
    where?: casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_populars to fetch.
     */
    orderBy?: casino_most_popularOrderByWithRelationInput | casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_populars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned casino_most_populars
    **/
    _count?: true | Casino_most_popularCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Casino_most_popularAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Casino_most_popularSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Casino_most_popularMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Casino_most_popularMaxAggregateInputType
  }

  export type GetCasino_most_popularAggregateType<T extends Casino_most_popularAggregateArgs> = {
        [P in keyof T & keyof AggregateCasino_most_popular]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCasino_most_popular[P]>
      : GetScalarType<T[P], AggregateCasino_most_popular[P]>
  }




  export type casino_most_popularGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: casino_most_popularWhereInput
    orderBy?: casino_most_popularOrderByWithAggregationInput | casino_most_popularOrderByWithAggregationInput[]
    by: Casino_most_popularScalarFieldEnum[] | Casino_most_popularScalarFieldEnum
    having?: casino_most_popularScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Casino_most_popularCountAggregateInputType | true
    _avg?: Casino_most_popularAvgAggregateInputType
    _sum?: Casino_most_popularSumAggregateInputType
    _min?: Casino_most_popularMinAggregateInputType
    _max?: Casino_most_popularMaxAggregateInputType
  }


  export type Casino_most_popularGroupByOutputType = {
    id: number
    qty_lines: number
    qty_columns: number
    _count: Casino_most_popularCountAggregateOutputType | null
    _avg: Casino_most_popularAvgAggregateOutputType | null
    _sum: Casino_most_popularSumAggregateOutputType | null
    _min: Casino_most_popularMinAggregateOutputType | null
    _max: Casino_most_popularMaxAggregateOutputType | null
  }

  type GetCasino_most_popularGroupByPayload<T extends casino_most_popularGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Casino_most_popularGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Casino_most_popularGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Casino_most_popularGroupByOutputType[P]>
            : GetScalarType<T[P], Casino_most_popularGroupByOutputType[P]>
        }
      >
    >


  export type casino_most_popularSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qty_lines?: boolean
    qty_columns?: boolean
    casino_most_popular_slot_games?: boolean | casino_most_popular$casino_most_popular_slot_gamesArgs<ExtArgs>
    slot_settings?: boolean | casino_most_popular$slot_settingsArgs<ExtArgs>
    _count?: boolean | Casino_most_popularCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["casino_most_popular"]>

  export type casino_most_popularSelectScalar = {
    id?: boolean
    qty_lines?: boolean
    qty_columns?: boolean
  }

  export type casino_most_popularInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    casino_most_popular_slot_games?: boolean | casino_most_popular$casino_most_popular_slot_gamesArgs<ExtArgs>
    slot_settings?: boolean | casino_most_popular$slot_settingsArgs<ExtArgs>
    _count?: boolean | Casino_most_popularCountOutputTypeArgs<ExtArgs>
  }


  type casino_most_popularGetPayload<S extends boolean | null | undefined | casino_most_popularArgs> = $Types.GetResult<casino_most_popularPayload, S>

  type casino_most_popularCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<casino_most_popularFindManyArgs, 'select' | 'include'> & {
      select?: Casino_most_popularCountAggregateInputType | true
    }

  export interface casino_most_popularDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['casino_most_popular'], meta: { name: 'casino_most_popular' } }
    /**
     * Find zero or one Casino_most_popular that matches the filter.
     * @param {casino_most_popularFindUniqueArgs} args - Arguments to find a Casino_most_popular
     * @example
     * // Get one Casino_most_popular
     * const casino_most_popular = await prisma.casino_most_popular.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends casino_most_popularFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popularFindUniqueArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Casino_most_popular that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {casino_most_popularFindUniqueOrThrowArgs} args - Arguments to find a Casino_most_popular
     * @example
     * // Get one Casino_most_popular
     * const casino_most_popular = await prisma.casino_most_popular.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends casino_most_popularFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popularFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Casino_most_popular that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popularFindFirstArgs} args - Arguments to find a Casino_most_popular
     * @example
     * // Get one Casino_most_popular
     * const casino_most_popular = await prisma.casino_most_popular.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends casino_most_popularFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popularFindFirstArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Casino_most_popular that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popularFindFirstOrThrowArgs} args - Arguments to find a Casino_most_popular
     * @example
     * // Get one Casino_most_popular
     * const casino_most_popular = await prisma.casino_most_popular.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends casino_most_popularFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popularFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Casino_most_populars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popularFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Casino_most_populars
     * const casino_most_populars = await prisma.casino_most_popular.findMany()
     * 
     * // Get first 10 Casino_most_populars
     * const casino_most_populars = await prisma.casino_most_popular.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const casino_most_popularWithIdOnly = await prisma.casino_most_popular.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends casino_most_popularFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popularFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Casino_most_popular.
     * @param {casino_most_popularCreateArgs} args - Arguments to create a Casino_most_popular.
     * @example
     * // Create one Casino_most_popular
     * const Casino_most_popular = await prisma.casino_most_popular.create({
     *   data: {
     *     // ... data to create a Casino_most_popular
     *   }
     * })
     * 
    **/
    create<T extends casino_most_popularCreateArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popularCreateArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Casino_most_populars.
     *     @param {casino_most_popularCreateManyArgs} args - Arguments to create many Casino_most_populars.
     *     @example
     *     // Create many Casino_most_populars
     *     const casino_most_popular = await prisma.casino_most_popular.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends casino_most_popularCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popularCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Casino_most_popular.
     * @param {casino_most_popularDeleteArgs} args - Arguments to delete one Casino_most_popular.
     * @example
     * // Delete one Casino_most_popular
     * const Casino_most_popular = await prisma.casino_most_popular.delete({
     *   where: {
     *     // ... filter to delete one Casino_most_popular
     *   }
     * })
     * 
    **/
    delete<T extends casino_most_popularDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popularDeleteArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Casino_most_popular.
     * @param {casino_most_popularUpdateArgs} args - Arguments to update one Casino_most_popular.
     * @example
     * // Update one Casino_most_popular
     * const casino_most_popular = await prisma.casino_most_popular.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends casino_most_popularUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popularUpdateArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Casino_most_populars.
     * @param {casino_most_popularDeleteManyArgs} args - Arguments to filter Casino_most_populars to delete.
     * @example
     * // Delete a few Casino_most_populars
     * const { count } = await prisma.casino_most_popular.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends casino_most_popularDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popularDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Casino_most_populars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popularUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Casino_most_populars
     * const casino_most_popular = await prisma.casino_most_popular.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends casino_most_popularUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popularUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Casino_most_popular.
     * @param {casino_most_popularUpsertArgs} args - Arguments to update or create a Casino_most_popular.
     * @example
     * // Update or create a Casino_most_popular
     * const casino_most_popular = await prisma.casino_most_popular.upsert({
     *   create: {
     *     // ... data to create a Casino_most_popular
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Casino_most_popular we want to update
     *   }
     * })
    **/
    upsert<T extends casino_most_popularUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popularUpsertArgs<ExtArgs>>
    ): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Casino_most_populars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popularCountArgs} args - Arguments to filter Casino_most_populars to count.
     * @example
     * // Count the number of Casino_most_populars
     * const count = await prisma.casino_most_popular.count({
     *   where: {
     *     // ... the filter for the Casino_most_populars we want to count
     *   }
     * })
    **/
    count<T extends casino_most_popularCountArgs>(
      args?: Subset<T, casino_most_popularCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Casino_most_popularCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Casino_most_popular.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Casino_most_popularAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Casino_most_popularAggregateArgs>(args: Subset<T, Casino_most_popularAggregateArgs>): Prisma.PrismaPromise<GetCasino_most_popularAggregateType<T>>

    /**
     * Group by Casino_most_popular.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popularGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends casino_most_popularGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: casino_most_popularGroupByArgs['orderBy'] }
        : { orderBy?: casino_most_popularGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, casino_most_popularGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCasino_most_popularGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the casino_most_popular model
   */
  readonly fields: casino_most_popularFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for casino_most_popular.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__casino_most_popularClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    casino_most_popular_slot_games<T extends casino_most_popular$casino_most_popular_slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, casino_most_popular$casino_most_popular_slot_gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findMany'>| Null>;

    slot_settings<T extends casino_most_popular$slot_settingsArgs<ExtArgs> = {}>(args?: Subset<T, casino_most_popular$slot_settingsArgs<ExtArgs>>): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the casino_most_popular model
   */ 
  interface casino_most_popularFieldRefs {
    readonly id: FieldRef<"casino_most_popular", 'Int'>
    readonly qty_lines: FieldRef<"casino_most_popular", 'Int'>
    readonly qty_columns: FieldRef<"casino_most_popular", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * casino_most_popular findUnique
   */
  export type casino_most_popularFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular to fetch.
     */
    where: casino_most_popularWhereUniqueInput
  }


  /**
   * casino_most_popular findUniqueOrThrow
   */
  export type casino_most_popularFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular to fetch.
     */
    where: casino_most_popularWhereUniqueInput
  }


  /**
   * casino_most_popular findFirst
   */
  export type casino_most_popularFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular to fetch.
     */
    where?: casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_populars to fetch.
     */
    orderBy?: casino_most_popularOrderByWithRelationInput | casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for casino_most_populars.
     */
    cursor?: casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_populars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of casino_most_populars.
     */
    distinct?: Casino_most_popularScalarFieldEnum | Casino_most_popularScalarFieldEnum[]
  }


  /**
   * casino_most_popular findFirstOrThrow
   */
  export type casino_most_popularFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular to fetch.
     */
    where?: casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_populars to fetch.
     */
    orderBy?: casino_most_popularOrderByWithRelationInput | casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for casino_most_populars.
     */
    cursor?: casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_populars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of casino_most_populars.
     */
    distinct?: Casino_most_popularScalarFieldEnum | Casino_most_popularScalarFieldEnum[]
  }


  /**
   * casino_most_popular findMany
   */
  export type casino_most_popularFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_populars to fetch.
     */
    where?: casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_populars to fetch.
     */
    orderBy?: casino_most_popularOrderByWithRelationInput | casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing casino_most_populars.
     */
    cursor?: casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_populars.
     */
    skip?: number
    distinct?: Casino_most_popularScalarFieldEnum | Casino_most_popularScalarFieldEnum[]
  }


  /**
   * casino_most_popular create
   */
  export type casino_most_popularCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * The data needed to create a casino_most_popular.
     */
    data: XOR<casino_most_popularCreateInput, casino_most_popularUncheckedCreateInput>
  }


  /**
   * casino_most_popular createMany
   */
  export type casino_most_popularCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many casino_most_populars.
     */
    data: casino_most_popularCreateManyInput | casino_most_popularCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * casino_most_popular update
   */
  export type casino_most_popularUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * The data needed to update a casino_most_popular.
     */
    data: XOR<casino_most_popularUpdateInput, casino_most_popularUncheckedUpdateInput>
    /**
     * Choose, which casino_most_popular to update.
     */
    where: casino_most_popularWhereUniqueInput
  }


  /**
   * casino_most_popular updateMany
   */
  export type casino_most_popularUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update casino_most_populars.
     */
    data: XOR<casino_most_popularUpdateManyMutationInput, casino_most_popularUncheckedUpdateManyInput>
    /**
     * Filter which casino_most_populars to update
     */
    where?: casino_most_popularWhereInput
  }


  /**
   * casino_most_popular upsert
   */
  export type casino_most_popularUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * The filter to search for the casino_most_popular to update in case it exists.
     */
    where: casino_most_popularWhereUniqueInput
    /**
     * In case the casino_most_popular found by the `where` argument doesn't exist, create a new casino_most_popular with this data.
     */
    create: XOR<casino_most_popularCreateInput, casino_most_popularUncheckedCreateInput>
    /**
     * In case the casino_most_popular was found with the provided `where` argument, update it with this data.
     */
    update: XOR<casino_most_popularUpdateInput, casino_most_popularUncheckedUpdateInput>
  }


  /**
   * casino_most_popular delete
   */
  export type casino_most_popularDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter which casino_most_popular to delete.
     */
    where: casino_most_popularWhereUniqueInput
  }


  /**
   * casino_most_popular deleteMany
   */
  export type casino_most_popularDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which casino_most_populars to delete
     */
    where?: casino_most_popularWhereInput
  }


  /**
   * casino_most_popular.casino_most_popular_slot_games
   */
  export type casino_most_popular$casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    where?: casino_most_popular_slot_gamesWhereInput
    orderBy?: casino_most_popular_slot_gamesOrderByWithRelationInput | casino_most_popular_slot_gamesOrderByWithRelationInput[]
    cursor?: casino_most_popular_slot_gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Casino_most_popular_slot_gamesScalarFieldEnum | Casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * casino_most_popular.slot_settings
   */
  export type casino_most_popular$slot_settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    where?: slot_settingsWhereInput
  }


  /**
   * casino_most_popular without action
   */
  export type casino_most_popularArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
  }



  /**
   * Model casino_most_popular_slot_games
   */


  export type AggregateCasino_most_popular_slot_games = {
    _count: Casino_most_popular_slot_gamesCountAggregateOutputType | null
    _avg: Casino_most_popular_slot_gamesAvgAggregateOutputType | null
    _sum: Casino_most_popular_slot_gamesSumAggregateOutputType | null
    _min: Casino_most_popular_slot_gamesMinAggregateOutputType | null
    _max: Casino_most_popular_slot_gamesMaxAggregateOutputType | null
  }

  export type Casino_most_popular_slot_gamesAvgAggregateOutputType = {
    casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Casino_most_popular_slot_gamesSumAggregateOutputType = {
    casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Casino_most_popular_slot_gamesMinAggregateOutputType = {
    casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Casino_most_popular_slot_gamesMaxAggregateOutputType = {
    casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Casino_most_popular_slot_gamesCountAggregateOutputType = {
    casino_most_popular_id: number
    slot_games_id: number
    _all: number
  }


  export type Casino_most_popular_slot_gamesAvgAggregateInputType = {
    casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Casino_most_popular_slot_gamesSumAggregateInputType = {
    casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Casino_most_popular_slot_gamesMinAggregateInputType = {
    casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Casino_most_popular_slot_gamesMaxAggregateInputType = {
    casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Casino_most_popular_slot_gamesCountAggregateInputType = {
    casino_most_popular_id?: true
    slot_games_id?: true
    _all?: true
  }

  export type Casino_most_popular_slot_gamesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which casino_most_popular_slot_games to aggregate.
     */
    where?: casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_popular_slot_games to fetch.
     */
    orderBy?: casino_most_popular_slot_gamesOrderByWithRelationInput | casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_popular_slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned casino_most_popular_slot_games
    **/
    _count?: true | Casino_most_popular_slot_gamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Casino_most_popular_slot_gamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Casino_most_popular_slot_gamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Casino_most_popular_slot_gamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Casino_most_popular_slot_gamesMaxAggregateInputType
  }

  export type GetCasino_most_popular_slot_gamesAggregateType<T extends Casino_most_popular_slot_gamesAggregateArgs> = {
        [P in keyof T & keyof AggregateCasino_most_popular_slot_games]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCasino_most_popular_slot_games[P]>
      : GetScalarType<T[P], AggregateCasino_most_popular_slot_games[P]>
  }




  export type casino_most_popular_slot_gamesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: casino_most_popular_slot_gamesWhereInput
    orderBy?: casino_most_popular_slot_gamesOrderByWithAggregationInput | casino_most_popular_slot_gamesOrderByWithAggregationInput[]
    by: Casino_most_popular_slot_gamesScalarFieldEnum[] | Casino_most_popular_slot_gamesScalarFieldEnum
    having?: casino_most_popular_slot_gamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Casino_most_popular_slot_gamesCountAggregateInputType | true
    _avg?: Casino_most_popular_slot_gamesAvgAggregateInputType
    _sum?: Casino_most_popular_slot_gamesSumAggregateInputType
    _min?: Casino_most_popular_slot_gamesMinAggregateInputType
    _max?: Casino_most_popular_slot_gamesMaxAggregateInputType
  }


  export type Casino_most_popular_slot_gamesGroupByOutputType = {
    casino_most_popular_id: number
    slot_games_id: number
    _count: Casino_most_popular_slot_gamesCountAggregateOutputType | null
    _avg: Casino_most_popular_slot_gamesAvgAggregateOutputType | null
    _sum: Casino_most_popular_slot_gamesSumAggregateOutputType | null
    _min: Casino_most_popular_slot_gamesMinAggregateOutputType | null
    _max: Casino_most_popular_slot_gamesMaxAggregateOutputType | null
  }

  type GetCasino_most_popular_slot_gamesGroupByPayload<T extends casino_most_popular_slot_gamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Casino_most_popular_slot_gamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Casino_most_popular_slot_gamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Casino_most_popular_slot_gamesGroupByOutputType[P]>
            : GetScalarType<T[P], Casino_most_popular_slot_gamesGroupByOutputType[P]>
        }
      >
    >


  export type casino_most_popular_slot_gamesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    casino_most_popular_id?: boolean
    slot_games_id?: boolean
    slot_games?: boolean | slot_gamesArgs<ExtArgs>
    casino_most_popular?: boolean | casino_most_popularArgs<ExtArgs>
  }, ExtArgs["result"]["casino_most_popular_slot_games"]>

  export type casino_most_popular_slot_gamesSelectScalar = {
    casino_most_popular_id?: boolean
    slot_games_id?: boolean
  }

  export type casino_most_popular_slot_gamesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    slot_games?: boolean | slot_gamesArgs<ExtArgs>
    casino_most_popular?: boolean | casino_most_popularArgs<ExtArgs>
  }


  type casino_most_popular_slot_gamesGetPayload<S extends boolean | null | undefined | casino_most_popular_slot_gamesArgs> = $Types.GetResult<casino_most_popular_slot_gamesPayload, S>

  type casino_most_popular_slot_gamesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<casino_most_popular_slot_gamesFindManyArgs, 'select' | 'include'> & {
      select?: Casino_most_popular_slot_gamesCountAggregateInputType | true
    }

  export interface casino_most_popular_slot_gamesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['casino_most_popular_slot_games'], meta: { name: 'casino_most_popular_slot_games' } }
    /**
     * Find zero or one Casino_most_popular_slot_games that matches the filter.
     * @param {casino_most_popular_slot_gamesFindUniqueArgs} args - Arguments to find a Casino_most_popular_slot_games
     * @example
     * // Get one Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Casino_most_popular_slot_games that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {casino_most_popular_slot_gamesFindUniqueOrThrowArgs} args - Arguments to find a Casino_most_popular_slot_games
     * @example
     * // Get one Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Casino_most_popular_slot_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popular_slot_gamesFindFirstArgs} args - Arguments to find a Casino_most_popular_slot_games
     * @example
     * // Get one Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends casino_most_popular_slot_gamesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popular_slot_gamesFindFirstArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Casino_most_popular_slot_games that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popular_slot_gamesFindFirstOrThrowArgs} args - Arguments to find a Casino_most_popular_slot_games
     * @example
     * // Get one Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Casino_most_popular_slot_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popular_slot_gamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.findMany()
     * 
     * // Get first 10 Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.findMany({ take: 10 })
     * 
     * // Only select the `casino_most_popular_id`
     * const casino_most_popular_slot_gamesWithCasino_most_popular_idOnly = await prisma.casino_most_popular_slot_games.findMany({ select: { casino_most_popular_id: true } })
     * 
    **/
    findMany<T extends casino_most_popular_slot_gamesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popular_slot_gamesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Casino_most_popular_slot_games.
     * @param {casino_most_popular_slot_gamesCreateArgs} args - Arguments to create a Casino_most_popular_slot_games.
     * @example
     * // Create one Casino_most_popular_slot_games
     * const Casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.create({
     *   data: {
     *     // ... data to create a Casino_most_popular_slot_games
     *   }
     * })
     * 
    **/
    create<T extends casino_most_popular_slot_gamesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popular_slot_gamesCreateArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Casino_most_popular_slot_games.
     *     @param {casino_most_popular_slot_gamesCreateManyArgs} args - Arguments to create many Casino_most_popular_slot_games.
     *     @example
     *     // Create many Casino_most_popular_slot_games
     *     const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends casino_most_popular_slot_gamesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popular_slot_gamesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Casino_most_popular_slot_games.
     * @param {casino_most_popular_slot_gamesDeleteArgs} args - Arguments to delete one Casino_most_popular_slot_games.
     * @example
     * // Delete one Casino_most_popular_slot_games
     * const Casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.delete({
     *   where: {
     *     // ... filter to delete one Casino_most_popular_slot_games
     *   }
     * })
     * 
    **/
    delete<T extends casino_most_popular_slot_gamesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popular_slot_gamesDeleteArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Casino_most_popular_slot_games.
     * @param {casino_most_popular_slot_gamesUpdateArgs} args - Arguments to update one Casino_most_popular_slot_games.
     * @example
     * // Update one Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends casino_most_popular_slot_gamesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popular_slot_gamesUpdateArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Casino_most_popular_slot_games.
     * @param {casino_most_popular_slot_gamesDeleteManyArgs} args - Arguments to filter Casino_most_popular_slot_games to delete.
     * @example
     * // Delete a few Casino_most_popular_slot_games
     * const { count } = await prisma.casino_most_popular_slot_games.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popular_slot_gamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Casino_most_popular_slot_games.
     * @param {casino_most_popular_slot_gamesUpsertArgs} args - Arguments to update or create a Casino_most_popular_slot_games.
     * @example
     * // Update or create a Casino_most_popular_slot_games
     * const casino_most_popular_slot_games = await prisma.casino_most_popular_slot_games.upsert({
     *   create: {
     *     // ... data to create a Casino_most_popular_slot_games
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Casino_most_popular_slot_games we want to update
     *   }
     * })
    **/
    upsert<T extends casino_most_popular_slot_gamesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, casino_most_popular_slot_gamesUpsertArgs<ExtArgs>>
    ): Prisma__casino_most_popular_slot_gamesClient<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popular_slot_gamesCountArgs} args - Arguments to filter Casino_most_popular_slot_games to count.
     * @example
     * // Count the number of Casino_most_popular_slot_games
     * const count = await prisma.casino_most_popular_slot_games.count({
     *   where: {
     *     // ... the filter for the Casino_most_popular_slot_games we want to count
     *   }
     * })
    **/
    count<T extends casino_most_popular_slot_gamesCountArgs>(
      args?: Subset<T, casino_most_popular_slot_gamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Casino_most_popular_slot_gamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Casino_most_popular_slot_gamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Casino_most_popular_slot_gamesAggregateArgs>(args: Subset<T, Casino_most_popular_slot_gamesAggregateArgs>): Prisma.PrismaPromise<GetCasino_most_popular_slot_gamesAggregateType<T>>

    /**
     * Group by Casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {casino_most_popular_slot_gamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends casino_most_popular_slot_gamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: casino_most_popular_slot_gamesGroupByArgs['orderBy'] }
        : { orderBy?: casino_most_popular_slot_gamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, casino_most_popular_slot_gamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCasino_most_popular_slot_gamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the casino_most_popular_slot_games model
   */
  readonly fields: casino_most_popular_slot_gamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for casino_most_popular_slot_games.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__casino_most_popular_slot_gamesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    slot_games<T extends slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, slot_gamesArgs<ExtArgs>>): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    casino_most_popular<T extends casino_most_popularArgs<ExtArgs> = {}>(args?: Subset<T, casino_most_popularArgs<ExtArgs>>): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the casino_most_popular_slot_games model
   */ 
  interface casino_most_popular_slot_gamesFieldRefs {
    readonly casino_most_popular_id: FieldRef<"casino_most_popular_slot_games", 'Int'>
    readonly slot_games_id: FieldRef<"casino_most_popular_slot_games", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * casino_most_popular_slot_games findUnique
   */
  export type casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular_slot_games to fetch.
     */
    where: casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * casino_most_popular_slot_games findUniqueOrThrow
   */
  export type casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular_slot_games to fetch.
     */
    where: casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * casino_most_popular_slot_games findFirst
   */
  export type casino_most_popular_slot_gamesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular_slot_games to fetch.
     */
    where?: casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_popular_slot_games to fetch.
     */
    orderBy?: casino_most_popular_slot_gamesOrderByWithRelationInput | casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for casino_most_popular_slot_games.
     */
    cursor?: casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_popular_slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of casino_most_popular_slot_games.
     */
    distinct?: Casino_most_popular_slot_gamesScalarFieldEnum | Casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * casino_most_popular_slot_games findFirstOrThrow
   */
  export type casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular_slot_games to fetch.
     */
    where?: casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_popular_slot_games to fetch.
     */
    orderBy?: casino_most_popular_slot_gamesOrderByWithRelationInput | casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for casino_most_popular_slot_games.
     */
    cursor?: casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_popular_slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of casino_most_popular_slot_games.
     */
    distinct?: Casino_most_popular_slot_gamesScalarFieldEnum | Casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * casino_most_popular_slot_games findMany
   */
  export type casino_most_popular_slot_gamesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which casino_most_popular_slot_games to fetch.
     */
    where?: casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of casino_most_popular_slot_games to fetch.
     */
    orderBy?: casino_most_popular_slot_gamesOrderByWithRelationInput | casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing casino_most_popular_slot_games.
     */
    cursor?: casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` casino_most_popular_slot_games.
     */
    skip?: number
    distinct?: Casino_most_popular_slot_gamesScalarFieldEnum | Casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * casino_most_popular_slot_games create
   */
  export type casino_most_popular_slot_gamesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * The data needed to create a casino_most_popular_slot_games.
     */
    data: XOR<casino_most_popular_slot_gamesCreateInput, casino_most_popular_slot_gamesUncheckedCreateInput>
  }


  /**
   * casino_most_popular_slot_games createMany
   */
  export type casino_most_popular_slot_gamesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many casino_most_popular_slot_games.
     */
    data: casino_most_popular_slot_gamesCreateManyInput | casino_most_popular_slot_gamesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * casino_most_popular_slot_games update
   */
  export type casino_most_popular_slot_gamesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * The data needed to update a casino_most_popular_slot_games.
     */
    data: XOR<casino_most_popular_slot_gamesUpdateInput, casino_most_popular_slot_gamesUncheckedUpdateInput>
    /**
     * Choose, which casino_most_popular_slot_games to update.
     */
    where: casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * casino_most_popular_slot_games updateMany
   */
  export type casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update casino_most_popular_slot_games.
     */
    data: XOR<casino_most_popular_slot_gamesUpdateManyMutationInput, casino_most_popular_slot_gamesUncheckedUpdateManyInput>
    /**
     * Filter which casino_most_popular_slot_games to update
     */
    where?: casino_most_popular_slot_gamesWhereInput
  }


  /**
   * casino_most_popular_slot_games upsert
   */
  export type casino_most_popular_slot_gamesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * The filter to search for the casino_most_popular_slot_games to update in case it exists.
     */
    where: casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * In case the casino_most_popular_slot_games found by the `where` argument doesn't exist, create a new casino_most_popular_slot_games with this data.
     */
    create: XOR<casino_most_popular_slot_gamesCreateInput, casino_most_popular_slot_gamesUncheckedCreateInput>
    /**
     * In case the casino_most_popular_slot_games was found with the provided `where` argument, update it with this data.
     */
    update: XOR<casino_most_popular_slot_gamesUpdateInput, casino_most_popular_slot_gamesUncheckedUpdateInput>
  }


  /**
   * casino_most_popular_slot_games delete
   */
  export type casino_most_popular_slot_gamesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter which casino_most_popular_slot_games to delete.
     */
    where: casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * casino_most_popular_slot_games deleteMany
   */
  export type casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which casino_most_popular_slot_games to delete
     */
    where?: casino_most_popular_slot_gamesWhereInput
  }


  /**
   * casino_most_popular_slot_games without action
   */
  export type casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
  }



  /**
   * Model client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    settings_id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    settings_id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    settings_id: number | null
    key_id_prod: string | null
    key_secret_prod: string | null
    key_id_stage: string | null
    key_secret_stage: string | null
    currency: string | null
    language: string | null
    url_return: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    prod_callback: string | null
    stage_callback: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    settings_id: number | null
    key_id_prod: string | null
    key_secret_prod: string | null
    key_id_stage: string | null
    key_secret_stage: string | null
    currency: string | null
    language: string | null
    url_return: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    prod_callback: string | null
    stage_callback: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    settings_id: number
    key_id_prod: number
    key_secret_prod: number
    key_id_stage: number
    key_secret_stage: number
    currency: number
    language: number
    url_return: number
    created_at: number
    updated_at: number
    name: number
    prod_callback: number
    stage_callback: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    settings_id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    settings_id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    settings_id?: true
    key_id_prod?: true
    key_secret_prod?: true
    key_id_stage?: true
    key_secret_stage?: true
    currency?: true
    language?: true
    url_return?: true
    created_at?: true
    updated_at?: true
    name?: true
    prod_callback?: true
    stage_callback?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    settings_id?: true
    key_id_prod?: true
    key_secret_prod?: true
    key_id_stage?: true
    key_secret_stage?: true
    currency?: true
    language?: true
    url_return?: true
    created_at?: true
    updated_at?: true
    name?: true
    prod_callback?: true
    stage_callback?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    settings_id?: true
    key_id_prod?: true
    key_secret_prod?: true
    key_id_stage?: true
    key_secret_stage?: true
    currency?: true
    language?: true
    url_return?: true
    created_at?: true
    updated_at?: true
    name?: true
    prod_callback?: true
    stage_callback?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which client to aggregate.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type clientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: clientWhereInput
    orderBy?: clientOrderByWithAggregationInput | clientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: clientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    id: number
    settings_id: number | null
    key_id_prod: string | null
    key_secret_prod: string | null
    key_id_stage: string | null
    key_secret_stage: string | null
    currency: string | null
    language: string | null
    url_return: string | null
    created_at: Date
    updated_at: Date
    name: string | null
    prod_callback: string | null
    stage_callback: string | null
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends clientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type clientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings_id?: boolean
    key_id_prod?: boolean
    key_secret_prod?: boolean
    key_id_stage?: boolean
    key_secret_stage?: boolean
    currency?: boolean
    language?: boolean
    url_return?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    prod_callback?: boolean
    stage_callback?: boolean
    settings_client_settings_idTosettings?: boolean | client$settings_client_settings_idTosettingsArgs<ExtArgs>
    client_auth_user?: boolean | client$client_auth_userArgs<ExtArgs>
    settings_settings_client_idToclient?: boolean | client$settings_settings_client_idToclientArgs<ExtArgs>
    user?: boolean | client$userArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type clientSelectScalar = {
    id?: boolean
    settings_id?: boolean
    key_id_prod?: boolean
    key_secret_prod?: boolean
    key_id_stage?: boolean
    key_secret_stage?: boolean
    currency?: boolean
    language?: boolean
    url_return?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    prod_callback?: boolean
    stage_callback?: boolean
  }

  export type clientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    settings_client_settings_idTosettings?: boolean | client$settings_client_settings_idTosettingsArgs<ExtArgs>
    client_auth_user?: boolean | client$client_auth_userArgs<ExtArgs>
    settings_settings_client_idToclient?: boolean | client$settings_settings_client_idToclientArgs<ExtArgs>
    user?: boolean | client$userArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeArgs<ExtArgs>
  }


  type clientGetPayload<S extends boolean | null | undefined | clientArgs> = $Types.GetResult<clientPayload, S>

  type clientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<clientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface clientDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client'], meta: { name: 'client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {clientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, clientFindUniqueArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {clientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends clientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindFirstArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends clientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends clientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<clientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {clientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends clientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, clientCreateArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     *     @param {clientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {clientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends clientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, clientDeleteArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {clientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, clientUpdateArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {clientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, clientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {clientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends clientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, clientUpsertArgs<ExtArgs>>
    ): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientCountArgs>(
      args?: Subset<T, clientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientGroupByArgs['orderBy'] }
        : { orderBy?: clientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client model
   */
  readonly fields: clientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    settings_client_settings_idTosettings<T extends client$settings_client_settings_idTosettingsArgs<ExtArgs> = {}>(args?: Subset<T, client$settings_client_settings_idTosettingsArgs<ExtArgs>>): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    client_auth_user<T extends client$client_auth_userArgs<ExtArgs> = {}>(args?: Subset<T, client$client_auth_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'findMany'>| Null>;

    settings_settings_client_idToclient<T extends client$settings_settings_client_idToclientArgs<ExtArgs> = {}>(args?: Subset<T, client$settings_settings_client_idToclientArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findMany'>| Null>;

    user<T extends client$userArgs<ExtArgs> = {}>(args?: Subset<T, client$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the client model
   */ 
  interface clientFieldRefs {
    readonly id: FieldRef<"client", 'Int'>
    readonly settings_id: FieldRef<"client", 'Int'>
    readonly key_id_prod: FieldRef<"client", 'String'>
    readonly key_secret_prod: FieldRef<"client", 'String'>
    readonly key_id_stage: FieldRef<"client", 'String'>
    readonly key_secret_stage: FieldRef<"client", 'String'>
    readonly currency: FieldRef<"client", 'String'>
    readonly language: FieldRef<"client", 'String'>
    readonly url_return: FieldRef<"client", 'String'>
    readonly created_at: FieldRef<"client", 'DateTime'>
    readonly updated_at: FieldRef<"client", 'DateTime'>
    readonly name: FieldRef<"client", 'String'>
    readonly prod_callback: FieldRef<"client", 'String'>
    readonly stage_callback: FieldRef<"client", 'String'>
  }
    

  // Custom InputTypes

  /**
   * client findUnique
   */
  export type clientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client findUniqueOrThrow
   */
  export type clientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client findFirst
   */
  export type clientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * client findFirstOrThrow
   */
  export type clientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which client to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * client findMany
   */
  export type clientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientOrderByWithRelationInput | clientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     */
    cursor?: clientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * client create
   */
  export type clientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The data needed to create a client.
     */
    data: XOR<clientCreateInput, clientUncheckedCreateInput>
  }


  /**
   * client createMany
   */
  export type clientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clients.
     */
    data: clientCreateManyInput | clientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * client update
   */
  export type clientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The data needed to update a client.
     */
    data: XOR<clientUpdateInput, clientUncheckedUpdateInput>
    /**
     * Choose, which client to update.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client updateMany
   */
  export type clientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clients.
     */
    data: XOR<clientUpdateManyMutationInput, clientUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientWhereInput
  }


  /**
   * client upsert
   */
  export type clientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * The filter to search for the client to update in case it exists.
     */
    where: clientWhereUniqueInput
    /**
     * In case the client found by the `where` argument doesn't exist, create a new client with this data.
     */
    create: XOR<clientCreateInput, clientUncheckedCreateInput>
    /**
     * In case the client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientUpdateInput, clientUncheckedUpdateInput>
  }


  /**
   * client delete
   */
  export type clientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    /**
     * Filter which client to delete.
     */
    where: clientWhereUniqueInput
  }


  /**
   * client deleteMany
   */
  export type clientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to delete
     */
    where?: clientWhereInput
  }


  /**
   * client.settings_client_settings_idTosettings
   */
  export type client$settings_client_settings_idTosettingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    where?: settingsWhereInput
  }


  /**
   * client.client_auth_user
   */
  export type client$client_auth_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    where?: client_auth_userWhereInput
    orderBy?: client_auth_userOrderByWithRelationInput | client_auth_userOrderByWithRelationInput[]
    cursor?: client_auth_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_auth_userScalarFieldEnum | Client_auth_userScalarFieldEnum[]
  }


  /**
   * client.settings_settings_client_idToclient
   */
  export type client$settings_settings_client_idToclientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    cursor?: settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }


  /**
   * client.user
   */
  export type client$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * client without action
   */
  export type clientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
  }



  /**
   * Model client_auth_user
   */


  export type AggregateClient_auth_user = {
    _count: Client_auth_userCountAggregateOutputType | null
    _avg: Client_auth_userAvgAggregateOutputType | null
    _sum: Client_auth_userSumAggregateOutputType | null
    _min: Client_auth_userMinAggregateOutputType | null
    _max: Client_auth_userMaxAggregateOutputType | null
  }

  export type Client_auth_userAvgAggregateOutputType = {
    client_id: number | null
    auth_user_id: number | null
  }

  export type Client_auth_userSumAggregateOutputType = {
    client_id: number | null
    auth_user_id: number | null
  }

  export type Client_auth_userMinAggregateOutputType = {
    client_id: number | null
    auth_user_id: number | null
  }

  export type Client_auth_userMaxAggregateOutputType = {
    client_id: number | null
    auth_user_id: number | null
  }

  export type Client_auth_userCountAggregateOutputType = {
    client_id: number
    auth_user_id: number
    _all: number
  }


  export type Client_auth_userAvgAggregateInputType = {
    client_id?: true
    auth_user_id?: true
  }

  export type Client_auth_userSumAggregateInputType = {
    client_id?: true
    auth_user_id?: true
  }

  export type Client_auth_userMinAggregateInputType = {
    client_id?: true
    auth_user_id?: true
  }

  export type Client_auth_userMaxAggregateInputType = {
    client_id?: true
    auth_user_id?: true
  }

  export type Client_auth_userCountAggregateInputType = {
    client_id?: true
    auth_user_id?: true
    _all?: true
  }

  export type Client_auth_userAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_auth_user to aggregate.
     */
    where?: client_auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_auth_users to fetch.
     */
    orderBy?: client_auth_userOrderByWithRelationInput | client_auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: client_auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned client_auth_users
    **/
    _count?: true | Client_auth_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Client_auth_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Client_auth_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Client_auth_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Client_auth_userMaxAggregateInputType
  }

  export type GetClient_auth_userAggregateType<T extends Client_auth_userAggregateArgs> = {
        [P in keyof T & keyof AggregateClient_auth_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient_auth_user[P]>
      : GetScalarType<T[P], AggregateClient_auth_user[P]>
  }




  export type client_auth_userGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: client_auth_userWhereInput
    orderBy?: client_auth_userOrderByWithAggregationInput | client_auth_userOrderByWithAggregationInput[]
    by: Client_auth_userScalarFieldEnum[] | Client_auth_userScalarFieldEnum
    having?: client_auth_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Client_auth_userCountAggregateInputType | true
    _avg?: Client_auth_userAvgAggregateInputType
    _sum?: Client_auth_userSumAggregateInputType
    _min?: Client_auth_userMinAggregateInputType
    _max?: Client_auth_userMaxAggregateInputType
  }


  export type Client_auth_userGroupByOutputType = {
    client_id: number
    auth_user_id: number
    _count: Client_auth_userCountAggregateOutputType | null
    _avg: Client_auth_userAvgAggregateOutputType | null
    _sum: Client_auth_userSumAggregateOutputType | null
    _min: Client_auth_userMinAggregateOutputType | null
    _max: Client_auth_userMaxAggregateOutputType | null
  }

  type GetClient_auth_userGroupByPayload<T extends client_auth_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Client_auth_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Client_auth_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Client_auth_userGroupByOutputType[P]>
            : GetScalarType<T[P], Client_auth_userGroupByOutputType[P]>
        }
      >
    >


  export type client_auth_userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    client_id?: boolean
    auth_user_id?: boolean
    client?: boolean | clientArgs<ExtArgs>
    auth_user?: boolean | auth_userArgs<ExtArgs>
  }, ExtArgs["result"]["client_auth_user"]>

  export type client_auth_userSelectScalar = {
    client_id?: boolean
    auth_user_id?: boolean
  }

  export type client_auth_userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client?: boolean | clientArgs<ExtArgs>
    auth_user?: boolean | auth_userArgs<ExtArgs>
  }


  type client_auth_userGetPayload<S extends boolean | null | undefined | client_auth_userArgs> = $Types.GetResult<client_auth_userPayload, S>

  type client_auth_userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<client_auth_userFindManyArgs, 'select' | 'include'> & {
      select?: Client_auth_userCountAggregateInputType | true
    }

  export interface client_auth_userDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client_auth_user'], meta: { name: 'client_auth_user' } }
    /**
     * Find zero or one Client_auth_user that matches the filter.
     * @param {client_auth_userFindUniqueArgs} args - Arguments to find a Client_auth_user
     * @example
     * // Get one Client_auth_user
     * const client_auth_user = await prisma.client_auth_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends client_auth_userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, client_auth_userFindUniqueArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client_auth_user that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {client_auth_userFindUniqueOrThrowArgs} args - Arguments to find a Client_auth_user
     * @example
     * // Get one Client_auth_user
     * const client_auth_user = await prisma.client_auth_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends client_auth_userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, client_auth_userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client_auth_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_auth_userFindFirstArgs} args - Arguments to find a Client_auth_user
     * @example
     * // Get one Client_auth_user
     * const client_auth_user = await prisma.client_auth_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends client_auth_userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, client_auth_userFindFirstArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client_auth_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_auth_userFindFirstOrThrowArgs} args - Arguments to find a Client_auth_user
     * @example
     * // Get one Client_auth_user
     * const client_auth_user = await prisma.client_auth_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends client_auth_userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, client_auth_userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Client_auth_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_auth_userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Client_auth_users
     * const client_auth_users = await prisma.client_auth_user.findMany()
     * 
     * // Get first 10 Client_auth_users
     * const client_auth_users = await prisma.client_auth_user.findMany({ take: 10 })
     * 
     * // Only select the `client_id`
     * const client_auth_userWithClient_idOnly = await prisma.client_auth_user.findMany({ select: { client_id: true } })
     * 
    **/
    findMany<T extends client_auth_userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, client_auth_userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client_auth_user.
     * @param {client_auth_userCreateArgs} args - Arguments to create a Client_auth_user.
     * @example
     * // Create one Client_auth_user
     * const Client_auth_user = await prisma.client_auth_user.create({
     *   data: {
     *     // ... data to create a Client_auth_user
     *   }
     * })
     * 
    **/
    create<T extends client_auth_userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, client_auth_userCreateArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Client_auth_users.
     *     @param {client_auth_userCreateManyArgs} args - Arguments to create many Client_auth_users.
     *     @example
     *     // Create many Client_auth_users
     *     const client_auth_user = await prisma.client_auth_user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends client_auth_userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, client_auth_userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client_auth_user.
     * @param {client_auth_userDeleteArgs} args - Arguments to delete one Client_auth_user.
     * @example
     * // Delete one Client_auth_user
     * const Client_auth_user = await prisma.client_auth_user.delete({
     *   where: {
     *     // ... filter to delete one Client_auth_user
     *   }
     * })
     * 
    **/
    delete<T extends client_auth_userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, client_auth_userDeleteArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client_auth_user.
     * @param {client_auth_userUpdateArgs} args - Arguments to update one Client_auth_user.
     * @example
     * // Update one Client_auth_user
     * const client_auth_user = await prisma.client_auth_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends client_auth_userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, client_auth_userUpdateArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Client_auth_users.
     * @param {client_auth_userDeleteManyArgs} args - Arguments to filter Client_auth_users to delete.
     * @example
     * // Delete a few Client_auth_users
     * const { count } = await prisma.client_auth_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends client_auth_userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, client_auth_userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_auth_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Client_auth_users
     * const client_auth_user = await prisma.client_auth_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends client_auth_userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, client_auth_userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client_auth_user.
     * @param {client_auth_userUpsertArgs} args - Arguments to update or create a Client_auth_user.
     * @example
     * // Update or create a Client_auth_user
     * const client_auth_user = await prisma.client_auth_user.upsert({
     *   create: {
     *     // ... data to create a Client_auth_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client_auth_user we want to update
     *   }
     * })
    **/
    upsert<T extends client_auth_userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, client_auth_userUpsertArgs<ExtArgs>>
    ): Prisma__client_auth_userClient<$Types.GetResult<client_auth_userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Client_auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_auth_userCountArgs} args - Arguments to filter Client_auth_users to count.
     * @example
     * // Count the number of Client_auth_users
     * const count = await prisma.client_auth_user.count({
     *   where: {
     *     // ... the filter for the Client_auth_users we want to count
     *   }
     * })
    **/
    count<T extends client_auth_userCountArgs>(
      args?: Subset<T, client_auth_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Client_auth_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client_auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Client_auth_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Client_auth_userAggregateArgs>(args: Subset<T, Client_auth_userAggregateArgs>): Prisma.PrismaPromise<GetClient_auth_userAggregateType<T>>

    /**
     * Group by Client_auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_auth_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends client_auth_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: client_auth_userGroupByArgs['orderBy'] }
        : { orderBy?: client_auth_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, client_auth_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClient_auth_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client_auth_user model
   */
  readonly fields: client_auth_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client_auth_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__client_auth_userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client<T extends clientArgs<ExtArgs> = {}>(args?: Subset<T, clientArgs<ExtArgs>>): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    auth_user<T extends auth_userArgs<ExtArgs> = {}>(args?: Subset<T, auth_userArgs<ExtArgs>>): Prisma__auth_userClient<$Types.GetResult<auth_userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the client_auth_user model
   */ 
  interface client_auth_userFieldRefs {
    readonly client_id: FieldRef<"client_auth_user", 'Int'>
    readonly auth_user_id: FieldRef<"client_auth_user", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * client_auth_user findUnique
   */
  export type client_auth_userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * Filter, which client_auth_user to fetch.
     */
    where: client_auth_userWhereUniqueInput
  }


  /**
   * client_auth_user findUniqueOrThrow
   */
  export type client_auth_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * Filter, which client_auth_user to fetch.
     */
    where: client_auth_userWhereUniqueInput
  }


  /**
   * client_auth_user findFirst
   */
  export type client_auth_userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * Filter, which client_auth_user to fetch.
     */
    where?: client_auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_auth_users to fetch.
     */
    orderBy?: client_auth_userOrderByWithRelationInput | client_auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_auth_users.
     */
    cursor?: client_auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_auth_users.
     */
    distinct?: Client_auth_userScalarFieldEnum | Client_auth_userScalarFieldEnum[]
  }


  /**
   * client_auth_user findFirstOrThrow
   */
  export type client_auth_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * Filter, which client_auth_user to fetch.
     */
    where?: client_auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_auth_users to fetch.
     */
    orderBy?: client_auth_userOrderByWithRelationInput | client_auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_auth_users.
     */
    cursor?: client_auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_auth_users.
     */
    distinct?: Client_auth_userScalarFieldEnum | Client_auth_userScalarFieldEnum[]
  }


  /**
   * client_auth_user findMany
   */
  export type client_auth_userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * Filter, which client_auth_users to fetch.
     */
    where?: client_auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_auth_users to fetch.
     */
    orderBy?: client_auth_userOrderByWithRelationInput | client_auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing client_auth_users.
     */
    cursor?: client_auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_auth_users.
     */
    skip?: number
    distinct?: Client_auth_userScalarFieldEnum | Client_auth_userScalarFieldEnum[]
  }


  /**
   * client_auth_user create
   */
  export type client_auth_userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * The data needed to create a client_auth_user.
     */
    data: XOR<client_auth_userCreateInput, client_auth_userUncheckedCreateInput>
  }


  /**
   * client_auth_user createMany
   */
  export type client_auth_userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many client_auth_users.
     */
    data: client_auth_userCreateManyInput | client_auth_userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * client_auth_user update
   */
  export type client_auth_userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * The data needed to update a client_auth_user.
     */
    data: XOR<client_auth_userUpdateInput, client_auth_userUncheckedUpdateInput>
    /**
     * Choose, which client_auth_user to update.
     */
    where: client_auth_userWhereUniqueInput
  }


  /**
   * client_auth_user updateMany
   */
  export type client_auth_userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update client_auth_users.
     */
    data: XOR<client_auth_userUpdateManyMutationInput, client_auth_userUncheckedUpdateManyInput>
    /**
     * Filter which client_auth_users to update
     */
    where?: client_auth_userWhereInput
  }


  /**
   * client_auth_user upsert
   */
  export type client_auth_userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * The filter to search for the client_auth_user to update in case it exists.
     */
    where: client_auth_userWhereUniqueInput
    /**
     * In case the client_auth_user found by the `where` argument doesn't exist, create a new client_auth_user with this data.
     */
    create: XOR<client_auth_userCreateInput, client_auth_userUncheckedCreateInput>
    /**
     * In case the client_auth_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<client_auth_userUpdateInput, client_auth_userUncheckedUpdateInput>
  }


  /**
   * client_auth_user delete
   */
  export type client_auth_userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
    /**
     * Filter which client_auth_user to delete.
     */
    where: client_auth_userWhereUniqueInput
  }


  /**
   * client_auth_user deleteMany
   */
  export type client_auth_userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_auth_users to delete
     */
    where?: client_auth_userWhereInput
  }


  /**
   * client_auth_user without action
   */
  export type client_auth_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_auth_user
     */
    select?: client_auth_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: client_auth_userInclude<ExtArgs> | null
  }



  /**
   * Model doctrine_migration_versions
   */


  export type AggregateDoctrine_migration_versions = {
    _count: Doctrine_migration_versionsCountAggregateOutputType | null
    _avg: Doctrine_migration_versionsAvgAggregateOutputType | null
    _sum: Doctrine_migration_versionsSumAggregateOutputType | null
    _min: Doctrine_migration_versionsMinAggregateOutputType | null
    _max: Doctrine_migration_versionsMaxAggregateOutputType | null
  }

  export type Doctrine_migration_versionsAvgAggregateOutputType = {
    execution_time: number | null
  }

  export type Doctrine_migration_versionsSumAggregateOutputType = {
    execution_time: number | null
  }

  export type Doctrine_migration_versionsMinAggregateOutputType = {
    version: string | null
    executed_at: Date | null
    execution_time: number | null
  }

  export type Doctrine_migration_versionsMaxAggregateOutputType = {
    version: string | null
    executed_at: Date | null
    execution_time: number | null
  }

  export type Doctrine_migration_versionsCountAggregateOutputType = {
    version: number
    executed_at: number
    execution_time: number
    _all: number
  }


  export type Doctrine_migration_versionsAvgAggregateInputType = {
    execution_time?: true
  }

  export type Doctrine_migration_versionsSumAggregateInputType = {
    execution_time?: true
  }

  export type Doctrine_migration_versionsMinAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
  }

  export type Doctrine_migration_versionsMaxAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
  }

  export type Doctrine_migration_versionsCountAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
    _all?: true
  }

  export type Doctrine_migration_versionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which doctrine_migration_versions to aggregate.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned doctrine_migration_versions
    **/
    _count?: true | Doctrine_migration_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Doctrine_migration_versionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Doctrine_migration_versionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Doctrine_migration_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Doctrine_migration_versionsMaxAggregateInputType
  }

  export type GetDoctrine_migration_versionsAggregateType<T extends Doctrine_migration_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctrine_migration_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctrine_migration_versions[P]>
      : GetScalarType<T[P], AggregateDoctrine_migration_versions[P]>
  }




  export type doctrine_migration_versionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: doctrine_migration_versionsWhereInput
    orderBy?: doctrine_migration_versionsOrderByWithAggregationInput | doctrine_migration_versionsOrderByWithAggregationInput[]
    by: Doctrine_migration_versionsScalarFieldEnum[] | Doctrine_migration_versionsScalarFieldEnum
    having?: doctrine_migration_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Doctrine_migration_versionsCountAggregateInputType | true
    _avg?: Doctrine_migration_versionsAvgAggregateInputType
    _sum?: Doctrine_migration_versionsSumAggregateInputType
    _min?: Doctrine_migration_versionsMinAggregateInputType
    _max?: Doctrine_migration_versionsMaxAggregateInputType
  }


  export type Doctrine_migration_versionsGroupByOutputType = {
    version: string
    executed_at: Date | null
    execution_time: number | null
    _count: Doctrine_migration_versionsCountAggregateOutputType | null
    _avg: Doctrine_migration_versionsAvgAggregateOutputType | null
    _sum: Doctrine_migration_versionsSumAggregateOutputType | null
    _min: Doctrine_migration_versionsMinAggregateOutputType | null
    _max: Doctrine_migration_versionsMaxAggregateOutputType | null
  }

  type GetDoctrine_migration_versionsGroupByPayload<T extends doctrine_migration_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Doctrine_migration_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Doctrine_migration_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Doctrine_migration_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], Doctrine_migration_versionsGroupByOutputType[P]>
        }
      >
    >


  export type doctrine_migration_versionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    executed_at?: boolean
    execution_time?: boolean
  }, ExtArgs["result"]["doctrine_migration_versions"]>

  export type doctrine_migration_versionsSelectScalar = {
    version?: boolean
    executed_at?: boolean
    execution_time?: boolean
  }


  type doctrine_migration_versionsGetPayload<S extends boolean | null | undefined | doctrine_migration_versionsArgs> = $Types.GetResult<doctrine_migration_versionsPayload, S>

  type doctrine_migration_versionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<doctrine_migration_versionsFindManyArgs, 'select' | 'include'> & {
      select?: Doctrine_migration_versionsCountAggregateInputType | true
    }

  export interface doctrine_migration_versionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['doctrine_migration_versions'], meta: { name: 'doctrine_migration_versions' } }
    /**
     * Find zero or one Doctrine_migration_versions that matches the filter.
     * @param {doctrine_migration_versionsFindUniqueArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends doctrine_migration_versionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsFindUniqueArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Doctrine_migration_versions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {doctrine_migration_versionsFindUniqueOrThrowArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Doctrine_migration_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindFirstArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends doctrine_migration_versionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindFirstArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Doctrine_migration_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindFirstOrThrowArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Doctrine_migration_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany()
     * 
     * // Get first 10 Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const doctrine_migration_versionsWithVersionOnly = await prisma.doctrine_migration_versions.findMany({ select: { version: true } })
     * 
    **/
    findMany<T extends doctrine_migration_versionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Doctrine_migration_versions.
     * @param {doctrine_migration_versionsCreateArgs} args - Arguments to create a Doctrine_migration_versions.
     * @example
     * // Create one Doctrine_migration_versions
     * const Doctrine_migration_versions = await prisma.doctrine_migration_versions.create({
     *   data: {
     *     // ... data to create a Doctrine_migration_versions
     *   }
     * })
     * 
    **/
    create<T extends doctrine_migration_versionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsCreateArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Doctrine_migration_versions.
     *     @param {doctrine_migration_versionsCreateManyArgs} args - Arguments to create many Doctrine_migration_versions.
     *     @example
     *     // Create many Doctrine_migration_versions
     *     const doctrine_migration_versions = await prisma.doctrine_migration_versions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends doctrine_migration_versionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Doctrine_migration_versions.
     * @param {doctrine_migration_versionsDeleteArgs} args - Arguments to delete one Doctrine_migration_versions.
     * @example
     * // Delete one Doctrine_migration_versions
     * const Doctrine_migration_versions = await prisma.doctrine_migration_versions.delete({
     *   where: {
     *     // ... filter to delete one Doctrine_migration_versions
     *   }
     * })
     * 
    **/
    delete<T extends doctrine_migration_versionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsDeleteArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Doctrine_migration_versions.
     * @param {doctrine_migration_versionsUpdateArgs} args - Arguments to update one Doctrine_migration_versions.
     * @example
     * // Update one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends doctrine_migration_versionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsUpdateArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Doctrine_migration_versions.
     * @param {doctrine_migration_versionsDeleteManyArgs} args - Arguments to filter Doctrine_migration_versions to delete.
     * @example
     * // Delete a few Doctrine_migration_versions
     * const { count } = await prisma.doctrine_migration_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends doctrine_migration_versionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, doctrine_migration_versionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends doctrine_migration_versionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctrine_migration_versions.
     * @param {doctrine_migration_versionsUpsertArgs} args - Arguments to update or create a Doctrine_migration_versions.
     * @example
     * // Update or create a Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.upsert({
     *   create: {
     *     // ... data to create a Doctrine_migration_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctrine_migration_versions we want to update
     *   }
     * })
    **/
    upsert<T extends doctrine_migration_versionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, doctrine_migration_versionsUpsertArgs<ExtArgs>>
    ): Prisma__doctrine_migration_versionsClient<$Types.GetResult<doctrine_migration_versionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsCountArgs} args - Arguments to filter Doctrine_migration_versions to count.
     * @example
     * // Count the number of Doctrine_migration_versions
     * const count = await prisma.doctrine_migration_versions.count({
     *   where: {
     *     // ... the filter for the Doctrine_migration_versions we want to count
     *   }
     * })
    **/
    count<T extends doctrine_migration_versionsCountArgs>(
      args?: Subset<T, doctrine_migration_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Doctrine_migration_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Doctrine_migration_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Doctrine_migration_versionsAggregateArgs>(args: Subset<T, Doctrine_migration_versionsAggregateArgs>): Prisma.PrismaPromise<GetDoctrine_migration_versionsAggregateType<T>>

    /**
     * Group by Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends doctrine_migration_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: doctrine_migration_versionsGroupByArgs['orderBy'] }
        : { orderBy?: doctrine_migration_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, doctrine_migration_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctrine_migration_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the doctrine_migration_versions model
   */
  readonly fields: doctrine_migration_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for doctrine_migration_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__doctrine_migration_versionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the doctrine_migration_versions model
   */ 
  interface doctrine_migration_versionsFieldRefs {
    readonly version: FieldRef<"doctrine_migration_versions", 'String'>
    readonly executed_at: FieldRef<"doctrine_migration_versions", 'DateTime'>
    readonly execution_time: FieldRef<"doctrine_migration_versions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * doctrine_migration_versions findUnique
   */
  export type doctrine_migration_versionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions findUniqueOrThrow
   */
  export type doctrine_migration_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions findFirst
   */
  export type doctrine_migration_versionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctrine_migration_versions.
     */
    distinct?: Doctrine_migration_versionsScalarFieldEnum | Doctrine_migration_versionsScalarFieldEnum[]
  }


  /**
   * doctrine_migration_versions findFirstOrThrow
   */
  export type doctrine_migration_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctrine_migration_versions.
     */
    distinct?: Doctrine_migration_versionsScalarFieldEnum | Doctrine_migration_versionsScalarFieldEnum[]
  }


  /**
   * doctrine_migration_versions findMany
   */
  export type doctrine_migration_versionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: doctrine_migration_versionsOrderByWithRelationInput | doctrine_migration_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    distinct?: Doctrine_migration_versionsScalarFieldEnum | Doctrine_migration_versionsScalarFieldEnum[]
  }


  /**
   * doctrine_migration_versions create
   */
  export type doctrine_migration_versionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * The data needed to create a doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsCreateInput, doctrine_migration_versionsUncheckedCreateInput>
  }


  /**
   * doctrine_migration_versions createMany
   */
  export type doctrine_migration_versionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many doctrine_migration_versions.
     */
    data: doctrine_migration_versionsCreateManyInput | doctrine_migration_versionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * doctrine_migration_versions update
   */
  export type doctrine_migration_versionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * The data needed to update a doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsUpdateInput, doctrine_migration_versionsUncheckedUpdateInput>
    /**
     * Choose, which doctrine_migration_versions to update.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions updateMany
   */
  export type doctrine_migration_versionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsUpdateManyMutationInput, doctrine_migration_versionsUncheckedUpdateManyInput>
    /**
     * Filter which doctrine_migration_versions to update
     */
    where?: doctrine_migration_versionsWhereInput
  }


  /**
   * doctrine_migration_versions upsert
   */
  export type doctrine_migration_versionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * The filter to search for the doctrine_migration_versions to update in case it exists.
     */
    where: doctrine_migration_versionsWhereUniqueInput
    /**
     * In case the doctrine_migration_versions found by the `where` argument doesn't exist, create a new doctrine_migration_versions with this data.
     */
    create: XOR<doctrine_migration_versionsCreateInput, doctrine_migration_versionsUncheckedCreateInput>
    /**
     * In case the doctrine_migration_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<doctrine_migration_versionsUpdateInput, doctrine_migration_versionsUncheckedUpdateInput>
  }


  /**
   * doctrine_migration_versions delete
   */
  export type doctrine_migration_versionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
    /**
     * Filter which doctrine_migration_versions to delete.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions deleteMany
   */
  export type doctrine_migration_versionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which doctrine_migration_versions to delete
     */
    where?: doctrine_migration_versionsWhereInput
  }


  /**
   * doctrine_migration_versions without action
   */
  export type doctrine_migration_versionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect<ExtArgs> | null
  }



  /**
   * Model file
   */


  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    id: number | null
  }

  export type FileSumAggregateOutputType = {
    id: number | null
  }

  export type FileMinAggregateOutputType = {
    id: number | null
    file: string | null
    upload_at: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: number | null
    file: string | null
    upload_at: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    file: number
    upload_at: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    id?: true
  }

  export type FileSumAggregateInputType = {
    id?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    file?: true
    upload_at?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    file?: true
    upload_at?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    file?: true
    upload_at?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which file to aggregate.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: fileOrderByWithRelationInput | fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type fileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fileWhereInput
    orderBy?: fileOrderByWithAggregationInput | fileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }


  export type FileGroupByOutputType = {
    id: number
    file: string
    upload_at: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type fileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file?: boolean
    upload_at?: boolean
  }, ExtArgs["result"]["file"]>

  export type fileSelectScalar = {
    id?: boolean
    file?: boolean
    upload_at?: boolean
  }


  type fileGetPayload<S extends boolean | null | undefined | fileArgs> = $Types.GetResult<filePayload, S>

  type fileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fileFindManyArgs, 'select' | 'include'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface fileDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['file'], meta: { name: 'file' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {fileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, fileFindUniqueArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one File that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, fileFindFirstArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<filePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a File.
     * @param {fileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
    **/
    create<T extends fileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fileCreateArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Files.
     *     @param {fileCreateManyArgs} args - Arguments to create many Files.
     *     @example
     *     // Create many Files
     *     const file = await prisma.file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File.
     * @param {fileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
    **/
    delete<T extends fileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fileDeleteArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one File.
     * @param {fileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fileUpdateArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {fileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {fileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
    **/
    upsert<T extends fileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fileUpsertArgs<ExtArgs>>
    ): Prisma__fileClient<$Types.GetResult<filePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends fileCountArgs>(
      args?: Subset<T, fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fileGroupByArgs['orderBy'] }
        : { orderBy?: fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the file model
   */
  readonly fields: fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the file model
   */ 
  interface fileFieldRefs {
    readonly id: FieldRef<"file", 'Int'>
    readonly file: FieldRef<"file", 'String'>
    readonly upload_at: FieldRef<"file", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * file findUnique
   */
  export type fileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * Filter, which file to fetch.
     */
    where: fileWhereUniqueInput
  }


  /**
   * file findUniqueOrThrow
   */
  export type fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * Filter, which file to fetch.
     */
    where: fileWhereUniqueInput
  }


  /**
   * file findFirst
   */
  export type fileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * Filter, which file to fetch.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: fileOrderByWithRelationInput | fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }


  /**
   * file findFirstOrThrow
   */
  export type fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * Filter, which file to fetch.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: fileOrderByWithRelationInput | fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }


  /**
   * file findMany
   */
  export type fileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: fileOrderByWithRelationInput | fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files.
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }


  /**
   * file create
   */
  export type fileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * The data needed to create a file.
     */
    data: XOR<fileCreateInput, fileUncheckedCreateInput>
  }


  /**
   * file createMany
   */
  export type fileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many files.
     */
    data: fileCreateManyInput | fileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * file update
   */
  export type fileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * The data needed to update a file.
     */
    data: XOR<fileUpdateInput, fileUncheckedUpdateInput>
    /**
     * Choose, which file to update.
     */
    where: fileWhereUniqueInput
  }


  /**
   * file updateMany
   */
  export type fileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update files.
     */
    data: XOR<fileUpdateManyMutationInput, fileUncheckedUpdateManyInput>
    /**
     * Filter which files to update
     */
    where?: fileWhereInput
  }


  /**
   * file upsert
   */
  export type fileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * The filter to search for the file to update in case it exists.
     */
    where: fileWhereUniqueInput
    /**
     * In case the file found by the `where` argument doesn't exist, create a new file with this data.
     */
    create: XOR<fileCreateInput, fileUncheckedCreateInput>
    /**
     * In case the file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fileUpdateInput, fileUncheckedUpdateInput>
  }


  /**
   * file delete
   */
  export type fileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
    /**
     * Filter which file to delete.
     */
    where: fileWhereUniqueInput
  }


  /**
   * file deleteMany
   */
  export type fileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which files to delete
     */
    where?: fileWhereInput
  }


  /**
   * file without action
   */
  export type fileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect<ExtArgs> | null
  }



  /**
   * Model layout_colors
   */


  export type AggregateLayout_colors = {
    _count: Layout_colorsCountAggregateOutputType | null
    _avg: Layout_colorsAvgAggregateOutputType | null
    _sum: Layout_colorsSumAggregateOutputType | null
    _min: Layout_colorsMinAggregateOutputType | null
    _max: Layout_colorsMaxAggregateOutputType | null
  }

  export type Layout_colorsAvgAggregateOutputType = {
    id: number | null
    settings_id: number | null
  }

  export type Layout_colorsSumAggregateOutputType = {
    id: number | null
    settings_id: number | null
  }

  export type Layout_colorsMinAggregateOutputType = {
    id: number | null
    settings_id: number | null
    name: string | null
    hexadecimal: string | null
  }

  export type Layout_colorsMaxAggregateOutputType = {
    id: number | null
    settings_id: number | null
    name: string | null
    hexadecimal: string | null
  }

  export type Layout_colorsCountAggregateOutputType = {
    id: number
    settings_id: number
    name: number
    hexadecimal: number
    _all: number
  }


  export type Layout_colorsAvgAggregateInputType = {
    id?: true
    settings_id?: true
  }

  export type Layout_colorsSumAggregateInputType = {
    id?: true
    settings_id?: true
  }

  export type Layout_colorsMinAggregateInputType = {
    id?: true
    settings_id?: true
    name?: true
    hexadecimal?: true
  }

  export type Layout_colorsMaxAggregateInputType = {
    id?: true
    settings_id?: true
    name?: true
    hexadecimal?: true
  }

  export type Layout_colorsCountAggregateInputType = {
    id?: true
    settings_id?: true
    name?: true
    hexadecimal?: true
    _all?: true
  }

  export type Layout_colorsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which layout_colors to aggregate.
     */
    where?: layout_colorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of layout_colors to fetch.
     */
    orderBy?: layout_colorsOrderByWithRelationInput | layout_colorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: layout_colorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` layout_colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` layout_colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned layout_colors
    **/
    _count?: true | Layout_colorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Layout_colorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Layout_colorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Layout_colorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Layout_colorsMaxAggregateInputType
  }

  export type GetLayout_colorsAggregateType<T extends Layout_colorsAggregateArgs> = {
        [P in keyof T & keyof AggregateLayout_colors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLayout_colors[P]>
      : GetScalarType<T[P], AggregateLayout_colors[P]>
  }




  export type layout_colorsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: layout_colorsWhereInput
    orderBy?: layout_colorsOrderByWithAggregationInput | layout_colorsOrderByWithAggregationInput[]
    by: Layout_colorsScalarFieldEnum[] | Layout_colorsScalarFieldEnum
    having?: layout_colorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Layout_colorsCountAggregateInputType | true
    _avg?: Layout_colorsAvgAggregateInputType
    _sum?: Layout_colorsSumAggregateInputType
    _min?: Layout_colorsMinAggregateInputType
    _max?: Layout_colorsMaxAggregateInputType
  }


  export type Layout_colorsGroupByOutputType = {
    id: number
    settings_id: number | null
    name: string
    hexadecimal: string
    _count: Layout_colorsCountAggregateOutputType | null
    _avg: Layout_colorsAvgAggregateOutputType | null
    _sum: Layout_colorsSumAggregateOutputType | null
    _min: Layout_colorsMinAggregateOutputType | null
    _max: Layout_colorsMaxAggregateOutputType | null
  }

  type GetLayout_colorsGroupByPayload<T extends layout_colorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Layout_colorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Layout_colorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Layout_colorsGroupByOutputType[P]>
            : GetScalarType<T[P], Layout_colorsGroupByOutputType[P]>
        }
      >
    >


  export type layout_colorsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settings_id?: boolean
    name?: boolean
    hexadecimal?: boolean
    settings?: boolean | layout_colors$settingsArgs<ExtArgs>
  }, ExtArgs["result"]["layout_colors"]>

  export type layout_colorsSelectScalar = {
    id?: boolean
    settings_id?: boolean
    name?: boolean
    hexadecimal?: boolean
  }

  export type layout_colorsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    settings?: boolean | layout_colors$settingsArgs<ExtArgs>
  }


  type layout_colorsGetPayload<S extends boolean | null | undefined | layout_colorsArgs> = $Types.GetResult<layout_colorsPayload, S>

  type layout_colorsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<layout_colorsFindManyArgs, 'select' | 'include'> & {
      select?: Layout_colorsCountAggregateInputType | true
    }

  export interface layout_colorsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['layout_colors'], meta: { name: 'layout_colors' } }
    /**
     * Find zero or one Layout_colors that matches the filter.
     * @param {layout_colorsFindUniqueArgs} args - Arguments to find a Layout_colors
     * @example
     * // Get one Layout_colors
     * const layout_colors = await prisma.layout_colors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends layout_colorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, layout_colorsFindUniqueArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Layout_colors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {layout_colorsFindUniqueOrThrowArgs} args - Arguments to find a Layout_colors
     * @example
     * // Get one Layout_colors
     * const layout_colors = await prisma.layout_colors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends layout_colorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, layout_colorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Layout_colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layout_colorsFindFirstArgs} args - Arguments to find a Layout_colors
     * @example
     * // Get one Layout_colors
     * const layout_colors = await prisma.layout_colors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends layout_colorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, layout_colorsFindFirstArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Layout_colors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layout_colorsFindFirstOrThrowArgs} args - Arguments to find a Layout_colors
     * @example
     * // Get one Layout_colors
     * const layout_colors = await prisma.layout_colors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends layout_colorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, layout_colorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Layout_colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layout_colorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Layout_colors
     * const layout_colors = await prisma.layout_colors.findMany()
     * 
     * // Get first 10 Layout_colors
     * const layout_colors = await prisma.layout_colors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const layout_colorsWithIdOnly = await prisma.layout_colors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends layout_colorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, layout_colorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Layout_colors.
     * @param {layout_colorsCreateArgs} args - Arguments to create a Layout_colors.
     * @example
     * // Create one Layout_colors
     * const Layout_colors = await prisma.layout_colors.create({
     *   data: {
     *     // ... data to create a Layout_colors
     *   }
     * })
     * 
    **/
    create<T extends layout_colorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, layout_colorsCreateArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Layout_colors.
     *     @param {layout_colorsCreateManyArgs} args - Arguments to create many Layout_colors.
     *     @example
     *     // Create many Layout_colors
     *     const layout_colors = await prisma.layout_colors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends layout_colorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, layout_colorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Layout_colors.
     * @param {layout_colorsDeleteArgs} args - Arguments to delete one Layout_colors.
     * @example
     * // Delete one Layout_colors
     * const Layout_colors = await prisma.layout_colors.delete({
     *   where: {
     *     // ... filter to delete one Layout_colors
     *   }
     * })
     * 
    **/
    delete<T extends layout_colorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, layout_colorsDeleteArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Layout_colors.
     * @param {layout_colorsUpdateArgs} args - Arguments to update one Layout_colors.
     * @example
     * // Update one Layout_colors
     * const layout_colors = await prisma.layout_colors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends layout_colorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, layout_colorsUpdateArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Layout_colors.
     * @param {layout_colorsDeleteManyArgs} args - Arguments to filter Layout_colors to delete.
     * @example
     * // Delete a few Layout_colors
     * const { count } = await prisma.layout_colors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends layout_colorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, layout_colorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Layout_colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layout_colorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Layout_colors
     * const layout_colors = await prisma.layout_colors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends layout_colorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, layout_colorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Layout_colors.
     * @param {layout_colorsUpsertArgs} args - Arguments to update or create a Layout_colors.
     * @example
     * // Update or create a Layout_colors
     * const layout_colors = await prisma.layout_colors.upsert({
     *   create: {
     *     // ... data to create a Layout_colors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Layout_colors we want to update
     *   }
     * })
    **/
    upsert<T extends layout_colorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, layout_colorsUpsertArgs<ExtArgs>>
    ): Prisma__layout_colorsClient<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Layout_colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layout_colorsCountArgs} args - Arguments to filter Layout_colors to count.
     * @example
     * // Count the number of Layout_colors
     * const count = await prisma.layout_colors.count({
     *   where: {
     *     // ... the filter for the Layout_colors we want to count
     *   }
     * })
    **/
    count<T extends layout_colorsCountArgs>(
      args?: Subset<T, layout_colorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Layout_colorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Layout_colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Layout_colorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Layout_colorsAggregateArgs>(args: Subset<T, Layout_colorsAggregateArgs>): Prisma.PrismaPromise<GetLayout_colorsAggregateType<T>>

    /**
     * Group by Layout_colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layout_colorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends layout_colorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: layout_colorsGroupByArgs['orderBy'] }
        : { orderBy?: layout_colorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, layout_colorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLayout_colorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the layout_colors model
   */
  readonly fields: layout_colorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for layout_colors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__layout_colorsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    settings<T extends layout_colors$settingsArgs<ExtArgs> = {}>(args?: Subset<T, layout_colors$settingsArgs<ExtArgs>>): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the layout_colors model
   */ 
  interface layout_colorsFieldRefs {
    readonly id: FieldRef<"layout_colors", 'Int'>
    readonly settings_id: FieldRef<"layout_colors", 'Int'>
    readonly name: FieldRef<"layout_colors", 'String'>
    readonly hexadecimal: FieldRef<"layout_colors", 'String'>
  }
    

  // Custom InputTypes

  /**
   * layout_colors findUnique
   */
  export type layout_colorsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * Filter, which layout_colors to fetch.
     */
    where: layout_colorsWhereUniqueInput
  }


  /**
   * layout_colors findUniqueOrThrow
   */
  export type layout_colorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * Filter, which layout_colors to fetch.
     */
    where: layout_colorsWhereUniqueInput
  }


  /**
   * layout_colors findFirst
   */
  export type layout_colorsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * Filter, which layout_colors to fetch.
     */
    where?: layout_colorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of layout_colors to fetch.
     */
    orderBy?: layout_colorsOrderByWithRelationInput | layout_colorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for layout_colors.
     */
    cursor?: layout_colorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` layout_colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` layout_colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of layout_colors.
     */
    distinct?: Layout_colorsScalarFieldEnum | Layout_colorsScalarFieldEnum[]
  }


  /**
   * layout_colors findFirstOrThrow
   */
  export type layout_colorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * Filter, which layout_colors to fetch.
     */
    where?: layout_colorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of layout_colors to fetch.
     */
    orderBy?: layout_colorsOrderByWithRelationInput | layout_colorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for layout_colors.
     */
    cursor?: layout_colorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` layout_colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` layout_colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of layout_colors.
     */
    distinct?: Layout_colorsScalarFieldEnum | Layout_colorsScalarFieldEnum[]
  }


  /**
   * layout_colors findMany
   */
  export type layout_colorsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * Filter, which layout_colors to fetch.
     */
    where?: layout_colorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of layout_colors to fetch.
     */
    orderBy?: layout_colorsOrderByWithRelationInput | layout_colorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing layout_colors.
     */
    cursor?: layout_colorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` layout_colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` layout_colors.
     */
    skip?: number
    distinct?: Layout_colorsScalarFieldEnum | Layout_colorsScalarFieldEnum[]
  }


  /**
   * layout_colors create
   */
  export type layout_colorsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * The data needed to create a layout_colors.
     */
    data: XOR<layout_colorsCreateInput, layout_colorsUncheckedCreateInput>
  }


  /**
   * layout_colors createMany
   */
  export type layout_colorsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many layout_colors.
     */
    data: layout_colorsCreateManyInput | layout_colorsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * layout_colors update
   */
  export type layout_colorsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * The data needed to update a layout_colors.
     */
    data: XOR<layout_colorsUpdateInput, layout_colorsUncheckedUpdateInput>
    /**
     * Choose, which layout_colors to update.
     */
    where: layout_colorsWhereUniqueInput
  }


  /**
   * layout_colors updateMany
   */
  export type layout_colorsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update layout_colors.
     */
    data: XOR<layout_colorsUpdateManyMutationInput, layout_colorsUncheckedUpdateManyInput>
    /**
     * Filter which layout_colors to update
     */
    where?: layout_colorsWhereInput
  }


  /**
   * layout_colors upsert
   */
  export type layout_colorsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * The filter to search for the layout_colors to update in case it exists.
     */
    where: layout_colorsWhereUniqueInput
    /**
     * In case the layout_colors found by the `where` argument doesn't exist, create a new layout_colors with this data.
     */
    create: XOR<layout_colorsCreateInput, layout_colorsUncheckedCreateInput>
    /**
     * In case the layout_colors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<layout_colorsUpdateInput, layout_colorsUncheckedUpdateInput>
  }


  /**
   * layout_colors delete
   */
  export type layout_colorsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    /**
     * Filter which layout_colors to delete.
     */
    where: layout_colorsWhereUniqueInput
  }


  /**
   * layout_colors deleteMany
   */
  export type layout_colorsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which layout_colors to delete
     */
    where?: layout_colorsWhereInput
  }


  /**
   * layout_colors.settings
   */
  export type layout_colors$settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    where?: settingsWhereInput
  }


  /**
   * layout_colors without action
   */
  export type layout_colorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
  }



  /**
   * Model live_casino_most_popular
   */


  export type AggregateLive_casino_most_popular = {
    _count: Live_casino_most_popularCountAggregateOutputType | null
    _avg: Live_casino_most_popularAvgAggregateOutputType | null
    _sum: Live_casino_most_popularSumAggregateOutputType | null
    _min: Live_casino_most_popularMinAggregateOutputType | null
    _max: Live_casino_most_popularMaxAggregateOutputType | null
  }

  export type Live_casino_most_popularAvgAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Live_casino_most_popularSumAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Live_casino_most_popularMinAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Live_casino_most_popularMaxAggregateOutputType = {
    id: number | null
    qty_lines: number | null
    qty_columns: number | null
  }

  export type Live_casino_most_popularCountAggregateOutputType = {
    id: number
    qty_lines: number
    qty_columns: number
    _all: number
  }


  export type Live_casino_most_popularAvgAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Live_casino_most_popularSumAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Live_casino_most_popularMinAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Live_casino_most_popularMaxAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
  }

  export type Live_casino_most_popularCountAggregateInputType = {
    id?: true
    qty_lines?: true
    qty_columns?: true
    _all?: true
  }

  export type Live_casino_most_popularAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which live_casino_most_popular to aggregate.
     */
    where?: live_casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_populars to fetch.
     */
    orderBy?: live_casino_most_popularOrderByWithRelationInput | live_casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: live_casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_populars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned live_casino_most_populars
    **/
    _count?: true | Live_casino_most_popularCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Live_casino_most_popularAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Live_casino_most_popularSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Live_casino_most_popularMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Live_casino_most_popularMaxAggregateInputType
  }

  export type GetLive_casino_most_popularAggregateType<T extends Live_casino_most_popularAggregateArgs> = {
        [P in keyof T & keyof AggregateLive_casino_most_popular]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLive_casino_most_popular[P]>
      : GetScalarType<T[P], AggregateLive_casino_most_popular[P]>
  }




  export type live_casino_most_popularGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: live_casino_most_popularWhereInput
    orderBy?: live_casino_most_popularOrderByWithAggregationInput | live_casino_most_popularOrderByWithAggregationInput[]
    by: Live_casino_most_popularScalarFieldEnum[] | Live_casino_most_popularScalarFieldEnum
    having?: live_casino_most_popularScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Live_casino_most_popularCountAggregateInputType | true
    _avg?: Live_casino_most_popularAvgAggregateInputType
    _sum?: Live_casino_most_popularSumAggregateInputType
    _min?: Live_casino_most_popularMinAggregateInputType
    _max?: Live_casino_most_popularMaxAggregateInputType
  }


  export type Live_casino_most_popularGroupByOutputType = {
    id: number
    qty_lines: number
    qty_columns: number
    _count: Live_casino_most_popularCountAggregateOutputType | null
    _avg: Live_casino_most_popularAvgAggregateOutputType | null
    _sum: Live_casino_most_popularSumAggregateOutputType | null
    _min: Live_casino_most_popularMinAggregateOutputType | null
    _max: Live_casino_most_popularMaxAggregateOutputType | null
  }

  type GetLive_casino_most_popularGroupByPayload<T extends live_casino_most_popularGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Live_casino_most_popularGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Live_casino_most_popularGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Live_casino_most_popularGroupByOutputType[P]>
            : GetScalarType<T[P], Live_casino_most_popularGroupByOutputType[P]>
        }
      >
    >


  export type live_casino_most_popularSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qty_lines?: boolean
    qty_columns?: boolean
    live_casino_most_popular_slot_games?: boolean | live_casino_most_popular$live_casino_most_popular_slot_gamesArgs<ExtArgs>
    slot_settings?: boolean | live_casino_most_popular$slot_settingsArgs<ExtArgs>
    _count?: boolean | Live_casino_most_popularCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["live_casino_most_popular"]>

  export type live_casino_most_popularSelectScalar = {
    id?: boolean
    qty_lines?: boolean
    qty_columns?: boolean
  }

  export type live_casino_most_popularInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    live_casino_most_popular_slot_games?: boolean | live_casino_most_popular$live_casino_most_popular_slot_gamesArgs<ExtArgs>
    slot_settings?: boolean | live_casino_most_popular$slot_settingsArgs<ExtArgs>
    _count?: boolean | Live_casino_most_popularCountOutputTypeArgs<ExtArgs>
  }


  type live_casino_most_popularGetPayload<S extends boolean | null | undefined | live_casino_most_popularArgs> = $Types.GetResult<live_casino_most_popularPayload, S>

  type live_casino_most_popularCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<live_casino_most_popularFindManyArgs, 'select' | 'include'> & {
      select?: Live_casino_most_popularCountAggregateInputType | true
    }

  export interface live_casino_most_popularDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['live_casino_most_popular'], meta: { name: 'live_casino_most_popular' } }
    /**
     * Find zero or one Live_casino_most_popular that matches the filter.
     * @param {live_casino_most_popularFindUniqueArgs} args - Arguments to find a Live_casino_most_popular
     * @example
     * // Get one Live_casino_most_popular
     * const live_casino_most_popular = await prisma.live_casino_most_popular.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends live_casino_most_popularFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popularFindUniqueArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Live_casino_most_popular that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {live_casino_most_popularFindUniqueOrThrowArgs} args - Arguments to find a Live_casino_most_popular
     * @example
     * // Get one Live_casino_most_popular
     * const live_casino_most_popular = await prisma.live_casino_most_popular.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends live_casino_most_popularFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popularFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Live_casino_most_popular that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popularFindFirstArgs} args - Arguments to find a Live_casino_most_popular
     * @example
     * // Get one Live_casino_most_popular
     * const live_casino_most_popular = await prisma.live_casino_most_popular.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends live_casino_most_popularFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popularFindFirstArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Live_casino_most_popular that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popularFindFirstOrThrowArgs} args - Arguments to find a Live_casino_most_popular
     * @example
     * // Get one Live_casino_most_popular
     * const live_casino_most_popular = await prisma.live_casino_most_popular.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends live_casino_most_popularFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popularFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Live_casino_most_populars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popularFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Live_casino_most_populars
     * const live_casino_most_populars = await prisma.live_casino_most_popular.findMany()
     * 
     * // Get first 10 Live_casino_most_populars
     * const live_casino_most_populars = await prisma.live_casino_most_popular.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const live_casino_most_popularWithIdOnly = await prisma.live_casino_most_popular.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends live_casino_most_popularFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popularFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Live_casino_most_popular.
     * @param {live_casino_most_popularCreateArgs} args - Arguments to create a Live_casino_most_popular.
     * @example
     * // Create one Live_casino_most_popular
     * const Live_casino_most_popular = await prisma.live_casino_most_popular.create({
     *   data: {
     *     // ... data to create a Live_casino_most_popular
     *   }
     * })
     * 
    **/
    create<T extends live_casino_most_popularCreateArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popularCreateArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Live_casino_most_populars.
     *     @param {live_casino_most_popularCreateManyArgs} args - Arguments to create many Live_casino_most_populars.
     *     @example
     *     // Create many Live_casino_most_populars
     *     const live_casino_most_popular = await prisma.live_casino_most_popular.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends live_casino_most_popularCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popularCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Live_casino_most_popular.
     * @param {live_casino_most_popularDeleteArgs} args - Arguments to delete one Live_casino_most_popular.
     * @example
     * // Delete one Live_casino_most_popular
     * const Live_casino_most_popular = await prisma.live_casino_most_popular.delete({
     *   where: {
     *     // ... filter to delete one Live_casino_most_popular
     *   }
     * })
     * 
    **/
    delete<T extends live_casino_most_popularDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popularDeleteArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Live_casino_most_popular.
     * @param {live_casino_most_popularUpdateArgs} args - Arguments to update one Live_casino_most_popular.
     * @example
     * // Update one Live_casino_most_popular
     * const live_casino_most_popular = await prisma.live_casino_most_popular.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends live_casino_most_popularUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popularUpdateArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Live_casino_most_populars.
     * @param {live_casino_most_popularDeleteManyArgs} args - Arguments to filter Live_casino_most_populars to delete.
     * @example
     * // Delete a few Live_casino_most_populars
     * const { count } = await prisma.live_casino_most_popular.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends live_casino_most_popularDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popularDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Live_casino_most_populars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popularUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Live_casino_most_populars
     * const live_casino_most_popular = await prisma.live_casino_most_popular.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends live_casino_most_popularUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popularUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Live_casino_most_popular.
     * @param {live_casino_most_popularUpsertArgs} args - Arguments to update or create a Live_casino_most_popular.
     * @example
     * // Update or create a Live_casino_most_popular
     * const live_casino_most_popular = await prisma.live_casino_most_popular.upsert({
     *   create: {
     *     // ... data to create a Live_casino_most_popular
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Live_casino_most_popular we want to update
     *   }
     * })
    **/
    upsert<T extends live_casino_most_popularUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popularUpsertArgs<ExtArgs>>
    ): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Live_casino_most_populars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popularCountArgs} args - Arguments to filter Live_casino_most_populars to count.
     * @example
     * // Count the number of Live_casino_most_populars
     * const count = await prisma.live_casino_most_popular.count({
     *   where: {
     *     // ... the filter for the Live_casino_most_populars we want to count
     *   }
     * })
    **/
    count<T extends live_casino_most_popularCountArgs>(
      args?: Subset<T, live_casino_most_popularCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Live_casino_most_popularCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Live_casino_most_popular.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Live_casino_most_popularAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Live_casino_most_popularAggregateArgs>(args: Subset<T, Live_casino_most_popularAggregateArgs>): Prisma.PrismaPromise<GetLive_casino_most_popularAggregateType<T>>

    /**
     * Group by Live_casino_most_popular.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popularGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends live_casino_most_popularGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: live_casino_most_popularGroupByArgs['orderBy'] }
        : { orderBy?: live_casino_most_popularGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, live_casino_most_popularGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLive_casino_most_popularGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the live_casino_most_popular model
   */
  readonly fields: live_casino_most_popularFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for live_casino_most_popular.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__live_casino_most_popularClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    live_casino_most_popular_slot_games<T extends live_casino_most_popular$live_casino_most_popular_slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, live_casino_most_popular$live_casino_most_popular_slot_gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findMany'>| Null>;

    slot_settings<T extends live_casino_most_popular$slot_settingsArgs<ExtArgs> = {}>(args?: Subset<T, live_casino_most_popular$slot_settingsArgs<ExtArgs>>): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the live_casino_most_popular model
   */ 
  interface live_casino_most_popularFieldRefs {
    readonly id: FieldRef<"live_casino_most_popular", 'Int'>
    readonly qty_lines: FieldRef<"live_casino_most_popular", 'Int'>
    readonly qty_columns: FieldRef<"live_casino_most_popular", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * live_casino_most_popular findUnique
   */
  export type live_casino_most_popularFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular to fetch.
     */
    where: live_casino_most_popularWhereUniqueInput
  }


  /**
   * live_casino_most_popular findUniqueOrThrow
   */
  export type live_casino_most_popularFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular to fetch.
     */
    where: live_casino_most_popularWhereUniqueInput
  }


  /**
   * live_casino_most_popular findFirst
   */
  export type live_casino_most_popularFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular to fetch.
     */
    where?: live_casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_populars to fetch.
     */
    orderBy?: live_casino_most_popularOrderByWithRelationInput | live_casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for live_casino_most_populars.
     */
    cursor?: live_casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_populars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of live_casino_most_populars.
     */
    distinct?: Live_casino_most_popularScalarFieldEnum | Live_casino_most_popularScalarFieldEnum[]
  }


  /**
   * live_casino_most_popular findFirstOrThrow
   */
  export type live_casino_most_popularFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular to fetch.
     */
    where?: live_casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_populars to fetch.
     */
    orderBy?: live_casino_most_popularOrderByWithRelationInput | live_casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for live_casino_most_populars.
     */
    cursor?: live_casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_populars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of live_casino_most_populars.
     */
    distinct?: Live_casino_most_popularScalarFieldEnum | Live_casino_most_popularScalarFieldEnum[]
  }


  /**
   * live_casino_most_popular findMany
   */
  export type live_casino_most_popularFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_populars to fetch.
     */
    where?: live_casino_most_popularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_populars to fetch.
     */
    orderBy?: live_casino_most_popularOrderByWithRelationInput | live_casino_most_popularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing live_casino_most_populars.
     */
    cursor?: live_casino_most_popularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_populars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_populars.
     */
    skip?: number
    distinct?: Live_casino_most_popularScalarFieldEnum | Live_casino_most_popularScalarFieldEnum[]
  }


  /**
   * live_casino_most_popular create
   */
  export type live_casino_most_popularCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * The data needed to create a live_casino_most_popular.
     */
    data: XOR<live_casino_most_popularCreateInput, live_casino_most_popularUncheckedCreateInput>
  }


  /**
   * live_casino_most_popular createMany
   */
  export type live_casino_most_popularCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many live_casino_most_populars.
     */
    data: live_casino_most_popularCreateManyInput | live_casino_most_popularCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * live_casino_most_popular update
   */
  export type live_casino_most_popularUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * The data needed to update a live_casino_most_popular.
     */
    data: XOR<live_casino_most_popularUpdateInput, live_casino_most_popularUncheckedUpdateInput>
    /**
     * Choose, which live_casino_most_popular to update.
     */
    where: live_casino_most_popularWhereUniqueInput
  }


  /**
   * live_casino_most_popular updateMany
   */
  export type live_casino_most_popularUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update live_casino_most_populars.
     */
    data: XOR<live_casino_most_popularUpdateManyMutationInput, live_casino_most_popularUncheckedUpdateManyInput>
    /**
     * Filter which live_casino_most_populars to update
     */
    where?: live_casino_most_popularWhereInput
  }


  /**
   * live_casino_most_popular upsert
   */
  export type live_casino_most_popularUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * The filter to search for the live_casino_most_popular to update in case it exists.
     */
    where: live_casino_most_popularWhereUniqueInput
    /**
     * In case the live_casino_most_popular found by the `where` argument doesn't exist, create a new live_casino_most_popular with this data.
     */
    create: XOR<live_casino_most_popularCreateInput, live_casino_most_popularUncheckedCreateInput>
    /**
     * In case the live_casino_most_popular was found with the provided `where` argument, update it with this data.
     */
    update: XOR<live_casino_most_popularUpdateInput, live_casino_most_popularUncheckedUpdateInput>
  }


  /**
   * live_casino_most_popular delete
   */
  export type live_casino_most_popularDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    /**
     * Filter which live_casino_most_popular to delete.
     */
    where: live_casino_most_popularWhereUniqueInput
  }


  /**
   * live_casino_most_popular deleteMany
   */
  export type live_casino_most_popularDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which live_casino_most_populars to delete
     */
    where?: live_casino_most_popularWhereInput
  }


  /**
   * live_casino_most_popular.live_casino_most_popular_slot_games
   */
  export type live_casino_most_popular$live_casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    where?: live_casino_most_popular_slot_gamesWhereInput
    orderBy?: live_casino_most_popular_slot_gamesOrderByWithRelationInput | live_casino_most_popular_slot_gamesOrderByWithRelationInput[]
    cursor?: live_casino_most_popular_slot_gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Live_casino_most_popular_slot_gamesScalarFieldEnum | Live_casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * live_casino_most_popular.slot_settings
   */
  export type live_casino_most_popular$slot_settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    where?: slot_settingsWhereInput
  }


  /**
   * live_casino_most_popular without action
   */
  export type live_casino_most_popularArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
  }



  /**
   * Model live_casino_most_popular_slot_games
   */


  export type AggregateLive_casino_most_popular_slot_games = {
    _count: Live_casino_most_popular_slot_gamesCountAggregateOutputType | null
    _avg: Live_casino_most_popular_slot_gamesAvgAggregateOutputType | null
    _sum: Live_casino_most_popular_slot_gamesSumAggregateOutputType | null
    _min: Live_casino_most_popular_slot_gamesMinAggregateOutputType | null
    _max: Live_casino_most_popular_slot_gamesMaxAggregateOutputType | null
  }

  export type Live_casino_most_popular_slot_gamesAvgAggregateOutputType = {
    live_casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Live_casino_most_popular_slot_gamesSumAggregateOutputType = {
    live_casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Live_casino_most_popular_slot_gamesMinAggregateOutputType = {
    live_casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Live_casino_most_popular_slot_gamesMaxAggregateOutputType = {
    live_casino_most_popular_id: number | null
    slot_games_id: number | null
  }

  export type Live_casino_most_popular_slot_gamesCountAggregateOutputType = {
    live_casino_most_popular_id: number
    slot_games_id: number
    _all: number
  }


  export type Live_casino_most_popular_slot_gamesAvgAggregateInputType = {
    live_casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Live_casino_most_popular_slot_gamesSumAggregateInputType = {
    live_casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Live_casino_most_popular_slot_gamesMinAggregateInputType = {
    live_casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Live_casino_most_popular_slot_gamesMaxAggregateInputType = {
    live_casino_most_popular_id?: true
    slot_games_id?: true
  }

  export type Live_casino_most_popular_slot_gamesCountAggregateInputType = {
    live_casino_most_popular_id?: true
    slot_games_id?: true
    _all?: true
  }

  export type Live_casino_most_popular_slot_gamesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which live_casino_most_popular_slot_games to aggregate.
     */
    where?: live_casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_popular_slot_games to fetch.
     */
    orderBy?: live_casino_most_popular_slot_gamesOrderByWithRelationInput | live_casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: live_casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_popular_slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned live_casino_most_popular_slot_games
    **/
    _count?: true | Live_casino_most_popular_slot_gamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Live_casino_most_popular_slot_gamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Live_casino_most_popular_slot_gamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Live_casino_most_popular_slot_gamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Live_casino_most_popular_slot_gamesMaxAggregateInputType
  }

  export type GetLive_casino_most_popular_slot_gamesAggregateType<T extends Live_casino_most_popular_slot_gamesAggregateArgs> = {
        [P in keyof T & keyof AggregateLive_casino_most_popular_slot_games]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLive_casino_most_popular_slot_games[P]>
      : GetScalarType<T[P], AggregateLive_casino_most_popular_slot_games[P]>
  }




  export type live_casino_most_popular_slot_gamesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: live_casino_most_popular_slot_gamesWhereInput
    orderBy?: live_casino_most_popular_slot_gamesOrderByWithAggregationInput | live_casino_most_popular_slot_gamesOrderByWithAggregationInput[]
    by: Live_casino_most_popular_slot_gamesScalarFieldEnum[] | Live_casino_most_popular_slot_gamesScalarFieldEnum
    having?: live_casino_most_popular_slot_gamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Live_casino_most_popular_slot_gamesCountAggregateInputType | true
    _avg?: Live_casino_most_popular_slot_gamesAvgAggregateInputType
    _sum?: Live_casino_most_popular_slot_gamesSumAggregateInputType
    _min?: Live_casino_most_popular_slot_gamesMinAggregateInputType
    _max?: Live_casino_most_popular_slot_gamesMaxAggregateInputType
  }


  export type Live_casino_most_popular_slot_gamesGroupByOutputType = {
    live_casino_most_popular_id: number
    slot_games_id: number
    _count: Live_casino_most_popular_slot_gamesCountAggregateOutputType | null
    _avg: Live_casino_most_popular_slot_gamesAvgAggregateOutputType | null
    _sum: Live_casino_most_popular_slot_gamesSumAggregateOutputType | null
    _min: Live_casino_most_popular_slot_gamesMinAggregateOutputType | null
    _max: Live_casino_most_popular_slot_gamesMaxAggregateOutputType | null
  }

  type GetLive_casino_most_popular_slot_gamesGroupByPayload<T extends live_casino_most_popular_slot_gamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Live_casino_most_popular_slot_gamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Live_casino_most_popular_slot_gamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Live_casino_most_popular_slot_gamesGroupByOutputType[P]>
            : GetScalarType<T[P], Live_casino_most_popular_slot_gamesGroupByOutputType[P]>
        }
      >
    >


  export type live_casino_most_popular_slot_gamesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    live_casino_most_popular_id?: boolean
    slot_games_id?: boolean
    live_casino_most_popular?: boolean | live_casino_most_popularArgs<ExtArgs>
    slot_games?: boolean | slot_gamesArgs<ExtArgs>
  }, ExtArgs["result"]["live_casino_most_popular_slot_games"]>

  export type live_casino_most_popular_slot_gamesSelectScalar = {
    live_casino_most_popular_id?: boolean
    slot_games_id?: boolean
  }

  export type live_casino_most_popular_slot_gamesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    live_casino_most_popular?: boolean | live_casino_most_popularArgs<ExtArgs>
    slot_games?: boolean | slot_gamesArgs<ExtArgs>
  }


  type live_casino_most_popular_slot_gamesGetPayload<S extends boolean | null | undefined | live_casino_most_popular_slot_gamesArgs> = $Types.GetResult<live_casino_most_popular_slot_gamesPayload, S>

  type live_casino_most_popular_slot_gamesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<live_casino_most_popular_slot_gamesFindManyArgs, 'select' | 'include'> & {
      select?: Live_casino_most_popular_slot_gamesCountAggregateInputType | true
    }

  export interface live_casino_most_popular_slot_gamesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['live_casino_most_popular_slot_games'], meta: { name: 'live_casino_most_popular_slot_games' } }
    /**
     * Find zero or one Live_casino_most_popular_slot_games that matches the filter.
     * @param {live_casino_most_popular_slot_gamesFindUniqueArgs} args - Arguments to find a Live_casino_most_popular_slot_games
     * @example
     * // Get one Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends live_casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Live_casino_most_popular_slot_games that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {live_casino_most_popular_slot_gamesFindUniqueOrThrowArgs} args - Arguments to find a Live_casino_most_popular_slot_games
     * @example
     * // Get one Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends live_casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Live_casino_most_popular_slot_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popular_slot_gamesFindFirstArgs} args - Arguments to find a Live_casino_most_popular_slot_games
     * @example
     * // Get one Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends live_casino_most_popular_slot_gamesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popular_slot_gamesFindFirstArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Live_casino_most_popular_slot_games that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popular_slot_gamesFindFirstOrThrowArgs} args - Arguments to find a Live_casino_most_popular_slot_games
     * @example
     * // Get one Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends live_casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Live_casino_most_popular_slot_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popular_slot_gamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.findMany()
     * 
     * // Get first 10 Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.findMany({ take: 10 })
     * 
     * // Only select the `live_casino_most_popular_id`
     * const live_casino_most_popular_slot_gamesWithLive_casino_most_popular_idOnly = await prisma.live_casino_most_popular_slot_games.findMany({ select: { live_casino_most_popular_id: true } })
     * 
    **/
    findMany<T extends live_casino_most_popular_slot_gamesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popular_slot_gamesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Live_casino_most_popular_slot_games.
     * @param {live_casino_most_popular_slot_gamesCreateArgs} args - Arguments to create a Live_casino_most_popular_slot_games.
     * @example
     * // Create one Live_casino_most_popular_slot_games
     * const Live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.create({
     *   data: {
     *     // ... data to create a Live_casino_most_popular_slot_games
     *   }
     * })
     * 
    **/
    create<T extends live_casino_most_popular_slot_gamesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popular_slot_gamesCreateArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Live_casino_most_popular_slot_games.
     *     @param {live_casino_most_popular_slot_gamesCreateManyArgs} args - Arguments to create many Live_casino_most_popular_slot_games.
     *     @example
     *     // Create many Live_casino_most_popular_slot_games
     *     const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends live_casino_most_popular_slot_gamesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popular_slot_gamesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Live_casino_most_popular_slot_games.
     * @param {live_casino_most_popular_slot_gamesDeleteArgs} args - Arguments to delete one Live_casino_most_popular_slot_games.
     * @example
     * // Delete one Live_casino_most_popular_slot_games
     * const Live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.delete({
     *   where: {
     *     // ... filter to delete one Live_casino_most_popular_slot_games
     *   }
     * })
     * 
    **/
    delete<T extends live_casino_most_popular_slot_gamesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popular_slot_gamesDeleteArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Live_casino_most_popular_slot_games.
     * @param {live_casino_most_popular_slot_gamesUpdateArgs} args - Arguments to update one Live_casino_most_popular_slot_games.
     * @example
     * // Update one Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends live_casino_most_popular_slot_gamesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popular_slot_gamesUpdateArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Live_casino_most_popular_slot_games.
     * @param {live_casino_most_popular_slot_gamesDeleteManyArgs} args - Arguments to filter Live_casino_most_popular_slot_games to delete.
     * @example
     * // Delete a few Live_casino_most_popular_slot_games
     * const { count } = await prisma.live_casino_most_popular_slot_games.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends live_casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, live_casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Live_casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popular_slot_gamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends live_casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Live_casino_most_popular_slot_games.
     * @param {live_casino_most_popular_slot_gamesUpsertArgs} args - Arguments to update or create a Live_casino_most_popular_slot_games.
     * @example
     * // Update or create a Live_casino_most_popular_slot_games
     * const live_casino_most_popular_slot_games = await prisma.live_casino_most_popular_slot_games.upsert({
     *   create: {
     *     // ... data to create a Live_casino_most_popular_slot_games
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Live_casino_most_popular_slot_games we want to update
     *   }
     * })
    **/
    upsert<T extends live_casino_most_popular_slot_gamesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, live_casino_most_popular_slot_gamesUpsertArgs<ExtArgs>>
    ): Prisma__live_casino_most_popular_slot_gamesClient<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Live_casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popular_slot_gamesCountArgs} args - Arguments to filter Live_casino_most_popular_slot_games to count.
     * @example
     * // Count the number of Live_casino_most_popular_slot_games
     * const count = await prisma.live_casino_most_popular_slot_games.count({
     *   where: {
     *     // ... the filter for the Live_casino_most_popular_slot_games we want to count
     *   }
     * })
    **/
    count<T extends live_casino_most_popular_slot_gamesCountArgs>(
      args?: Subset<T, live_casino_most_popular_slot_gamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Live_casino_most_popular_slot_gamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Live_casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Live_casino_most_popular_slot_gamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Live_casino_most_popular_slot_gamesAggregateArgs>(args: Subset<T, Live_casino_most_popular_slot_gamesAggregateArgs>): Prisma.PrismaPromise<GetLive_casino_most_popular_slot_gamesAggregateType<T>>

    /**
     * Group by Live_casino_most_popular_slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {live_casino_most_popular_slot_gamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends live_casino_most_popular_slot_gamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: live_casino_most_popular_slot_gamesGroupByArgs['orderBy'] }
        : { orderBy?: live_casino_most_popular_slot_gamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, live_casino_most_popular_slot_gamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLive_casino_most_popular_slot_gamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the live_casino_most_popular_slot_games model
   */
  readonly fields: live_casino_most_popular_slot_gamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for live_casino_most_popular_slot_games.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__live_casino_most_popular_slot_gamesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    live_casino_most_popular<T extends live_casino_most_popularArgs<ExtArgs> = {}>(args?: Subset<T, live_casino_most_popularArgs<ExtArgs>>): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    slot_games<T extends slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, slot_gamesArgs<ExtArgs>>): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the live_casino_most_popular_slot_games model
   */ 
  interface live_casino_most_popular_slot_gamesFieldRefs {
    readonly live_casino_most_popular_id: FieldRef<"live_casino_most_popular_slot_games", 'Int'>
    readonly slot_games_id: FieldRef<"live_casino_most_popular_slot_games", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * live_casino_most_popular_slot_games findUnique
   */
  export type live_casino_most_popular_slot_gamesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular_slot_games to fetch.
     */
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * live_casino_most_popular_slot_games findUniqueOrThrow
   */
  export type live_casino_most_popular_slot_gamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular_slot_games to fetch.
     */
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * live_casino_most_popular_slot_games findFirst
   */
  export type live_casino_most_popular_slot_gamesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular_slot_games to fetch.
     */
    where?: live_casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_popular_slot_games to fetch.
     */
    orderBy?: live_casino_most_popular_slot_gamesOrderByWithRelationInput | live_casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for live_casino_most_popular_slot_games.
     */
    cursor?: live_casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_popular_slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of live_casino_most_popular_slot_games.
     */
    distinct?: Live_casino_most_popular_slot_gamesScalarFieldEnum | Live_casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * live_casino_most_popular_slot_games findFirstOrThrow
   */
  export type live_casino_most_popular_slot_gamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular_slot_games to fetch.
     */
    where?: live_casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_popular_slot_games to fetch.
     */
    orderBy?: live_casino_most_popular_slot_gamesOrderByWithRelationInput | live_casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for live_casino_most_popular_slot_games.
     */
    cursor?: live_casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_popular_slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of live_casino_most_popular_slot_games.
     */
    distinct?: Live_casino_most_popular_slot_gamesScalarFieldEnum | Live_casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * live_casino_most_popular_slot_games findMany
   */
  export type live_casino_most_popular_slot_gamesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which live_casino_most_popular_slot_games to fetch.
     */
    where?: live_casino_most_popular_slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of live_casino_most_popular_slot_games to fetch.
     */
    orderBy?: live_casino_most_popular_slot_gamesOrderByWithRelationInput | live_casino_most_popular_slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing live_casino_most_popular_slot_games.
     */
    cursor?: live_casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` live_casino_most_popular_slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` live_casino_most_popular_slot_games.
     */
    skip?: number
    distinct?: Live_casino_most_popular_slot_gamesScalarFieldEnum | Live_casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * live_casino_most_popular_slot_games create
   */
  export type live_casino_most_popular_slot_gamesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * The data needed to create a live_casino_most_popular_slot_games.
     */
    data: XOR<live_casino_most_popular_slot_gamesCreateInput, live_casino_most_popular_slot_gamesUncheckedCreateInput>
  }


  /**
   * live_casino_most_popular_slot_games createMany
   */
  export type live_casino_most_popular_slot_gamesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many live_casino_most_popular_slot_games.
     */
    data: live_casino_most_popular_slot_gamesCreateManyInput | live_casino_most_popular_slot_gamesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * live_casino_most_popular_slot_games update
   */
  export type live_casino_most_popular_slot_gamesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * The data needed to update a live_casino_most_popular_slot_games.
     */
    data: XOR<live_casino_most_popular_slot_gamesUpdateInput, live_casino_most_popular_slot_gamesUncheckedUpdateInput>
    /**
     * Choose, which live_casino_most_popular_slot_games to update.
     */
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * live_casino_most_popular_slot_games updateMany
   */
  export type live_casino_most_popular_slot_gamesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update live_casino_most_popular_slot_games.
     */
    data: XOR<live_casino_most_popular_slot_gamesUpdateManyMutationInput, live_casino_most_popular_slot_gamesUncheckedUpdateManyInput>
    /**
     * Filter which live_casino_most_popular_slot_games to update
     */
    where?: live_casino_most_popular_slot_gamesWhereInput
  }


  /**
   * live_casino_most_popular_slot_games upsert
   */
  export type live_casino_most_popular_slot_gamesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * The filter to search for the live_casino_most_popular_slot_games to update in case it exists.
     */
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
    /**
     * In case the live_casino_most_popular_slot_games found by the `where` argument doesn't exist, create a new live_casino_most_popular_slot_games with this data.
     */
    create: XOR<live_casino_most_popular_slot_gamesCreateInput, live_casino_most_popular_slot_gamesUncheckedCreateInput>
    /**
     * In case the live_casino_most_popular_slot_games was found with the provided `where` argument, update it with this data.
     */
    update: XOR<live_casino_most_popular_slot_gamesUpdateInput, live_casino_most_popular_slot_gamesUncheckedUpdateInput>
  }


  /**
   * live_casino_most_popular_slot_games delete
   */
  export type live_casino_most_popular_slot_gamesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    /**
     * Filter which live_casino_most_popular_slot_games to delete.
     */
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
  }


  /**
   * live_casino_most_popular_slot_games deleteMany
   */
  export type live_casino_most_popular_slot_gamesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which live_casino_most_popular_slot_games to delete
     */
    where?: live_casino_most_popular_slot_gamesWhereInput
  }


  /**
   * live_casino_most_popular_slot_games without action
   */
  export type live_casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
  }



  /**
   * Model messenger_messages
   */


  export type AggregateMessenger_messages = {
    _count: Messenger_messagesCountAggregateOutputType | null
    _avg: Messenger_messagesAvgAggregateOutputType | null
    _sum: Messenger_messagesSumAggregateOutputType | null
    _min: Messenger_messagesMinAggregateOutputType | null
    _max: Messenger_messagesMaxAggregateOutputType | null
  }

  export type Messenger_messagesAvgAggregateOutputType = {
    id: number | null
  }

  export type Messenger_messagesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Messenger_messagesMinAggregateOutputType = {
    id: bigint | null
    body: string | null
    headers: string | null
    queue_name: string | null
    created_at: Date | null
    available_at: Date | null
    delivered_at: Date | null
  }

  export type Messenger_messagesMaxAggregateOutputType = {
    id: bigint | null
    body: string | null
    headers: string | null
    queue_name: string | null
    created_at: Date | null
    available_at: Date | null
    delivered_at: Date | null
  }

  export type Messenger_messagesCountAggregateOutputType = {
    id: number
    body: number
    headers: number
    queue_name: number
    created_at: number
    available_at: number
    delivered_at: number
    _all: number
  }


  export type Messenger_messagesAvgAggregateInputType = {
    id?: true
  }

  export type Messenger_messagesSumAggregateInputType = {
    id?: true
  }

  export type Messenger_messagesMinAggregateInputType = {
    id?: true
    body?: true
    headers?: true
    queue_name?: true
    created_at?: true
    available_at?: true
    delivered_at?: true
  }

  export type Messenger_messagesMaxAggregateInputType = {
    id?: true
    body?: true
    headers?: true
    queue_name?: true
    created_at?: true
    available_at?: true
    delivered_at?: true
  }

  export type Messenger_messagesCountAggregateInputType = {
    id?: true
    body?: true
    headers?: true
    queue_name?: true
    created_at?: true
    available_at?: true
    delivered_at?: true
    _all?: true
  }

  export type Messenger_messagesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which messenger_messages to aggregate.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: messenger_messagesOrderByWithRelationInput | messenger_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messenger_messages
    **/
    _count?: true | Messenger_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Messenger_messagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Messenger_messagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Messenger_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Messenger_messagesMaxAggregateInputType
  }

  export type GetMessenger_messagesAggregateType<T extends Messenger_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessenger_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessenger_messages[P]>
      : GetScalarType<T[P], AggregateMessenger_messages[P]>
  }




  export type messenger_messagesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: messenger_messagesWhereInput
    orderBy?: messenger_messagesOrderByWithAggregationInput | messenger_messagesOrderByWithAggregationInput[]
    by: Messenger_messagesScalarFieldEnum[] | Messenger_messagesScalarFieldEnum
    having?: messenger_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Messenger_messagesCountAggregateInputType | true
    _avg?: Messenger_messagesAvgAggregateInputType
    _sum?: Messenger_messagesSumAggregateInputType
    _min?: Messenger_messagesMinAggregateInputType
    _max?: Messenger_messagesMaxAggregateInputType
  }


  export type Messenger_messagesGroupByOutputType = {
    id: bigint
    body: string
    headers: string
    queue_name: string
    created_at: Date
    available_at: Date
    delivered_at: Date | null
    _count: Messenger_messagesCountAggregateOutputType | null
    _avg: Messenger_messagesAvgAggregateOutputType | null
    _sum: Messenger_messagesSumAggregateOutputType | null
    _min: Messenger_messagesMinAggregateOutputType | null
    _max: Messenger_messagesMaxAggregateOutputType | null
  }

  type GetMessenger_messagesGroupByPayload<T extends messenger_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Messenger_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Messenger_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Messenger_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Messenger_messagesGroupByOutputType[P]>
        }
      >
    >


  export type messenger_messagesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    headers?: boolean
    queue_name?: boolean
    created_at?: boolean
    available_at?: boolean
    delivered_at?: boolean
  }, ExtArgs["result"]["messenger_messages"]>

  export type messenger_messagesSelectScalar = {
    id?: boolean
    body?: boolean
    headers?: boolean
    queue_name?: boolean
    created_at?: boolean
    available_at?: boolean
    delivered_at?: boolean
  }


  type messenger_messagesGetPayload<S extends boolean | null | undefined | messenger_messagesArgs> = $Types.GetResult<messenger_messagesPayload, S>

  type messenger_messagesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<messenger_messagesFindManyArgs, 'select' | 'include'> & {
      select?: Messenger_messagesCountAggregateInputType | true
    }

  export interface messenger_messagesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messenger_messages'], meta: { name: 'messenger_messages' } }
    /**
     * Find zero or one Messenger_messages that matches the filter.
     * @param {messenger_messagesFindUniqueArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends messenger_messagesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, messenger_messagesFindUniqueArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Messenger_messages that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {messenger_messagesFindUniqueOrThrowArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends messenger_messagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, messenger_messagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Messenger_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesFindFirstArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends messenger_messagesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, messenger_messagesFindFirstArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Messenger_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesFindFirstOrThrowArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends messenger_messagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, messenger_messagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messenger_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findMany()
     * 
     * // Get first 10 Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messenger_messagesWithIdOnly = await prisma.messenger_messages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends messenger_messagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messenger_messagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Messenger_messages.
     * @param {messenger_messagesCreateArgs} args - Arguments to create a Messenger_messages.
     * @example
     * // Create one Messenger_messages
     * const Messenger_messages = await prisma.messenger_messages.create({
     *   data: {
     *     // ... data to create a Messenger_messages
     *   }
     * })
     * 
    **/
    create<T extends messenger_messagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, messenger_messagesCreateArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messenger_messages.
     *     @param {messenger_messagesCreateManyArgs} args - Arguments to create many Messenger_messages.
     *     @example
     *     // Create many Messenger_messages
     *     const messenger_messages = await prisma.messenger_messages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends messenger_messagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messenger_messagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Messenger_messages.
     * @param {messenger_messagesDeleteArgs} args - Arguments to delete one Messenger_messages.
     * @example
     * // Delete one Messenger_messages
     * const Messenger_messages = await prisma.messenger_messages.delete({
     *   where: {
     *     // ... filter to delete one Messenger_messages
     *   }
     * })
     * 
    **/
    delete<T extends messenger_messagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, messenger_messagesDeleteArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Messenger_messages.
     * @param {messenger_messagesUpdateArgs} args - Arguments to update one Messenger_messages.
     * @example
     * // Update one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends messenger_messagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, messenger_messagesUpdateArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messenger_messages.
     * @param {messenger_messagesDeleteManyArgs} args - Arguments to filter Messenger_messages to delete.
     * @example
     * // Delete a few Messenger_messages
     * const { count } = await prisma.messenger_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends messenger_messagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messenger_messagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends messenger_messagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, messenger_messagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Messenger_messages.
     * @param {messenger_messagesUpsertArgs} args - Arguments to update or create a Messenger_messages.
     * @example
     * // Update or create a Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.upsert({
     *   create: {
     *     // ... data to create a Messenger_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messenger_messages we want to update
     *   }
     * })
    **/
    upsert<T extends messenger_messagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, messenger_messagesUpsertArgs<ExtArgs>>
    ): Prisma__messenger_messagesClient<$Types.GetResult<messenger_messagesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesCountArgs} args - Arguments to filter Messenger_messages to count.
     * @example
     * // Count the number of Messenger_messages
     * const count = await prisma.messenger_messages.count({
     *   where: {
     *     // ... the filter for the Messenger_messages we want to count
     *   }
     * })
    **/
    count<T extends messenger_messagesCountArgs>(
      args?: Subset<T, messenger_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Messenger_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Messenger_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Messenger_messagesAggregateArgs>(args: Subset<T, Messenger_messagesAggregateArgs>): Prisma.PrismaPromise<GetMessenger_messagesAggregateType<T>>

    /**
     * Group by Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messenger_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messenger_messagesGroupByArgs['orderBy'] }
        : { orderBy?: messenger_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messenger_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessenger_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messenger_messages model
   */
  readonly fields: messenger_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messenger_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__messenger_messagesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the messenger_messages model
   */ 
  interface messenger_messagesFieldRefs {
    readonly id: FieldRef<"messenger_messages", 'BigInt'>
    readonly body: FieldRef<"messenger_messages", 'String'>
    readonly headers: FieldRef<"messenger_messages", 'String'>
    readonly queue_name: FieldRef<"messenger_messages", 'String'>
    readonly created_at: FieldRef<"messenger_messages", 'DateTime'>
    readonly available_at: FieldRef<"messenger_messages", 'DateTime'>
    readonly delivered_at: FieldRef<"messenger_messages", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * messenger_messages findUnique
   */
  export type messenger_messagesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where: messenger_messagesWhereUniqueInput
  }


  /**
   * messenger_messages findUniqueOrThrow
   */
  export type messenger_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where: messenger_messagesWhereUniqueInput
  }


  /**
   * messenger_messages findFirst
   */
  export type messenger_messagesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: messenger_messagesOrderByWithRelationInput | messenger_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messenger_messages.
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messenger_messages.
     */
    distinct?: Messenger_messagesScalarFieldEnum | Messenger_messagesScalarFieldEnum[]
  }


  /**
   * messenger_messages findFirstOrThrow
   */
  export type messenger_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: messenger_messagesOrderByWithRelationInput | messenger_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messenger_messages.
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messenger_messages.
     */
    distinct?: Messenger_messagesScalarFieldEnum | Messenger_messagesScalarFieldEnum[]
  }


  /**
   * messenger_messages findMany
   */
  export type messenger_messagesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: messenger_messagesOrderByWithRelationInput | messenger_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messenger_messages.
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    distinct?: Messenger_messagesScalarFieldEnum | Messenger_messagesScalarFieldEnum[]
  }


  /**
   * messenger_messages create
   */
  export type messenger_messagesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * The data needed to create a messenger_messages.
     */
    data: XOR<messenger_messagesCreateInput, messenger_messagesUncheckedCreateInput>
  }


  /**
   * messenger_messages createMany
   */
  export type messenger_messagesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messenger_messages.
     */
    data: messenger_messagesCreateManyInput | messenger_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * messenger_messages update
   */
  export type messenger_messagesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * The data needed to update a messenger_messages.
     */
    data: XOR<messenger_messagesUpdateInput, messenger_messagesUncheckedUpdateInput>
    /**
     * Choose, which messenger_messages to update.
     */
    where: messenger_messagesWhereUniqueInput
  }


  /**
   * messenger_messages updateMany
   */
  export type messenger_messagesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messenger_messages.
     */
    data: XOR<messenger_messagesUpdateManyMutationInput, messenger_messagesUncheckedUpdateManyInput>
    /**
     * Filter which messenger_messages to update
     */
    where?: messenger_messagesWhereInput
  }


  /**
   * messenger_messages upsert
   */
  export type messenger_messagesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * The filter to search for the messenger_messages to update in case it exists.
     */
    where: messenger_messagesWhereUniqueInput
    /**
     * In case the messenger_messages found by the `where` argument doesn't exist, create a new messenger_messages with this data.
     */
    create: XOR<messenger_messagesCreateInput, messenger_messagesUncheckedCreateInput>
    /**
     * In case the messenger_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messenger_messagesUpdateInput, messenger_messagesUncheckedUpdateInput>
  }


  /**
   * messenger_messages delete
   */
  export type messenger_messagesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
    /**
     * Filter which messenger_messages to delete.
     */
    where: messenger_messagesWhereUniqueInput
  }


  /**
   * messenger_messages deleteMany
   */
  export type messenger_messagesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which messenger_messages to delete
     */
    where?: messenger_messagesWhereInput
  }


  /**
   * messenger_messages without action
   */
  export type messenger_messagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect<ExtArgs> | null
  }



  /**
   * Model operations
   */


  export type AggregateOperations = {
    _count: OperationsCountAggregateOutputType | null
    _avg: OperationsAvgAggregateOutputType | null
    _sum: OperationsSumAggregateOutputType | null
    _min: OperationsMinAggregateOutputType | null
    _max: OperationsMaxAggregateOutputType | null
  }

  export type OperationsAvgAggregateOutputType = {
    id: number | null
    whithdraw_minimum: number | null
    withdraw_maximum: number | null
    withdraw_fee: number | null
    deposit_minimum: number | null
    deposit_maximum: number | null
  }

  export type OperationsSumAggregateOutputType = {
    id: number | null
    whithdraw_minimum: number | null
    withdraw_maximum: number | null
    withdraw_fee: number | null
    deposit_minimum: number | null
    deposit_maximum: number | null
  }

  export type OperationsMinAggregateOutputType = {
    id: number | null
    active: boolean | null
    whithdraw_minimum: number | null
    withdraw_maximum: number | null
    withdraw_fee: number | null
    deposit_minimum: number | null
    deposit_maximum: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OperationsMaxAggregateOutputType = {
    id: number | null
    active: boolean | null
    whithdraw_minimum: number | null
    withdraw_maximum: number | null
    withdraw_fee: number | null
    deposit_minimum: number | null
    deposit_maximum: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OperationsCountAggregateOutputType = {
    id: number
    active: number
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OperationsAvgAggregateInputType = {
    id?: true
    whithdraw_minimum?: true
    withdraw_maximum?: true
    withdraw_fee?: true
    deposit_minimum?: true
    deposit_maximum?: true
  }

  export type OperationsSumAggregateInputType = {
    id?: true
    whithdraw_minimum?: true
    withdraw_maximum?: true
    withdraw_fee?: true
    deposit_minimum?: true
    deposit_maximum?: true
  }

  export type OperationsMinAggregateInputType = {
    id?: true
    active?: true
    whithdraw_minimum?: true
    withdraw_maximum?: true
    withdraw_fee?: true
    deposit_minimum?: true
    deposit_maximum?: true
    created_at?: true
    updated_at?: true
  }

  export type OperationsMaxAggregateInputType = {
    id?: true
    active?: true
    whithdraw_minimum?: true
    withdraw_maximum?: true
    withdraw_fee?: true
    deposit_minimum?: true
    deposit_maximum?: true
    created_at?: true
    updated_at?: true
  }

  export type OperationsCountAggregateInputType = {
    id?: true
    active?: true
    whithdraw_minimum?: true
    withdraw_maximum?: true
    withdraw_fee?: true
    deposit_minimum?: true
    deposit_maximum?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OperationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operations to aggregate.
     */
    where?: operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operations to fetch.
     */
    orderBy?: operationsOrderByWithRelationInput | operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operations
    **/
    _count?: true | OperationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationsMaxAggregateInputType
  }

  export type GetOperationsAggregateType<T extends OperationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOperations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperations[P]>
      : GetScalarType<T[P], AggregateOperations[P]>
  }




  export type operationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: operationsWhereInput
    orderBy?: operationsOrderByWithAggregationInput | operationsOrderByWithAggregationInput[]
    by: OperationsScalarFieldEnum[] | OperationsScalarFieldEnum
    having?: operationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationsCountAggregateInputType | true
    _avg?: OperationsAvgAggregateInputType
    _sum?: OperationsSumAggregateInputType
    _min?: OperationsMinAggregateInputType
    _max?: OperationsMaxAggregateInputType
  }


  export type OperationsGroupByOutputType = {
    id: number
    active: boolean
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: Date
    updated_at: Date
    _count: OperationsCountAggregateOutputType | null
    _avg: OperationsAvgAggregateOutputType | null
    _sum: OperationsSumAggregateOutputType | null
    _min: OperationsMinAggregateOutputType | null
    _max: OperationsMaxAggregateOutputType | null
  }

  type GetOperationsGroupByPayload<T extends operationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationsGroupByOutputType[P]>
            : GetScalarType<T[P], OperationsGroupByOutputType[P]>
        }
      >
    >


  export type operationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    active?: boolean
    whithdraw_minimum?: boolean
    withdraw_maximum?: boolean
    withdraw_fee?: boolean
    deposit_minimum?: boolean
    deposit_maximum?: boolean
    created_at?: boolean
    updated_at?: boolean
    settings?: boolean | operations$settingsArgs<ExtArgs>
  }, ExtArgs["result"]["operations"]>

  export type operationsSelectScalar = {
    id?: boolean
    active?: boolean
    whithdraw_minimum?: boolean
    withdraw_maximum?: boolean
    withdraw_fee?: boolean
    deposit_minimum?: boolean
    deposit_maximum?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type operationsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    settings?: boolean | operations$settingsArgs<ExtArgs>
  }


  type operationsGetPayload<S extends boolean | null | undefined | operationsArgs> = $Types.GetResult<operationsPayload, S>

  type operationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<operationsFindManyArgs, 'select' | 'include'> & {
      select?: OperationsCountAggregateInputType | true
    }

  export interface operationsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operations'], meta: { name: 'operations' } }
    /**
     * Find zero or one Operations that matches the filter.
     * @param {operationsFindUniqueArgs} args - Arguments to find a Operations
     * @example
     * // Get one Operations
     * const operations = await prisma.operations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends operationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, operationsFindUniqueArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Operations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {operationsFindUniqueOrThrowArgs} args - Arguments to find a Operations
     * @example
     * // Get one Operations
     * const operations = await prisma.operations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends operationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Operations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operationsFindFirstArgs} args - Arguments to find a Operations
     * @example
     * // Get one Operations
     * const operations = await prisma.operations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends operationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, operationsFindFirstArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Operations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operationsFindFirstOrThrowArgs} args - Arguments to find a Operations
     * @example
     * // Get one Operations
     * const operations = await prisma.operations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends operationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Operations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operations
     * const operations = await prisma.operations.findMany()
     * 
     * // Get first 10 Operations
     * const operations = await prisma.operations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationsWithIdOnly = await prisma.operations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends operationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<operationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Operations.
     * @param {operationsCreateArgs} args - Arguments to create a Operations.
     * @example
     * // Create one Operations
     * const Operations = await prisma.operations.create({
     *   data: {
     *     // ... data to create a Operations
     *   }
     * })
     * 
    **/
    create<T extends operationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, operationsCreateArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Operations.
     *     @param {operationsCreateManyArgs} args - Arguments to create many Operations.
     *     @example
     *     // Create many Operations
     *     const operations = await prisma.operations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends operationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operations.
     * @param {operationsDeleteArgs} args - Arguments to delete one Operations.
     * @example
     * // Delete one Operations
     * const Operations = await prisma.operations.delete({
     *   where: {
     *     // ... filter to delete one Operations
     *   }
     * })
     * 
    **/
    delete<T extends operationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, operationsDeleteArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Operations.
     * @param {operationsUpdateArgs} args - Arguments to update one Operations.
     * @example
     * // Update one Operations
     * const operations = await prisma.operations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends operationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, operationsUpdateArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Operations.
     * @param {operationsDeleteManyArgs} args - Arguments to filter Operations to delete.
     * @example
     * // Delete a few Operations
     * const { count } = await prisma.operations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends operationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operations
     * const operations = await prisma.operations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends operationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, operationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operations.
     * @param {operationsUpsertArgs} args - Arguments to update or create a Operations.
     * @example
     * // Update or create a Operations
     * const operations = await prisma.operations.upsert({
     *   create: {
     *     // ... data to create a Operations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operations we want to update
     *   }
     * })
    **/
    upsert<T extends operationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, operationsUpsertArgs<ExtArgs>>
    ): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operationsCountArgs} args - Arguments to filter Operations to count.
     * @example
     * // Count the number of Operations
     * const count = await prisma.operations.count({
     *   where: {
     *     // ... the filter for the Operations we want to count
     *   }
     * })
    **/
    count<T extends operationsCountArgs>(
      args?: Subset<T, operationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationsAggregateArgs>(args: Subset<T, OperationsAggregateArgs>): Prisma.PrismaPromise<GetOperationsAggregateType<T>>

    /**
     * Group by Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operationsGroupByArgs['orderBy'] }
        : { orderBy?: operationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the operations model
   */
  readonly fields: operationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for operations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__operationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    settings<T extends operations$settingsArgs<ExtArgs> = {}>(args?: Subset<T, operations$settingsArgs<ExtArgs>>): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the operations model
   */ 
  interface operationsFieldRefs {
    readonly id: FieldRef<"operations", 'Int'>
    readonly active: FieldRef<"operations", 'Boolean'>
    readonly whithdraw_minimum: FieldRef<"operations", 'Float'>
    readonly withdraw_maximum: FieldRef<"operations", 'Float'>
    readonly withdraw_fee: FieldRef<"operations", 'Float'>
    readonly deposit_minimum: FieldRef<"operations", 'Float'>
    readonly deposit_maximum: FieldRef<"operations", 'Float'>
    readonly created_at: FieldRef<"operations", 'DateTime'>
    readonly updated_at: FieldRef<"operations", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * operations findUnique
   */
  export type operationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * Filter, which operations to fetch.
     */
    where: operationsWhereUniqueInput
  }


  /**
   * operations findUniqueOrThrow
   */
  export type operationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * Filter, which operations to fetch.
     */
    where: operationsWhereUniqueInput
  }


  /**
   * operations findFirst
   */
  export type operationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * Filter, which operations to fetch.
     */
    where?: operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operations to fetch.
     */
    orderBy?: operationsOrderByWithRelationInput | operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operations.
     */
    cursor?: operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operations.
     */
    distinct?: OperationsScalarFieldEnum | OperationsScalarFieldEnum[]
  }


  /**
   * operations findFirstOrThrow
   */
  export type operationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * Filter, which operations to fetch.
     */
    where?: operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operations to fetch.
     */
    orderBy?: operationsOrderByWithRelationInput | operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operations.
     */
    cursor?: operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operations.
     */
    distinct?: OperationsScalarFieldEnum | OperationsScalarFieldEnum[]
  }


  /**
   * operations findMany
   */
  export type operationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * Filter, which operations to fetch.
     */
    where?: operationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operations to fetch.
     */
    orderBy?: operationsOrderByWithRelationInput | operationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operations.
     */
    cursor?: operationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operations.
     */
    skip?: number
    distinct?: OperationsScalarFieldEnum | OperationsScalarFieldEnum[]
  }


  /**
   * operations create
   */
  export type operationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * The data needed to create a operations.
     */
    data: XOR<operationsCreateInput, operationsUncheckedCreateInput>
  }


  /**
   * operations createMany
   */
  export type operationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operations.
     */
    data: operationsCreateManyInput | operationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * operations update
   */
  export type operationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * The data needed to update a operations.
     */
    data: XOR<operationsUpdateInput, operationsUncheckedUpdateInput>
    /**
     * Choose, which operations to update.
     */
    where: operationsWhereUniqueInput
  }


  /**
   * operations updateMany
   */
  export type operationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operations.
     */
    data: XOR<operationsUpdateManyMutationInput, operationsUncheckedUpdateManyInput>
    /**
     * Filter which operations to update
     */
    where?: operationsWhereInput
  }


  /**
   * operations upsert
   */
  export type operationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * The filter to search for the operations to update in case it exists.
     */
    where: operationsWhereUniqueInput
    /**
     * In case the operations found by the `where` argument doesn't exist, create a new operations with this data.
     */
    create: XOR<operationsCreateInput, operationsUncheckedCreateInput>
    /**
     * In case the operations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operationsUpdateInput, operationsUncheckedUpdateInput>
  }


  /**
   * operations delete
   */
  export type operationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    /**
     * Filter which operations to delete.
     */
    where: operationsWhereUniqueInput
  }


  /**
   * operations deleteMany
   */
  export type operationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operations to delete
     */
    where?: operationsWhereInput
  }


  /**
   * operations.settings
   */
  export type operations$settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    where?: settingsWhereInput
  }


  /**
   * operations without action
   */
  export type operationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
  }



  /**
   * Model provider
   */


  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderAvgAggregateOutputType = {
    id: number | null
    client_percent: number | null
    base_percent: number | null
  }

  export type ProviderSumAggregateOutputType = {
    id: number | null
    client_percent: number | null
    base_percent: number | null
  }

  export type ProviderMinAggregateOutputType = {
    id: number | null
    name: string | null
    client_percent: number | null
    base_percent: number | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: number | null
    name: string | null
    client_percent: number | null
    base_percent: number | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    name: number
    client_percent: number
    base_percent: number
    _all: number
  }


  export type ProviderAvgAggregateInputType = {
    id?: true
    client_percent?: true
    base_percent?: true
  }

  export type ProviderSumAggregateInputType = {
    id?: true
    client_percent?: true
    base_percent?: true
  }

  export type ProviderMinAggregateInputType = {
    id?: true
    name?: true
    client_percent?: true
    base_percent?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    name?: true
    client_percent?: true
    base_percent?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    name?: true
    client_percent?: true
    base_percent?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider to aggregate.
     */
    where?: providerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providerOrderByWithRelationInput | providerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: providerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type providerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: providerWhereInput
    orderBy?: providerOrderByWithAggregationInput | providerOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: providerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _avg?: ProviderAvgAggregateInputType
    _sum?: ProviderSumAggregateInputType
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }


  export type ProviderGroupByOutputType = {
    id: number
    name: string
    client_percent: number | null
    base_percent: number | null
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends providerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type providerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    client_percent?: boolean
    base_percent?: boolean
    slot_games?: boolean | provider$slot_gamesArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type providerSelectScalar = {
    id?: boolean
    name?: boolean
    client_percent?: boolean
    base_percent?: boolean
  }

  export type providerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    slot_games?: boolean | provider$slot_gamesArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeArgs<ExtArgs>
  }


  type providerGetPayload<S extends boolean | null | undefined | providerArgs> = $Types.GetResult<providerPayload, S>

  type providerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<providerFindManyArgs, 'select' | 'include'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface providerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider'], meta: { name: 'provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {providerFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends providerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, providerFindUniqueArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Provider that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {providerFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends providerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, providerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providerFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends providerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, providerFindFirstArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providerFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends providerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, providerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends providerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, providerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<providerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Provider.
     * @param {providerCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
    **/
    create<T extends providerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, providerCreateArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Providers.
     *     @param {providerCreateManyArgs} args - Arguments to create many Providers.
     *     @example
     *     // Create many Providers
     *     const provider = await prisma.provider.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends providerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, providerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provider.
     * @param {providerDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
    **/
    delete<T extends providerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, providerDeleteArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Provider.
     * @param {providerUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends providerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, providerUpdateArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Providers.
     * @param {providerDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends providerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, providerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends providerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, providerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provider.
     * @param {providerUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
    **/
    upsert<T extends providerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, providerUpsertArgs<ExtArgs>>
    ): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providerCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends providerCountArgs>(
      args?: Subset<T, providerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends providerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: providerGroupByArgs['orderBy'] }
        : { orderBy?: providerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, providerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider model
   */
  readonly fields: providerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__providerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    slot_games<T extends provider$slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, provider$slot_gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the provider model
   */ 
  interface providerFieldRefs {
    readonly id: FieldRef<"provider", 'Int'>
    readonly name: FieldRef<"provider", 'String'>
    readonly client_percent: FieldRef<"provider", 'Int'>
    readonly base_percent: FieldRef<"provider", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * provider findUnique
   */
  export type providerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * Filter, which provider to fetch.
     */
    where: providerWhereUniqueInput
  }


  /**
   * provider findUniqueOrThrow
   */
  export type providerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * Filter, which provider to fetch.
     */
    where: providerWhereUniqueInput
  }


  /**
   * provider findFirst
   */
  export type providerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * Filter, which provider to fetch.
     */
    where?: providerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providerOrderByWithRelationInput | providerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }


  /**
   * provider findFirstOrThrow
   */
  export type providerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * Filter, which provider to fetch.
     */
    where?: providerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providerOrderByWithRelationInput | providerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }


  /**
   * provider findMany
   */
  export type providerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providerOrderByWithRelationInput | providerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing providers.
     */
    cursor?: providerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }


  /**
   * provider create
   */
  export type providerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * The data needed to create a provider.
     */
    data: XOR<providerCreateInput, providerUncheckedCreateInput>
  }


  /**
   * provider createMany
   */
  export type providerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many providers.
     */
    data: providerCreateManyInput | providerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * provider update
   */
  export type providerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * The data needed to update a provider.
     */
    data: XOR<providerUpdateInput, providerUncheckedUpdateInput>
    /**
     * Choose, which provider to update.
     */
    where: providerWhereUniqueInput
  }


  /**
   * provider updateMany
   */
  export type providerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update providers.
     */
    data: XOR<providerUpdateManyMutationInput, providerUncheckedUpdateManyInput>
    /**
     * Filter which providers to update
     */
    where?: providerWhereInput
  }


  /**
   * provider upsert
   */
  export type providerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * The filter to search for the provider to update in case it exists.
     */
    where: providerWhereUniqueInput
    /**
     * In case the provider found by the `where` argument doesn't exist, create a new provider with this data.
     */
    create: XOR<providerCreateInput, providerUncheckedCreateInput>
    /**
     * In case the provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<providerUpdateInput, providerUncheckedUpdateInput>
  }


  /**
   * provider delete
   */
  export type providerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
    /**
     * Filter which provider to delete.
     */
    where: providerWhereUniqueInput
  }


  /**
   * provider deleteMany
   */
  export type providerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which providers to delete
     */
    where?: providerWhereInput
  }


  /**
   * provider.slot_games
   */
  export type provider$slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    where?: slot_gamesWhereInput
    orderBy?: slot_gamesOrderByWithRelationInput | slot_gamesOrderByWithRelationInput[]
    cursor?: slot_gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Slot_gamesScalarFieldEnum | Slot_gamesScalarFieldEnum[]
  }


  /**
   * provider without action
   */
  export type providerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider
     */
    select?: providerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providerInclude<ExtArgs> | null
  }



  /**
   * Model referral_history
   */


  export type AggregateReferral_history = {
    _count: Referral_historyCountAggregateOutputType | null
    _avg: Referral_historyAvgAggregateOutputType | null
    _sum: Referral_historySumAggregateOutputType | null
    _min: Referral_historyMinAggregateOutputType | null
    _max: Referral_historyMaxAggregateOutputType | null
  }

  export type Referral_historyAvgAggregateOutputType = {
    id: number | null
    referral_id: number | null
    user_id: number | null
    amount: number | null
  }

  export type Referral_historySumAggregateOutputType = {
    id: number | null
    referral_id: number | null
    user_id: number | null
    amount: number | null
  }

  export type Referral_historyMinAggregateOutputType = {
    id: number | null
    referral_id: number | null
    user_id: number | null
    game: string | null
    amount: number | null
    type: string | null
    available: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Referral_historyMaxAggregateOutputType = {
    id: number | null
    referral_id: number | null
    user_id: number | null
    game: string | null
    amount: number | null
    type: string | null
    available: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Referral_historyCountAggregateOutputType = {
    id: number
    referral_id: number
    user_id: number
    game: number
    amount: number
    type: number
    available: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Referral_historyAvgAggregateInputType = {
    id?: true
    referral_id?: true
    user_id?: true
    amount?: true
  }

  export type Referral_historySumAggregateInputType = {
    id?: true
    referral_id?: true
    user_id?: true
    amount?: true
  }

  export type Referral_historyMinAggregateInputType = {
    id?: true
    referral_id?: true
    user_id?: true
    game?: true
    amount?: true
    type?: true
    available?: true
    created_at?: true
    updated_at?: true
  }

  export type Referral_historyMaxAggregateInputType = {
    id?: true
    referral_id?: true
    user_id?: true
    game?: true
    amount?: true
    type?: true
    available?: true
    created_at?: true
    updated_at?: true
  }

  export type Referral_historyCountAggregateInputType = {
    id?: true
    referral_id?: true
    user_id?: true
    game?: true
    amount?: true
    type?: true
    available?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Referral_historyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_history to aggregate.
     */
    where?: referral_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_histories to fetch.
     */
    orderBy?: referral_historyOrderByWithRelationInput | referral_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_histories
    **/
    _count?: true | Referral_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Referral_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Referral_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_historyMaxAggregateInputType
  }

  export type GetReferral_historyAggregateType<T extends Referral_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_history[P]>
      : GetScalarType<T[P], AggregateReferral_history[P]>
  }




  export type referral_historyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: referral_historyWhereInput
    orderBy?: referral_historyOrderByWithAggregationInput | referral_historyOrderByWithAggregationInput[]
    by: Referral_historyScalarFieldEnum[] | Referral_historyScalarFieldEnum
    having?: referral_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_historyCountAggregateInputType | true
    _avg?: Referral_historyAvgAggregateInputType
    _sum?: Referral_historySumAggregateInputType
    _min?: Referral_historyMinAggregateInputType
    _max?: Referral_historyMaxAggregateInputType
  }


  export type Referral_historyGroupByOutputType = {
    id: number
    referral_id: number
    user_id: number | null
    game: string | null
    amount: number | null
    type: string | null
    available: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: Referral_historyCountAggregateOutputType | null
    _avg: Referral_historyAvgAggregateOutputType | null
    _sum: Referral_historySumAggregateOutputType | null
    _min: Referral_historyMinAggregateOutputType | null
    _max: Referral_historyMaxAggregateOutputType | null
  }

  type GetReferral_historyGroupByPayload<T extends referral_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Referral_historyGroupByOutputType[P]>
        }
      >
    >


  export type referral_historySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referral_id?: boolean
    user_id?: boolean
    game?: boolean
    amount?: boolean
    type?: boolean
    available?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_referral_history_referral_idTouser?: boolean | userArgs<ExtArgs>
    user_referral_history_user_idTouser?: boolean | referral_history$user_referral_history_user_idTouserArgs<ExtArgs>
  }, ExtArgs["result"]["referral_history"]>

  export type referral_historySelectScalar = {
    id?: boolean
    referral_id?: boolean
    user_id?: boolean
    game?: boolean
    amount?: boolean
    type?: boolean
    available?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type referral_historyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_referral_history_referral_idTouser?: boolean | userArgs<ExtArgs>
    user_referral_history_user_idTouser?: boolean | referral_history$user_referral_history_user_idTouserArgs<ExtArgs>
  }


  type referral_historyGetPayload<S extends boolean | null | undefined | referral_historyArgs> = $Types.GetResult<referral_historyPayload, S>

  type referral_historyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<referral_historyFindManyArgs, 'select' | 'include'> & {
      select?: Referral_historyCountAggregateInputType | true
    }

  export interface referral_historyDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_history'], meta: { name: 'referral_history' } }
    /**
     * Find zero or one Referral_history that matches the filter.
     * @param {referral_historyFindUniqueArgs} args - Arguments to find a Referral_history
     * @example
     * // Get one Referral_history
     * const referral_history = await prisma.referral_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends referral_historyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, referral_historyFindUniqueArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Referral_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {referral_historyFindUniqueOrThrowArgs} args - Arguments to find a Referral_history
     * @example
     * // Get one Referral_history
     * const referral_history = await prisma.referral_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends referral_historyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_historyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Referral_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_historyFindFirstArgs} args - Arguments to find a Referral_history
     * @example
     * // Get one Referral_history
     * const referral_history = await prisma.referral_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends referral_historyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_historyFindFirstArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Referral_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_historyFindFirstOrThrowArgs} args - Arguments to find a Referral_history
     * @example
     * // Get one Referral_history
     * const referral_history = await prisma.referral_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends referral_historyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_historyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Referral_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_histories
     * const referral_histories = await prisma.referral_history.findMany()
     * 
     * // Get first 10 Referral_histories
     * const referral_histories = await prisma.referral_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referral_historyWithIdOnly = await prisma.referral_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends referral_historyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Referral_history.
     * @param {referral_historyCreateArgs} args - Arguments to create a Referral_history.
     * @example
     * // Create one Referral_history
     * const Referral_history = await prisma.referral_history.create({
     *   data: {
     *     // ... data to create a Referral_history
     *   }
     * })
     * 
    **/
    create<T extends referral_historyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, referral_historyCreateArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Referral_histories.
     *     @param {referral_historyCreateManyArgs} args - Arguments to create many Referral_histories.
     *     @example
     *     // Create many Referral_histories
     *     const referral_history = await prisma.referral_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends referral_historyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral_history.
     * @param {referral_historyDeleteArgs} args - Arguments to delete one Referral_history.
     * @example
     * // Delete one Referral_history
     * const Referral_history = await prisma.referral_history.delete({
     *   where: {
     *     // ... filter to delete one Referral_history
     *   }
     * })
     * 
    **/
    delete<T extends referral_historyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, referral_historyDeleteArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Referral_history.
     * @param {referral_historyUpdateArgs} args - Arguments to update one Referral_history.
     * @example
     * // Update one Referral_history
     * const referral_history = await prisma.referral_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends referral_historyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, referral_historyUpdateArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Referral_histories.
     * @param {referral_historyDeleteManyArgs} args - Arguments to filter Referral_histories to delete.
     * @example
     * // Delete a few Referral_histories
     * const { count } = await prisma.referral_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends referral_historyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_histories
     * const referral_history = await prisma.referral_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends referral_historyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, referral_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral_history.
     * @param {referral_historyUpsertArgs} args - Arguments to update or create a Referral_history.
     * @example
     * // Update or create a Referral_history
     * const referral_history = await prisma.referral_history.upsert({
     *   create: {
     *     // ... data to create a Referral_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_history we want to update
     *   }
     * })
    **/
    upsert<T extends referral_historyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, referral_historyUpsertArgs<ExtArgs>>
    ): Prisma__referral_historyClient<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Referral_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_historyCountArgs} args - Arguments to filter Referral_histories to count.
     * @example
     * // Count the number of Referral_histories
     * const count = await prisma.referral_history.count({
     *   where: {
     *     // ... the filter for the Referral_histories we want to count
     *   }
     * })
    **/
    count<T extends referral_historyCountArgs>(
      args?: Subset<T, referral_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_historyAggregateArgs>(args: Subset<T, Referral_historyAggregateArgs>): Prisma.PrismaPromise<GetReferral_historyAggregateType<T>>

    /**
     * Group by Referral_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_historyGroupByArgs['orderBy'] }
        : { orderBy?: referral_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_history model
   */
  readonly fields: referral_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__referral_historyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user_referral_history_referral_idTouser<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    user_referral_history_user_idTouser<T extends referral_history$user_referral_history_user_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, referral_history$user_referral_history_user_idTouserArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the referral_history model
   */ 
  interface referral_historyFieldRefs {
    readonly id: FieldRef<"referral_history", 'Int'>
    readonly referral_id: FieldRef<"referral_history", 'Int'>
    readonly user_id: FieldRef<"referral_history", 'Int'>
    readonly game: FieldRef<"referral_history", 'String'>
    readonly amount: FieldRef<"referral_history", 'Float'>
    readonly type: FieldRef<"referral_history", 'String'>
    readonly available: FieldRef<"referral_history", 'Boolean'>
    readonly created_at: FieldRef<"referral_history", 'DateTime'>
    readonly updated_at: FieldRef<"referral_history", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * referral_history findUnique
   */
  export type referral_historyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * Filter, which referral_history to fetch.
     */
    where: referral_historyWhereUniqueInput
  }


  /**
   * referral_history findUniqueOrThrow
   */
  export type referral_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * Filter, which referral_history to fetch.
     */
    where: referral_historyWhereUniqueInput
  }


  /**
   * referral_history findFirst
   */
  export type referral_historyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * Filter, which referral_history to fetch.
     */
    where?: referral_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_histories to fetch.
     */
    orderBy?: referral_historyOrderByWithRelationInput | referral_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_histories.
     */
    cursor?: referral_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_histories.
     */
    distinct?: Referral_historyScalarFieldEnum | Referral_historyScalarFieldEnum[]
  }


  /**
   * referral_history findFirstOrThrow
   */
  export type referral_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * Filter, which referral_history to fetch.
     */
    where?: referral_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_histories to fetch.
     */
    orderBy?: referral_historyOrderByWithRelationInput | referral_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_histories.
     */
    cursor?: referral_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_histories.
     */
    distinct?: Referral_historyScalarFieldEnum | Referral_historyScalarFieldEnum[]
  }


  /**
   * referral_history findMany
   */
  export type referral_historyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * Filter, which referral_histories to fetch.
     */
    where?: referral_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_histories to fetch.
     */
    orderBy?: referral_historyOrderByWithRelationInput | referral_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_histories.
     */
    cursor?: referral_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_histories.
     */
    skip?: number
    distinct?: Referral_historyScalarFieldEnum | Referral_historyScalarFieldEnum[]
  }


  /**
   * referral_history create
   */
  export type referral_historyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a referral_history.
     */
    data: XOR<referral_historyCreateInput, referral_historyUncheckedCreateInput>
  }


  /**
   * referral_history createMany
   */
  export type referral_historyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_histories.
     */
    data: referral_historyCreateManyInput | referral_historyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * referral_history update
   */
  export type referral_historyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a referral_history.
     */
    data: XOR<referral_historyUpdateInput, referral_historyUncheckedUpdateInput>
    /**
     * Choose, which referral_history to update.
     */
    where: referral_historyWhereUniqueInput
  }


  /**
   * referral_history updateMany
   */
  export type referral_historyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_histories.
     */
    data: XOR<referral_historyUpdateManyMutationInput, referral_historyUncheckedUpdateManyInput>
    /**
     * Filter which referral_histories to update
     */
    where?: referral_historyWhereInput
  }


  /**
   * referral_history upsert
   */
  export type referral_historyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the referral_history to update in case it exists.
     */
    where: referral_historyWhereUniqueInput
    /**
     * In case the referral_history found by the `where` argument doesn't exist, create a new referral_history with this data.
     */
    create: XOR<referral_historyCreateInput, referral_historyUncheckedCreateInput>
    /**
     * In case the referral_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_historyUpdateInput, referral_historyUncheckedUpdateInput>
  }


  /**
   * referral_history delete
   */
  export type referral_historyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    /**
     * Filter which referral_history to delete.
     */
    where: referral_historyWhereUniqueInput
  }


  /**
   * referral_history deleteMany
   */
  export type referral_historyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_histories to delete
     */
    where?: referral_historyWhereInput
  }


  /**
   * referral_history.user_referral_history_user_idTouser
   */
  export type referral_history$user_referral_history_user_idTouserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * referral_history without action
   */
  export type referral_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
  }



  /**
   * Model referral_settings
   */


  export type AggregateReferral_settings = {
    _count: Referral_settingsCountAggregateOutputType | null
    _avg: Referral_settingsAvgAggregateOutputType | null
    _sum: Referral_settingsSumAggregateOutputType | null
    _min: Referral_settingsMinAggregateOutputType | null
    _max: Referral_settingsMaxAggregateOutputType | null
  }

  export type Referral_settingsAvgAggregateOutputType = {
    id: number | null
    cpa: number | null
    rev_share_percent: number | null
  }

  export type Referral_settingsSumAggregateOutputType = {
    id: number | null
    cpa: number | null
    rev_share_percent: number | null
  }

  export type Referral_settingsMinAggregateOutputType = {
    id: number | null
    cpa: number | null
    rev_share_percent: number | null
    referral_type: string | null
  }

  export type Referral_settingsMaxAggregateOutputType = {
    id: number | null
    cpa: number | null
    rev_share_percent: number | null
    referral_type: string | null
  }

  export type Referral_settingsCountAggregateOutputType = {
    id: number
    cpa: number
    rev_share_percent: number
    referral_type: number
    _all: number
  }


  export type Referral_settingsAvgAggregateInputType = {
    id?: true
    cpa?: true
    rev_share_percent?: true
  }

  export type Referral_settingsSumAggregateInputType = {
    id?: true
    cpa?: true
    rev_share_percent?: true
  }

  export type Referral_settingsMinAggregateInputType = {
    id?: true
    cpa?: true
    rev_share_percent?: true
    referral_type?: true
  }

  export type Referral_settingsMaxAggregateInputType = {
    id?: true
    cpa?: true
    rev_share_percent?: true
    referral_type?: true
  }

  export type Referral_settingsCountAggregateInputType = {
    id?: true
    cpa?: true
    rev_share_percent?: true
    referral_type?: true
    _all?: true
  }

  export type Referral_settingsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_settings to aggregate.
     */
    where?: referral_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_settings to fetch.
     */
    orderBy?: referral_settingsOrderByWithRelationInput | referral_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_settings
    **/
    _count?: true | Referral_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Referral_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Referral_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_settingsMaxAggregateInputType
  }

  export type GetReferral_settingsAggregateType<T extends Referral_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_settings[P]>
      : GetScalarType<T[P], AggregateReferral_settings[P]>
  }




  export type referral_settingsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: referral_settingsWhereInput
    orderBy?: referral_settingsOrderByWithAggregationInput | referral_settingsOrderByWithAggregationInput[]
    by: Referral_settingsScalarFieldEnum[] | Referral_settingsScalarFieldEnum
    having?: referral_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_settingsCountAggregateInputType | true
    _avg?: Referral_settingsAvgAggregateInputType
    _sum?: Referral_settingsSumAggregateInputType
    _min?: Referral_settingsMinAggregateInputType
    _max?: Referral_settingsMaxAggregateInputType
  }


  export type Referral_settingsGroupByOutputType = {
    id: number
    cpa: number | null
    rev_share_percent: number | null
    referral_type: string | null
    _count: Referral_settingsCountAggregateOutputType | null
    _avg: Referral_settingsAvgAggregateOutputType | null
    _sum: Referral_settingsSumAggregateOutputType | null
    _min: Referral_settingsMinAggregateOutputType | null
    _max: Referral_settingsMaxAggregateOutputType | null
  }

  type GetReferral_settingsGroupByPayload<T extends referral_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Referral_settingsGroupByOutputType[P]>
        }
      >
    >


  export type referral_settingsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpa?: boolean
    rev_share_percent?: boolean
    referral_type?: boolean
    user?: boolean | referral_settings$userArgs<ExtArgs>
  }, ExtArgs["result"]["referral_settings"]>

  export type referral_settingsSelectScalar = {
    id?: boolean
    cpa?: boolean
    rev_share_percent?: boolean
    referral_type?: boolean
  }

  export type referral_settingsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | referral_settings$userArgs<ExtArgs>
  }


  type referral_settingsGetPayload<S extends boolean | null | undefined | referral_settingsArgs> = $Types.GetResult<referral_settingsPayload, S>

  type referral_settingsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<referral_settingsFindManyArgs, 'select' | 'include'> & {
      select?: Referral_settingsCountAggregateInputType | true
    }

  export interface referral_settingsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_settings'], meta: { name: 'referral_settings' } }
    /**
     * Find zero or one Referral_settings that matches the filter.
     * @param {referral_settingsFindUniqueArgs} args - Arguments to find a Referral_settings
     * @example
     * // Get one Referral_settings
     * const referral_settings = await prisma.referral_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends referral_settingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, referral_settingsFindUniqueArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Referral_settings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {referral_settingsFindUniqueOrThrowArgs} args - Arguments to find a Referral_settings
     * @example
     * // Get one Referral_settings
     * const referral_settings = await prisma.referral_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends referral_settingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_settingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Referral_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_settingsFindFirstArgs} args - Arguments to find a Referral_settings
     * @example
     * // Get one Referral_settings
     * const referral_settings = await prisma.referral_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends referral_settingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_settingsFindFirstArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Referral_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_settingsFindFirstOrThrowArgs} args - Arguments to find a Referral_settings
     * @example
     * // Get one Referral_settings
     * const referral_settings = await prisma.referral_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends referral_settingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_settingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Referral_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_settingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_settings
     * const referral_settings = await prisma.referral_settings.findMany()
     * 
     * // Get first 10 Referral_settings
     * const referral_settings = await prisma.referral_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referral_settingsWithIdOnly = await prisma.referral_settings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends referral_settingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_settingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Referral_settings.
     * @param {referral_settingsCreateArgs} args - Arguments to create a Referral_settings.
     * @example
     * // Create one Referral_settings
     * const Referral_settings = await prisma.referral_settings.create({
     *   data: {
     *     // ... data to create a Referral_settings
     *   }
     * })
     * 
    **/
    create<T extends referral_settingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, referral_settingsCreateArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Referral_settings.
     *     @param {referral_settingsCreateManyArgs} args - Arguments to create many Referral_settings.
     *     @example
     *     // Create many Referral_settings
     *     const referral_settings = await prisma.referral_settings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends referral_settingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_settingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral_settings.
     * @param {referral_settingsDeleteArgs} args - Arguments to delete one Referral_settings.
     * @example
     * // Delete one Referral_settings
     * const Referral_settings = await prisma.referral_settings.delete({
     *   where: {
     *     // ... filter to delete one Referral_settings
     *   }
     * })
     * 
    **/
    delete<T extends referral_settingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, referral_settingsDeleteArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Referral_settings.
     * @param {referral_settingsUpdateArgs} args - Arguments to update one Referral_settings.
     * @example
     * // Update one Referral_settings
     * const referral_settings = await prisma.referral_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends referral_settingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, referral_settingsUpdateArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Referral_settings.
     * @param {referral_settingsDeleteManyArgs} args - Arguments to filter Referral_settings to delete.
     * @example
     * // Delete a few Referral_settings
     * const { count } = await prisma.referral_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends referral_settingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, referral_settingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_settings
     * const referral_settings = await prisma.referral_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends referral_settingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, referral_settingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral_settings.
     * @param {referral_settingsUpsertArgs} args - Arguments to update or create a Referral_settings.
     * @example
     * // Update or create a Referral_settings
     * const referral_settings = await prisma.referral_settings.upsert({
     *   create: {
     *     // ... data to create a Referral_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_settings we want to update
     *   }
     * })
    **/
    upsert<T extends referral_settingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, referral_settingsUpsertArgs<ExtArgs>>
    ): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Referral_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_settingsCountArgs} args - Arguments to filter Referral_settings to count.
     * @example
     * // Count the number of Referral_settings
     * const count = await prisma.referral_settings.count({
     *   where: {
     *     // ... the filter for the Referral_settings we want to count
     *   }
     * })
    **/
    count<T extends referral_settingsCountArgs>(
      args?: Subset<T, referral_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_settingsAggregateArgs>(args: Subset<T, Referral_settingsAggregateArgs>): Prisma.PrismaPromise<GetReferral_settingsAggregateType<T>>

    /**
     * Group by Referral_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_settingsGroupByArgs['orderBy'] }
        : { orderBy?: referral_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_settings model
   */
  readonly fields: referral_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__referral_settingsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends referral_settings$userArgs<ExtArgs> = {}>(args?: Subset<T, referral_settings$userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the referral_settings model
   */ 
  interface referral_settingsFieldRefs {
    readonly id: FieldRef<"referral_settings", 'Int'>
    readonly cpa: FieldRef<"referral_settings", 'Int'>
    readonly rev_share_percent: FieldRef<"referral_settings", 'Int'>
    readonly referral_type: FieldRef<"referral_settings", 'String'>
  }
    

  // Custom InputTypes

  /**
   * referral_settings findUnique
   */
  export type referral_settingsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * Filter, which referral_settings to fetch.
     */
    where: referral_settingsWhereUniqueInput
  }


  /**
   * referral_settings findUniqueOrThrow
   */
  export type referral_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * Filter, which referral_settings to fetch.
     */
    where: referral_settingsWhereUniqueInput
  }


  /**
   * referral_settings findFirst
   */
  export type referral_settingsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * Filter, which referral_settings to fetch.
     */
    where?: referral_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_settings to fetch.
     */
    orderBy?: referral_settingsOrderByWithRelationInput | referral_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_settings.
     */
    cursor?: referral_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_settings.
     */
    distinct?: Referral_settingsScalarFieldEnum | Referral_settingsScalarFieldEnum[]
  }


  /**
   * referral_settings findFirstOrThrow
   */
  export type referral_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * Filter, which referral_settings to fetch.
     */
    where?: referral_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_settings to fetch.
     */
    orderBy?: referral_settingsOrderByWithRelationInput | referral_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_settings.
     */
    cursor?: referral_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_settings.
     */
    distinct?: Referral_settingsScalarFieldEnum | Referral_settingsScalarFieldEnum[]
  }


  /**
   * referral_settings findMany
   */
  export type referral_settingsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * Filter, which referral_settings to fetch.
     */
    where?: referral_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_settings to fetch.
     */
    orderBy?: referral_settingsOrderByWithRelationInput | referral_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_settings.
     */
    cursor?: referral_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_settings.
     */
    skip?: number
    distinct?: Referral_settingsScalarFieldEnum | Referral_settingsScalarFieldEnum[]
  }


  /**
   * referral_settings create
   */
  export type referral_settingsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a referral_settings.
     */
    data?: XOR<referral_settingsCreateInput, referral_settingsUncheckedCreateInput>
  }


  /**
   * referral_settings createMany
   */
  export type referral_settingsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_settings.
     */
    data: referral_settingsCreateManyInput | referral_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * referral_settings update
   */
  export type referral_settingsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a referral_settings.
     */
    data: XOR<referral_settingsUpdateInput, referral_settingsUncheckedUpdateInput>
    /**
     * Choose, which referral_settings to update.
     */
    where: referral_settingsWhereUniqueInput
  }


  /**
   * referral_settings updateMany
   */
  export type referral_settingsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_settings.
     */
    data: XOR<referral_settingsUpdateManyMutationInput, referral_settingsUncheckedUpdateManyInput>
    /**
     * Filter which referral_settings to update
     */
    where?: referral_settingsWhereInput
  }


  /**
   * referral_settings upsert
   */
  export type referral_settingsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the referral_settings to update in case it exists.
     */
    where: referral_settingsWhereUniqueInput
    /**
     * In case the referral_settings found by the `where` argument doesn't exist, create a new referral_settings with this data.
     */
    create: XOR<referral_settingsCreateInput, referral_settingsUncheckedCreateInput>
    /**
     * In case the referral_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_settingsUpdateInput, referral_settingsUncheckedUpdateInput>
  }


  /**
   * referral_settings delete
   */
  export type referral_settingsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    /**
     * Filter which referral_settings to delete.
     */
    where: referral_settingsWhereUniqueInput
  }


  /**
   * referral_settings deleteMany
   */
  export type referral_settingsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_settings to delete
     */
    where?: referral_settingsWhereInput
  }


  /**
   * referral_settings.user
   */
  export type referral_settings$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * referral_settings without action
   */
  export type referral_settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
  }



  /**
   * Model settings
   */


  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
    operations_id: number | null
    slot_settings_id: number | null
    client_id: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
    operations_id: number | null
    slot_settings_id: number | null
    client_id: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    operations_id: number | null
    slot_settings_id: number | null
    client_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    operations_id: number | null
    slot_settings_id: number | null
    client_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    operations_id: number
    slot_settings_id: number
    client_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
    operations_id?: true
    slot_settings_id?: true
    client_id?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
    operations_id?: true
    slot_settings_id?: true
    client_id?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    operations_id?: true
    slot_settings_id?: true
    client_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    operations_id?: true
    slot_settings_id?: true
    client_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    operations_id?: true
    slot_settings_id?: true
    client_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type settingsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithAggregationInput | settingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }


  export type SettingsGroupByOutputType = {
    id: number
    operations_id: number | null
    slot_settings_id: number | null
    client_id: number
    created_at: Date
    updated_at: Date
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operations_id?: boolean
    slot_settings_id?: boolean
    client_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_client_settings_idTosettings?: boolean | settings$client_client_settings_idTosettingsArgs<ExtArgs>
    layout_colors?: boolean | settings$layout_colorsArgs<ExtArgs>
    client_settings_client_idToclient?: boolean | clientArgs<ExtArgs>
    operations?: boolean | settings$operationsArgs<ExtArgs>
    slot_settings?: boolean | settings$slot_settingsArgs<ExtArgs>
    _count?: boolean | SettingsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectScalar = {
    id?: boolean
    operations_id?: boolean
    slot_settings_id?: boolean
    client_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type settingsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client_client_settings_idTosettings?: boolean | settings$client_client_settings_idTosettingsArgs<ExtArgs>
    layout_colors?: boolean | settings$layout_colorsArgs<ExtArgs>
    client_settings_client_idToclient?: boolean | clientArgs<ExtArgs>
    operations?: boolean | settings$operationsArgs<ExtArgs>
    slot_settings?: boolean | settings$slot_settingsArgs<ExtArgs>
    _count?: boolean | SettingsCountOutputTypeArgs<ExtArgs>
  }


  type settingsGetPayload<S extends boolean | null | undefined | settingsArgs> = $Types.GetResult<settingsPayload, S>

  type settingsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<settingsFindManyArgs, 'select' | 'include'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface settingsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settings'], meta: { name: 'settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends settingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, settingsFindUniqueArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Settings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, settingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends settingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, settingsFindFirstArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, settingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends settingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, settingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
    **/
    create<T extends settingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, settingsCreateArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Settings.
     *     @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     *     @example
     *     // Create many Settings
     *     const settings = await prisma.settings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends settingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, settingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
    **/
    delete<T extends settingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, settingsDeleteArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends settingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, settingsUpdateArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends settingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, settingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends settingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, settingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
    **/
    upsert<T extends settingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, settingsUpsertArgs<ExtArgs>>
    ): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingsGroupByArgs['orderBy'] }
        : { orderBy?: settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settings model
   */
  readonly fields: settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__settingsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client_client_settings_idTosettings<T extends settings$client_client_settings_idTosettingsArgs<ExtArgs> = {}>(args?: Subset<T, settings$client_client_settings_idTosettingsArgs<ExtArgs>>): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    layout_colors<T extends settings$layout_colorsArgs<ExtArgs> = {}>(args?: Subset<T, settings$layout_colorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<layout_colorsPayload<ExtArgs>, T, 'findMany'>| Null>;

    client_settings_client_idToclient<T extends clientArgs<ExtArgs> = {}>(args?: Subset<T, clientArgs<ExtArgs>>): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    operations<T extends settings$operationsArgs<ExtArgs> = {}>(args?: Subset<T, settings$operationsArgs<ExtArgs>>): Prisma__operationsClient<$Types.GetResult<operationsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    slot_settings<T extends settings$slot_settingsArgs<ExtArgs> = {}>(args?: Subset<T, settings$slot_settingsArgs<ExtArgs>>): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the settings model
   */ 
  interface settingsFieldRefs {
    readonly id: FieldRef<"settings", 'Int'>
    readonly operations_id: FieldRef<"settings", 'Int'>
    readonly slot_settings_id: FieldRef<"settings", 'Int'>
    readonly client_id: FieldRef<"settings", 'Int'>
    readonly created_at: FieldRef<"settings", 'DateTime'>
    readonly updated_at: FieldRef<"settings", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * settings findUnique
   */
  export type settingsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }


  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }


  /**
   * settings findFirst
   */
  export type settingsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }


  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }


  /**
   * settings findMany
   */
  export type settingsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }


  /**
   * settings create
   */
  export type settingsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a settings.
     */
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }


  /**
   * settings createMany
   */
  export type settingsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * settings update
   */
  export type settingsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput
  }


  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
  }


  /**
   * settings upsert
   */
  export type settingsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }


  /**
   * settings delete
   */
  export type settingsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput
  }


  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput
  }


  /**
   * settings.client_client_settings_idTosettings
   */
  export type settings$client_client_settings_idTosettingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client
     */
    select?: clientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clientInclude<ExtArgs> | null
    where?: clientWhereInput
  }


  /**
   * settings.layout_colors
   */
  export type settings$layout_colorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the layout_colors
     */
    select?: layout_colorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: layout_colorsInclude<ExtArgs> | null
    where?: layout_colorsWhereInput
    orderBy?: layout_colorsOrderByWithRelationInput | layout_colorsOrderByWithRelationInput[]
    cursor?: layout_colorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Layout_colorsScalarFieldEnum | Layout_colorsScalarFieldEnum[]
  }


  /**
   * settings.operations
   */
  export type settings$operationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operations
     */
    select?: operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operationsInclude<ExtArgs> | null
    where?: operationsWhereInput
  }


  /**
   * settings.slot_settings
   */
  export type settings$slot_settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    where?: slot_settingsWhereInput
  }


  /**
   * settings without action
   */
  export type settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
  }



  /**
   * Model slot_games
   */


  export type AggregateSlot_games = {
    _count: Slot_gamesCountAggregateOutputType | null
    _avg: Slot_gamesAvgAggregateOutputType | null
    _sum: Slot_gamesSumAggregateOutputType | null
    _min: Slot_gamesMinAggregateOutputType | null
    _max: Slot_gamesMaxAggregateOutputType | null
  }

  export type Slot_gamesAvgAggregateOutputType = {
    id: number | null
    provider_id: number | null
  }

  export type Slot_gamesSumAggregateOutputType = {
    id: number | null
    provider_id: number | null
  }

  export type Slot_gamesMinAggregateOutputType = {
    id: number | null
    provider_id: number | null
    uuid: string | null
    name: string | null
    image: string | null
    type: string | null
    has_lobby: boolean | null
    is_mobile: boolean | null
    has_freespins: boolean | null
    has_tables: boolean | null
    freespin_valid_until_full_day: boolean | null
    slug: string | null
  }

  export type Slot_gamesMaxAggregateOutputType = {
    id: number | null
    provider_id: number | null
    uuid: string | null
    name: string | null
    image: string | null
    type: string | null
    has_lobby: boolean | null
    is_mobile: boolean | null
    has_freespins: boolean | null
    has_tables: boolean | null
    freespin_valid_until_full_day: boolean | null
    slug: string | null
  }

  export type Slot_gamesCountAggregateOutputType = {
    id: number
    provider_id: number
    uuid: number
    name: number
    image: number
    type: number
    has_lobby: number
    is_mobile: number
    has_freespins: number
    has_tables: number
    freespin_valid_until_full_day: number
    slug: number
    _all: number
  }


  export type Slot_gamesAvgAggregateInputType = {
    id?: true
    provider_id?: true
  }

  export type Slot_gamesSumAggregateInputType = {
    id?: true
    provider_id?: true
  }

  export type Slot_gamesMinAggregateInputType = {
    id?: true
    provider_id?: true
    uuid?: true
    name?: true
    image?: true
    type?: true
    has_lobby?: true
    is_mobile?: true
    has_freespins?: true
    has_tables?: true
    freespin_valid_until_full_day?: true
    slug?: true
  }

  export type Slot_gamesMaxAggregateInputType = {
    id?: true
    provider_id?: true
    uuid?: true
    name?: true
    image?: true
    type?: true
    has_lobby?: true
    is_mobile?: true
    has_freespins?: true
    has_tables?: true
    freespin_valid_until_full_day?: true
    slug?: true
  }

  export type Slot_gamesCountAggregateInputType = {
    id?: true
    provider_id?: true
    uuid?: true
    name?: true
    image?: true
    type?: true
    has_lobby?: true
    is_mobile?: true
    has_freespins?: true
    has_tables?: true
    freespin_valid_until_full_day?: true
    slug?: true
    _all?: true
  }

  export type Slot_gamesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which slot_games to aggregate.
     */
    where?: slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_games to fetch.
     */
    orderBy?: slot_gamesOrderByWithRelationInput | slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned slot_games
    **/
    _count?: true | Slot_gamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Slot_gamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Slot_gamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Slot_gamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Slot_gamesMaxAggregateInputType
  }

  export type GetSlot_gamesAggregateType<T extends Slot_gamesAggregateArgs> = {
        [P in keyof T & keyof AggregateSlot_games]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlot_games[P]>
      : GetScalarType<T[P], AggregateSlot_games[P]>
  }




  export type slot_gamesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: slot_gamesWhereInput
    orderBy?: slot_gamesOrderByWithAggregationInput | slot_gamesOrderByWithAggregationInput[]
    by: Slot_gamesScalarFieldEnum[] | Slot_gamesScalarFieldEnum
    having?: slot_gamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Slot_gamesCountAggregateInputType | true
    _avg?: Slot_gamesAvgAggregateInputType
    _sum?: Slot_gamesSumAggregateInputType
    _min?: Slot_gamesMinAggregateInputType
    _max?: Slot_gamesMaxAggregateInputType
  }


  export type Slot_gamesGroupByOutputType = {
    id: number
    provider_id: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug: string | null
    _count: Slot_gamesCountAggregateOutputType | null
    _avg: Slot_gamesAvgAggregateOutputType | null
    _sum: Slot_gamesSumAggregateOutputType | null
    _min: Slot_gamesMinAggregateOutputType | null
    _max: Slot_gamesMaxAggregateOutputType | null
  }

  type GetSlot_gamesGroupByPayload<T extends slot_gamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Slot_gamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Slot_gamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Slot_gamesGroupByOutputType[P]>
            : GetScalarType<T[P], Slot_gamesGroupByOutputType[P]>
        }
      >
    >


  export type slot_gamesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    uuid?: boolean
    name?: boolean
    image?: boolean
    type?: boolean
    has_lobby?: boolean
    is_mobile?: boolean
    has_freespins?: boolean
    has_tables?: boolean
    freespin_valid_until_full_day?: boolean
    slug?: boolean
    bet_operations?: boolean | slot_games$bet_operationsArgs<ExtArgs>
    casino_most_popular_slot_games?: boolean | slot_games$casino_most_popular_slot_gamesArgs<ExtArgs>
    live_casino_most_popular_slot_games?: boolean | slot_games$live_casino_most_popular_slot_gamesArgs<ExtArgs>
    provider?: boolean | providerArgs<ExtArgs>
    _count?: boolean | Slot_gamesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["slot_games"]>

  export type slot_gamesSelectScalar = {
    id?: boolean
    provider_id?: boolean
    uuid?: boolean
    name?: boolean
    image?: boolean
    type?: boolean
    has_lobby?: boolean
    is_mobile?: boolean
    has_freespins?: boolean
    has_tables?: boolean
    freespin_valid_until_full_day?: boolean
    slug?: boolean
  }

  export type slot_gamesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bet_operations?: boolean | slot_games$bet_operationsArgs<ExtArgs>
    casino_most_popular_slot_games?: boolean | slot_games$casino_most_popular_slot_gamesArgs<ExtArgs>
    live_casino_most_popular_slot_games?: boolean | slot_games$live_casino_most_popular_slot_gamesArgs<ExtArgs>
    provider?: boolean | providerArgs<ExtArgs>
    _count?: boolean | Slot_gamesCountOutputTypeArgs<ExtArgs>
  }


  type slot_gamesGetPayload<S extends boolean | null | undefined | slot_gamesArgs> = $Types.GetResult<slot_gamesPayload, S>

  type slot_gamesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<slot_gamesFindManyArgs, 'select' | 'include'> & {
      select?: Slot_gamesCountAggregateInputType | true
    }

  export interface slot_gamesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['slot_games'], meta: { name: 'slot_games' } }
    /**
     * Find zero or one Slot_games that matches the filter.
     * @param {slot_gamesFindUniqueArgs} args - Arguments to find a Slot_games
     * @example
     * // Get one Slot_games
     * const slot_games = await prisma.slot_games.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends slot_gamesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, slot_gamesFindUniqueArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Slot_games that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {slot_gamesFindUniqueOrThrowArgs} args - Arguments to find a Slot_games
     * @example
     * // Get one Slot_games
     * const slot_games = await prisma.slot_games.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends slot_gamesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_gamesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Slot_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_gamesFindFirstArgs} args - Arguments to find a Slot_games
     * @example
     * // Get one Slot_games
     * const slot_games = await prisma.slot_games.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends slot_gamesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_gamesFindFirstArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Slot_games that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_gamesFindFirstOrThrowArgs} args - Arguments to find a Slot_games
     * @example
     * // Get one Slot_games
     * const slot_games = await prisma.slot_games.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends slot_gamesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_gamesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Slot_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_gamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slot_games
     * const slot_games = await prisma.slot_games.findMany()
     * 
     * // Get first 10 Slot_games
     * const slot_games = await prisma.slot_games.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slot_gamesWithIdOnly = await prisma.slot_games.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends slot_gamesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_gamesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Slot_games.
     * @param {slot_gamesCreateArgs} args - Arguments to create a Slot_games.
     * @example
     * // Create one Slot_games
     * const Slot_games = await prisma.slot_games.create({
     *   data: {
     *     // ... data to create a Slot_games
     *   }
     * })
     * 
    **/
    create<T extends slot_gamesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, slot_gamesCreateArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Slot_games.
     *     @param {slot_gamesCreateManyArgs} args - Arguments to create many Slot_games.
     *     @example
     *     // Create many Slot_games
     *     const slot_games = await prisma.slot_games.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends slot_gamesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_gamesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Slot_games.
     * @param {slot_gamesDeleteArgs} args - Arguments to delete one Slot_games.
     * @example
     * // Delete one Slot_games
     * const Slot_games = await prisma.slot_games.delete({
     *   where: {
     *     // ... filter to delete one Slot_games
     *   }
     * })
     * 
    **/
    delete<T extends slot_gamesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, slot_gamesDeleteArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Slot_games.
     * @param {slot_gamesUpdateArgs} args - Arguments to update one Slot_games.
     * @example
     * // Update one Slot_games
     * const slot_games = await prisma.slot_games.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends slot_gamesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, slot_gamesUpdateArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Slot_games.
     * @param {slot_gamesDeleteManyArgs} args - Arguments to filter Slot_games to delete.
     * @example
     * // Delete a few Slot_games
     * const { count } = await prisma.slot_games.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends slot_gamesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_gamesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_gamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slot_games
     * const slot_games = await prisma.slot_games.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends slot_gamesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, slot_gamesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Slot_games.
     * @param {slot_gamesUpsertArgs} args - Arguments to update or create a Slot_games.
     * @example
     * // Update or create a Slot_games
     * const slot_games = await prisma.slot_games.upsert({
     *   create: {
     *     // ... data to create a Slot_games
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slot_games we want to update
     *   }
     * })
    **/
    upsert<T extends slot_gamesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, slot_gamesUpsertArgs<ExtArgs>>
    ): Prisma__slot_gamesClient<$Types.GetResult<slot_gamesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_gamesCountArgs} args - Arguments to filter Slot_games to count.
     * @example
     * // Count the number of Slot_games
     * const count = await prisma.slot_games.count({
     *   where: {
     *     // ... the filter for the Slot_games we want to count
     *   }
     * })
    **/
    count<T extends slot_gamesCountArgs>(
      args?: Subset<T, slot_gamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Slot_gamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Slot_gamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Slot_gamesAggregateArgs>(args: Subset<T, Slot_gamesAggregateArgs>): Prisma.PrismaPromise<GetSlot_gamesAggregateType<T>>

    /**
     * Group by Slot_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_gamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends slot_gamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: slot_gamesGroupByArgs['orderBy'] }
        : { orderBy?: slot_gamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, slot_gamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlot_gamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the slot_games model
   */
  readonly fields: slot_gamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for slot_games.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__slot_gamesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bet_operations<T extends slot_games$bet_operationsArgs<ExtArgs> = {}>(args?: Subset<T, slot_games$bet_operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'findMany'>| Null>;

    casino_most_popular_slot_games<T extends slot_games$casino_most_popular_slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, slot_games$casino_most_popular_slot_gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findMany'>| Null>;

    live_casino_most_popular_slot_games<T extends slot_games$live_casino_most_popular_slot_gamesArgs<ExtArgs> = {}>(args?: Subset<T, slot_games$live_casino_most_popular_slot_gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<live_casino_most_popular_slot_gamesPayload<ExtArgs>, T, 'findMany'>| Null>;

    provider<T extends providerArgs<ExtArgs> = {}>(args?: Subset<T, providerArgs<ExtArgs>>): Prisma__providerClient<$Types.GetResult<providerPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the slot_games model
   */ 
  interface slot_gamesFieldRefs {
    readonly id: FieldRef<"slot_games", 'Int'>
    readonly provider_id: FieldRef<"slot_games", 'Int'>
    readonly uuid: FieldRef<"slot_games", 'String'>
    readonly name: FieldRef<"slot_games", 'String'>
    readonly image: FieldRef<"slot_games", 'String'>
    readonly type: FieldRef<"slot_games", 'String'>
    readonly has_lobby: FieldRef<"slot_games", 'Boolean'>
    readonly is_mobile: FieldRef<"slot_games", 'Boolean'>
    readonly has_freespins: FieldRef<"slot_games", 'Boolean'>
    readonly has_tables: FieldRef<"slot_games", 'Boolean'>
    readonly freespin_valid_until_full_day: FieldRef<"slot_games", 'Boolean'>
    readonly slug: FieldRef<"slot_games", 'String'>
  }
    

  // Custom InputTypes

  /**
   * slot_games findUnique
   */
  export type slot_gamesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which slot_games to fetch.
     */
    where: slot_gamesWhereUniqueInput
  }


  /**
   * slot_games findUniqueOrThrow
   */
  export type slot_gamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which slot_games to fetch.
     */
    where: slot_gamesWhereUniqueInput
  }


  /**
   * slot_games findFirst
   */
  export type slot_gamesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which slot_games to fetch.
     */
    where?: slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_games to fetch.
     */
    orderBy?: slot_gamesOrderByWithRelationInput | slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slot_games.
     */
    cursor?: slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slot_games.
     */
    distinct?: Slot_gamesScalarFieldEnum | Slot_gamesScalarFieldEnum[]
  }


  /**
   * slot_games findFirstOrThrow
   */
  export type slot_gamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which slot_games to fetch.
     */
    where?: slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_games to fetch.
     */
    orderBy?: slot_gamesOrderByWithRelationInput | slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slot_games.
     */
    cursor?: slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slot_games.
     */
    distinct?: Slot_gamesScalarFieldEnum | Slot_gamesScalarFieldEnum[]
  }


  /**
   * slot_games findMany
   */
  export type slot_gamesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * Filter, which slot_games to fetch.
     */
    where?: slot_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_games to fetch.
     */
    orderBy?: slot_gamesOrderByWithRelationInput | slot_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing slot_games.
     */
    cursor?: slot_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_games.
     */
    skip?: number
    distinct?: Slot_gamesScalarFieldEnum | Slot_gamesScalarFieldEnum[]
  }


  /**
   * slot_games create
   */
  export type slot_gamesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * The data needed to create a slot_games.
     */
    data: XOR<slot_gamesCreateInput, slot_gamesUncheckedCreateInput>
  }


  /**
   * slot_games createMany
   */
  export type slot_gamesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many slot_games.
     */
    data: slot_gamesCreateManyInput | slot_gamesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * slot_games update
   */
  export type slot_gamesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * The data needed to update a slot_games.
     */
    data: XOR<slot_gamesUpdateInput, slot_gamesUncheckedUpdateInput>
    /**
     * Choose, which slot_games to update.
     */
    where: slot_gamesWhereUniqueInput
  }


  /**
   * slot_games updateMany
   */
  export type slot_gamesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update slot_games.
     */
    data: XOR<slot_gamesUpdateManyMutationInput, slot_gamesUncheckedUpdateManyInput>
    /**
     * Filter which slot_games to update
     */
    where?: slot_gamesWhereInput
  }


  /**
   * slot_games upsert
   */
  export type slot_gamesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * The filter to search for the slot_games to update in case it exists.
     */
    where: slot_gamesWhereUniqueInput
    /**
     * In case the slot_games found by the `where` argument doesn't exist, create a new slot_games with this data.
     */
    create: XOR<slot_gamesCreateInput, slot_gamesUncheckedCreateInput>
    /**
     * In case the slot_games was found with the provided `where` argument, update it with this data.
     */
    update: XOR<slot_gamesUpdateInput, slot_gamesUncheckedUpdateInput>
  }


  /**
   * slot_games delete
   */
  export type slot_gamesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
    /**
     * Filter which slot_games to delete.
     */
    where: slot_gamesWhereUniqueInput
  }


  /**
   * slot_games deleteMany
   */
  export type slot_gamesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which slot_games to delete
     */
    where?: slot_gamesWhereInput
  }


  /**
   * slot_games.bet_operations
   */
  export type slot_games$bet_operationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    where?: bet_operationsWhereInput
    orderBy?: bet_operationsOrderByWithRelationInput | bet_operationsOrderByWithRelationInput[]
    cursor?: bet_operationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bet_operationsScalarFieldEnum | Bet_operationsScalarFieldEnum[]
  }


  /**
   * slot_games.casino_most_popular_slot_games
   */
  export type slot_games$casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular_slot_games
     */
    select?: casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popular_slot_gamesInclude<ExtArgs> | null
    where?: casino_most_popular_slot_gamesWhereInput
    orderBy?: casino_most_popular_slot_gamesOrderByWithRelationInput | casino_most_popular_slot_gamesOrderByWithRelationInput[]
    cursor?: casino_most_popular_slot_gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Casino_most_popular_slot_gamesScalarFieldEnum | Casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * slot_games.live_casino_most_popular_slot_games
   */
  export type slot_games$live_casino_most_popular_slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular_slot_games
     */
    select?: live_casino_most_popular_slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popular_slot_gamesInclude<ExtArgs> | null
    where?: live_casino_most_popular_slot_gamesWhereInput
    orderBy?: live_casino_most_popular_slot_gamesOrderByWithRelationInput | live_casino_most_popular_slot_gamesOrderByWithRelationInput[]
    cursor?: live_casino_most_popular_slot_gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Live_casino_most_popular_slot_gamesScalarFieldEnum | Live_casino_most_popular_slot_gamesScalarFieldEnum[]
  }


  /**
   * slot_games without action
   */
  export type slot_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_games
     */
    select?: slot_gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_gamesInclude<ExtArgs> | null
  }



  /**
   * Model slot_settings
   */


  export type AggregateSlot_settings = {
    _count: Slot_settingsCountAggregateOutputType | null
    _avg: Slot_settingsAvgAggregateOutputType | null
    _sum: Slot_settingsSumAggregateOutputType | null
    _min: Slot_settingsMinAggregateOutputType | null
    _max: Slot_settingsMaxAggregateOutputType | null
  }

  export type Slot_settingsAvgAggregateOutputType = {
    id: number | null
    casino_most_popular_id: number | null
    live_casino_most_popular_id: number | null
  }

  export type Slot_settingsSumAggregateOutputType = {
    id: number | null
    casino_most_popular_id: number | null
    live_casino_most_popular_id: number | null
  }

  export type Slot_settingsMinAggregateOutputType = {
    id: number | null
    casino_most_popular_id: number | null
    live_casino_most_popular_id: number | null
  }

  export type Slot_settingsMaxAggregateOutputType = {
    id: number | null
    casino_most_popular_id: number | null
    live_casino_most_popular_id: number | null
  }

  export type Slot_settingsCountAggregateOutputType = {
    id: number
    casino_most_popular_id: number
    live_casino_most_popular_id: number
    _all: number
  }


  export type Slot_settingsAvgAggregateInputType = {
    id?: true
    casino_most_popular_id?: true
    live_casino_most_popular_id?: true
  }

  export type Slot_settingsSumAggregateInputType = {
    id?: true
    casino_most_popular_id?: true
    live_casino_most_popular_id?: true
  }

  export type Slot_settingsMinAggregateInputType = {
    id?: true
    casino_most_popular_id?: true
    live_casino_most_popular_id?: true
  }

  export type Slot_settingsMaxAggregateInputType = {
    id?: true
    casino_most_popular_id?: true
    live_casino_most_popular_id?: true
  }

  export type Slot_settingsCountAggregateInputType = {
    id?: true
    casino_most_popular_id?: true
    live_casino_most_popular_id?: true
    _all?: true
  }

  export type Slot_settingsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which slot_settings to aggregate.
     */
    where?: slot_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_settings to fetch.
     */
    orderBy?: slot_settingsOrderByWithRelationInput | slot_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: slot_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned slot_settings
    **/
    _count?: true | Slot_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Slot_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Slot_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Slot_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Slot_settingsMaxAggregateInputType
  }

  export type GetSlot_settingsAggregateType<T extends Slot_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSlot_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlot_settings[P]>
      : GetScalarType<T[P], AggregateSlot_settings[P]>
  }




  export type slot_settingsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: slot_settingsWhereInput
    orderBy?: slot_settingsOrderByWithAggregationInput | slot_settingsOrderByWithAggregationInput[]
    by: Slot_settingsScalarFieldEnum[] | Slot_settingsScalarFieldEnum
    having?: slot_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Slot_settingsCountAggregateInputType | true
    _avg?: Slot_settingsAvgAggregateInputType
    _sum?: Slot_settingsSumAggregateInputType
    _min?: Slot_settingsMinAggregateInputType
    _max?: Slot_settingsMaxAggregateInputType
  }


  export type Slot_settingsGroupByOutputType = {
    id: number
    casino_most_popular_id: number | null
    live_casino_most_popular_id: number | null
    _count: Slot_settingsCountAggregateOutputType | null
    _avg: Slot_settingsAvgAggregateOutputType | null
    _sum: Slot_settingsSumAggregateOutputType | null
    _min: Slot_settingsMinAggregateOutputType | null
    _max: Slot_settingsMaxAggregateOutputType | null
  }

  type GetSlot_settingsGroupByPayload<T extends slot_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Slot_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Slot_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Slot_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Slot_settingsGroupByOutputType[P]>
        }
      >
    >


  export type slot_settingsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    casino_most_popular_id?: boolean
    live_casino_most_popular_id?: boolean
    banner_more_profitable?: boolean | slot_settings$banner_more_profitableArgs<ExtArgs>
    settings?: boolean | slot_settings$settingsArgs<ExtArgs>
    live_casino_most_popular?: boolean | slot_settings$live_casino_most_popularArgs<ExtArgs>
    casino_most_popular?: boolean | slot_settings$casino_most_popularArgs<ExtArgs>
    _count?: boolean | Slot_settingsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["slot_settings"]>

  export type slot_settingsSelectScalar = {
    id?: boolean
    casino_most_popular_id?: boolean
    live_casino_most_popular_id?: boolean
  }

  export type slot_settingsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    banner_more_profitable?: boolean | slot_settings$banner_more_profitableArgs<ExtArgs>
    settings?: boolean | slot_settings$settingsArgs<ExtArgs>
    live_casino_most_popular?: boolean | slot_settings$live_casino_most_popularArgs<ExtArgs>
    casino_most_popular?: boolean | slot_settings$casino_most_popularArgs<ExtArgs>
    _count?: boolean | Slot_settingsCountOutputTypeArgs<ExtArgs>
  }


  type slot_settingsGetPayload<S extends boolean | null | undefined | slot_settingsArgs> = $Types.GetResult<slot_settingsPayload, S>

  type slot_settingsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<slot_settingsFindManyArgs, 'select' | 'include'> & {
      select?: Slot_settingsCountAggregateInputType | true
    }

  export interface slot_settingsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['slot_settings'], meta: { name: 'slot_settings' } }
    /**
     * Find zero or one Slot_settings that matches the filter.
     * @param {slot_settingsFindUniqueArgs} args - Arguments to find a Slot_settings
     * @example
     * // Get one Slot_settings
     * const slot_settings = await prisma.slot_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends slot_settingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, slot_settingsFindUniqueArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Slot_settings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {slot_settingsFindUniqueOrThrowArgs} args - Arguments to find a Slot_settings
     * @example
     * // Get one Slot_settings
     * const slot_settings = await prisma.slot_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends slot_settingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_settingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Slot_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_settingsFindFirstArgs} args - Arguments to find a Slot_settings
     * @example
     * // Get one Slot_settings
     * const slot_settings = await prisma.slot_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends slot_settingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_settingsFindFirstArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Slot_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_settingsFindFirstOrThrowArgs} args - Arguments to find a Slot_settings
     * @example
     * // Get one Slot_settings
     * const slot_settings = await prisma.slot_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends slot_settingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_settingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Slot_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_settingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slot_settings
     * const slot_settings = await prisma.slot_settings.findMany()
     * 
     * // Get first 10 Slot_settings
     * const slot_settings = await prisma.slot_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slot_settingsWithIdOnly = await prisma.slot_settings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends slot_settingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_settingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Slot_settings.
     * @param {slot_settingsCreateArgs} args - Arguments to create a Slot_settings.
     * @example
     * // Create one Slot_settings
     * const Slot_settings = await prisma.slot_settings.create({
     *   data: {
     *     // ... data to create a Slot_settings
     *   }
     * })
     * 
    **/
    create<T extends slot_settingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, slot_settingsCreateArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Slot_settings.
     *     @param {slot_settingsCreateManyArgs} args - Arguments to create many Slot_settings.
     *     @example
     *     // Create many Slot_settings
     *     const slot_settings = await prisma.slot_settings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends slot_settingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_settingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Slot_settings.
     * @param {slot_settingsDeleteArgs} args - Arguments to delete one Slot_settings.
     * @example
     * // Delete one Slot_settings
     * const Slot_settings = await prisma.slot_settings.delete({
     *   where: {
     *     // ... filter to delete one Slot_settings
     *   }
     * })
     * 
    **/
    delete<T extends slot_settingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, slot_settingsDeleteArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Slot_settings.
     * @param {slot_settingsUpdateArgs} args - Arguments to update one Slot_settings.
     * @example
     * // Update one Slot_settings
     * const slot_settings = await prisma.slot_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends slot_settingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, slot_settingsUpdateArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Slot_settings.
     * @param {slot_settingsDeleteManyArgs} args - Arguments to filter Slot_settings to delete.
     * @example
     * // Delete a few Slot_settings
     * const { count } = await prisma.slot_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends slot_settingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, slot_settingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slot_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slot_settings
     * const slot_settings = await prisma.slot_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends slot_settingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, slot_settingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Slot_settings.
     * @param {slot_settingsUpsertArgs} args - Arguments to update or create a Slot_settings.
     * @example
     * // Update or create a Slot_settings
     * const slot_settings = await prisma.slot_settings.upsert({
     *   create: {
     *     // ... data to create a Slot_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slot_settings we want to update
     *   }
     * })
    **/
    upsert<T extends slot_settingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, slot_settingsUpsertArgs<ExtArgs>>
    ): Prisma__slot_settingsClient<$Types.GetResult<slot_settingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Slot_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_settingsCountArgs} args - Arguments to filter Slot_settings to count.
     * @example
     * // Count the number of Slot_settings
     * const count = await prisma.slot_settings.count({
     *   where: {
     *     // ... the filter for the Slot_settings we want to count
     *   }
     * })
    **/
    count<T extends slot_settingsCountArgs>(
      args?: Subset<T, slot_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Slot_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slot_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Slot_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Slot_settingsAggregateArgs>(args: Subset<T, Slot_settingsAggregateArgs>): Prisma.PrismaPromise<GetSlot_settingsAggregateType<T>>

    /**
     * Group by Slot_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends slot_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: slot_settingsGroupByArgs['orderBy'] }
        : { orderBy?: slot_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, slot_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlot_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the slot_settings model
   */
  readonly fields: slot_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for slot_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__slot_settingsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    banner_more_profitable<T extends slot_settings$banner_more_profitableArgs<ExtArgs> = {}>(args?: Subset<T, slot_settings$banner_more_profitableArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<banner_more_profitablePayload<ExtArgs>, T, 'findMany'>| Null>;

    settings<T extends slot_settings$settingsArgs<ExtArgs> = {}>(args?: Subset<T, slot_settings$settingsArgs<ExtArgs>>): Prisma__settingsClient<$Types.GetResult<settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    live_casino_most_popular<T extends slot_settings$live_casino_most_popularArgs<ExtArgs> = {}>(args?: Subset<T, slot_settings$live_casino_most_popularArgs<ExtArgs>>): Prisma__live_casino_most_popularClient<$Types.GetResult<live_casino_most_popularPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    casino_most_popular<T extends slot_settings$casino_most_popularArgs<ExtArgs> = {}>(args?: Subset<T, slot_settings$casino_most_popularArgs<ExtArgs>>): Prisma__casino_most_popularClient<$Types.GetResult<casino_most_popularPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the slot_settings model
   */ 
  interface slot_settingsFieldRefs {
    readonly id: FieldRef<"slot_settings", 'Int'>
    readonly casino_most_popular_id: FieldRef<"slot_settings", 'Int'>
    readonly live_casino_most_popular_id: FieldRef<"slot_settings", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * slot_settings findUnique
   */
  export type slot_settingsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * Filter, which slot_settings to fetch.
     */
    where: slot_settingsWhereUniqueInput
  }


  /**
   * slot_settings findUniqueOrThrow
   */
  export type slot_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * Filter, which slot_settings to fetch.
     */
    where: slot_settingsWhereUniqueInput
  }


  /**
   * slot_settings findFirst
   */
  export type slot_settingsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * Filter, which slot_settings to fetch.
     */
    where?: slot_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_settings to fetch.
     */
    orderBy?: slot_settingsOrderByWithRelationInput | slot_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slot_settings.
     */
    cursor?: slot_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slot_settings.
     */
    distinct?: Slot_settingsScalarFieldEnum | Slot_settingsScalarFieldEnum[]
  }


  /**
   * slot_settings findFirstOrThrow
   */
  export type slot_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * Filter, which slot_settings to fetch.
     */
    where?: slot_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_settings to fetch.
     */
    orderBy?: slot_settingsOrderByWithRelationInput | slot_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slot_settings.
     */
    cursor?: slot_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slot_settings.
     */
    distinct?: Slot_settingsScalarFieldEnum | Slot_settingsScalarFieldEnum[]
  }


  /**
   * slot_settings findMany
   */
  export type slot_settingsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * Filter, which slot_settings to fetch.
     */
    where?: slot_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_settings to fetch.
     */
    orderBy?: slot_settingsOrderByWithRelationInput | slot_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing slot_settings.
     */
    cursor?: slot_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_settings.
     */
    skip?: number
    distinct?: Slot_settingsScalarFieldEnum | Slot_settingsScalarFieldEnum[]
  }


  /**
   * slot_settings create
   */
  export type slot_settingsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a slot_settings.
     */
    data?: XOR<slot_settingsCreateInput, slot_settingsUncheckedCreateInput>
  }


  /**
   * slot_settings createMany
   */
  export type slot_settingsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many slot_settings.
     */
    data: slot_settingsCreateManyInput | slot_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * slot_settings update
   */
  export type slot_settingsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a slot_settings.
     */
    data: XOR<slot_settingsUpdateInput, slot_settingsUncheckedUpdateInput>
    /**
     * Choose, which slot_settings to update.
     */
    where: slot_settingsWhereUniqueInput
  }


  /**
   * slot_settings updateMany
   */
  export type slot_settingsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update slot_settings.
     */
    data: XOR<slot_settingsUpdateManyMutationInput, slot_settingsUncheckedUpdateManyInput>
    /**
     * Filter which slot_settings to update
     */
    where?: slot_settingsWhereInput
  }


  /**
   * slot_settings upsert
   */
  export type slot_settingsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the slot_settings to update in case it exists.
     */
    where: slot_settingsWhereUniqueInput
    /**
     * In case the slot_settings found by the `where` argument doesn't exist, create a new slot_settings with this data.
     */
    create: XOR<slot_settingsCreateInput, slot_settingsUncheckedCreateInput>
    /**
     * In case the slot_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<slot_settingsUpdateInput, slot_settingsUncheckedUpdateInput>
  }


  /**
   * slot_settings delete
   */
  export type slot_settingsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
    /**
     * Filter which slot_settings to delete.
     */
    where: slot_settingsWhereUniqueInput
  }


  /**
   * slot_settings deleteMany
   */
  export type slot_settingsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which slot_settings to delete
     */
    where?: slot_settingsWhereInput
  }


  /**
   * slot_settings.banner_more_profitable
   */
  export type slot_settings$banner_more_profitableArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner_more_profitable
     */
    select?: banner_more_profitableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: banner_more_profitableInclude<ExtArgs> | null
    where?: banner_more_profitableWhereInput
    orderBy?: banner_more_profitableOrderByWithRelationInput | banner_more_profitableOrderByWithRelationInput[]
    cursor?: banner_more_profitableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Banner_more_profitableScalarFieldEnum | Banner_more_profitableScalarFieldEnum[]
  }


  /**
   * slot_settings.settings
   */
  export type slot_settings$settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude<ExtArgs> | null
    where?: settingsWhereInput
  }


  /**
   * slot_settings.live_casino_most_popular
   */
  export type slot_settings$live_casino_most_popularArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the live_casino_most_popular
     */
    select?: live_casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: live_casino_most_popularInclude<ExtArgs> | null
    where?: live_casino_most_popularWhereInput
  }


  /**
   * slot_settings.casino_most_popular
   */
  export type slot_settings$casino_most_popularArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the casino_most_popular
     */
    select?: casino_most_popularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: casino_most_popularInclude<ExtArgs> | null
    where?: casino_most_popularWhereInput
  }


  /**
   * slot_settings without action
   */
  export type slot_settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_settings
     */
    select?: slot_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: slot_settingsInclude<ExtArgs> | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    client_id: number | null
    referral_id: number | null
    referral_settings_id: number | null
    external_id: number | null
    balance: Decimal | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    client_id: number | null
    referral_id: number | null
    referral_settings_id: number | null
    external_id: number | null
    balance: Decimal | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    client_id: number | null
    referral_id: number | null
    referral_settings_id: number | null
    external_id: number | null
    username: string | null
    balance: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    session: string | null
    cpa_collected: boolean | null
    is_referrer: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    client_id: number | null
    referral_id: number | null
    referral_settings_id: number | null
    external_id: number | null
    username: string | null
    balance: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    session: string | null
    cpa_collected: boolean | null
    is_referrer: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    wallet_id: number
    client_id: number
    referral_id: number
    referral_settings_id: number
    external_id: number
    username: number
    balance: number
    created_at: number
    updated_at: number
    session: number
    cpa_collected: number
    is_referrer: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    wallet_id?: true
    client_id?: true
    referral_id?: true
    referral_settings_id?: true
    external_id?: true
    balance?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    wallet_id?: true
    client_id?: true
    referral_id?: true
    referral_settings_id?: true
    external_id?: true
    balance?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    wallet_id?: true
    client_id?: true
    referral_id?: true
    referral_settings_id?: true
    external_id?: true
    username?: true
    balance?: true
    created_at?: true
    updated_at?: true
    session?: true
    cpa_collected?: true
    is_referrer?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    wallet_id?: true
    client_id?: true
    referral_id?: true
    referral_settings_id?: true
    external_id?: true
    username?: true
    balance?: true
    created_at?: true
    updated_at?: true
    session?: true
    cpa_collected?: true
    is_referrer?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    wallet_id?: true
    client_id?: true
    referral_id?: true
    referral_settings_id?: true
    external_id?: true
    username?: true
    balance?: true
    created_at?: true
    updated_at?: true
    session?: true
    cpa_collected?: true
    is_referrer?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    wallet_id: number
    client_id: number
    referral_id: number | null
    referral_settings_id: number | null
    external_id: number
    username: string
    balance: Decimal | null
    created_at: Date
    updated_at: Date
    session: string | null
    cpa_collected: boolean | null
    is_referrer: boolean | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_id?: boolean
    client_id?: boolean
    referral_id?: boolean
    referral_settings_id?: boolean
    external_id?: boolean
    username?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
    session?: boolean
    cpa_collected?: boolean
    is_referrer?: boolean
    bet_operations?: boolean | user$bet_operationsArgs<ExtArgs>
    referral_history_referral_history_referral_idTouser?: boolean | user$referral_history_referral_history_referral_idTouserArgs<ExtArgs>
    referral_history_referral_history_user_idTouser?: boolean | user$referral_history_referral_history_user_idTouserArgs<ExtArgs>
    client?: boolean | clientArgs<ExtArgs>
    user?: boolean | user$userArgs<ExtArgs>
    other_user?: boolean | user$other_userArgs<ExtArgs>
    referral_settings?: boolean | user$referral_settingsArgs<ExtArgs>
    wallet?: boolean | walletArgs<ExtArgs>
    wallet_transaction?: boolean | user$wallet_transactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    wallet_id?: boolean
    client_id?: boolean
    referral_id?: boolean
    referral_settings_id?: boolean
    external_id?: boolean
    username?: boolean
    balance?: boolean
    created_at?: boolean
    updated_at?: boolean
    session?: boolean
    cpa_collected?: boolean
    is_referrer?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bet_operations?: boolean | user$bet_operationsArgs<ExtArgs>
    referral_history_referral_history_referral_idTouser?: boolean | user$referral_history_referral_history_referral_idTouserArgs<ExtArgs>
    referral_history_referral_history_user_idTouser?: boolean | user$referral_history_referral_history_user_idTouserArgs<ExtArgs>
    client?: boolean | clientArgs<ExtArgs>
    user?: boolean | user$userArgs<ExtArgs>
    other_user?: boolean | user$other_userArgs<ExtArgs>
    referral_settings?: boolean | user$referral_settingsArgs<ExtArgs>
    wallet?: boolean | walletArgs<ExtArgs>
    wallet_transaction?: boolean | user$wallet_transactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type userGetPayload<S extends boolean | null | undefined | userArgs> = $Types.GetResult<userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bet_operations<T extends user$bet_operationsArgs<ExtArgs> = {}>(args?: Subset<T, user$bet_operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<bet_operationsPayload<ExtArgs>, T, 'findMany'>| Null>;

    referral_history_referral_history_referral_idTouser<T extends user$referral_history_referral_history_referral_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$referral_history_referral_history_referral_idTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'findMany'>| Null>;

    referral_history_referral_history_user_idTouser<T extends user$referral_history_referral_history_user_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$referral_history_referral_history_user_idTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<referral_historyPayload<ExtArgs>, T, 'findMany'>| Null>;

    client<T extends clientArgs<ExtArgs> = {}>(args?: Subset<T, clientArgs<ExtArgs>>): Prisma__clientClient<$Types.GetResult<clientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    user<T extends user$userArgs<ExtArgs> = {}>(args?: Subset<T, user$userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    other_user<T extends user$other_userArgs<ExtArgs> = {}>(args?: Subset<T, user$other_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany'>| Null>;

    referral_settings<T extends user$referral_settingsArgs<ExtArgs> = {}>(args?: Subset<T, user$referral_settingsArgs<ExtArgs>>): Prisma__referral_settingsClient<$Types.GetResult<referral_settingsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    wallet<T extends walletArgs<ExtArgs> = {}>(args?: Subset<T, walletArgs<ExtArgs>>): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    wallet_transaction<T extends user$wallet_transactionArgs<ExtArgs> = {}>(args?: Subset<T, user$wallet_transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly wallet_id: FieldRef<"user", 'Int'>
    readonly client_id: FieldRef<"user", 'Int'>
    readonly referral_id: FieldRef<"user", 'Int'>
    readonly referral_settings_id: FieldRef<"user", 'Int'>
    readonly external_id: FieldRef<"user", 'Int'>
    readonly username: FieldRef<"user", 'String'>
    readonly balance: FieldRef<"user", 'Decimal'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly session: FieldRef<"user", 'String'>
    readonly cpa_collected: FieldRef<"user", 'Boolean'>
    readonly is_referrer: FieldRef<"user", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.bet_operations
   */
  export type user$bet_operationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bet_operations
     */
    select?: bet_operationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bet_operationsInclude<ExtArgs> | null
    where?: bet_operationsWhereInput
    orderBy?: bet_operationsOrderByWithRelationInput | bet_operationsOrderByWithRelationInput[]
    cursor?: bet_operationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bet_operationsScalarFieldEnum | Bet_operationsScalarFieldEnum[]
  }


  /**
   * user.referral_history_referral_history_referral_idTouser
   */
  export type user$referral_history_referral_history_referral_idTouserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    where?: referral_historyWhereInput
    orderBy?: referral_historyOrderByWithRelationInput | referral_historyOrderByWithRelationInput[]
    cursor?: referral_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Referral_historyScalarFieldEnum | Referral_historyScalarFieldEnum[]
  }


  /**
   * user.referral_history_referral_history_user_idTouser
   */
  export type user$referral_history_referral_history_user_idTouserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_history
     */
    select?: referral_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_historyInclude<ExtArgs> | null
    where?: referral_historyWhereInput
    orderBy?: referral_historyOrderByWithRelationInput | referral_historyOrderByWithRelationInput[]
    cursor?: referral_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Referral_historyScalarFieldEnum | Referral_historyScalarFieldEnum[]
  }


  /**
   * user.user
   */
  export type user$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * user.other_user
   */
  export type user$other_userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user.referral_settings
   */
  export type user$referral_settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_settings
     */
    select?: referral_settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: referral_settingsInclude<ExtArgs> | null
    where?: referral_settingsWhereInput
  }


  /**
   * user.wallet_transaction
   */
  export type user$wallet_transactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    where?: wallet_transactionWhereInput
    orderBy?: wallet_transactionOrderByWithRelationInput | wallet_transactionOrderByWithRelationInput[]
    cursor?: wallet_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Wallet_transactionScalarFieldEnum | Wallet_transactionScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model wallet
   */


  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    id: number | null
    balance: number | null
    bonus: number | null
    bet: number | null
    withdraw: number | null
    deposit: number | null
  }

  export type WalletSumAggregateOutputType = {
    id: number | null
    balance: number | null
    bonus: number | null
    bet: number | null
    withdraw: number | null
    deposit: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: number | null
    balance: number | null
    bonus: number | null
    bet: number | null
    withdraw: number | null
    deposit: number | null
  }

  export type WalletMaxAggregateOutputType = {
    id: number | null
    balance: number | null
    bonus: number | null
    bet: number | null
    withdraw: number | null
    deposit: number | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    balance: number
    bonus: number
    bet: number
    withdraw: number
    deposit: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    id?: true
    balance?: true
    bonus?: true
    bet?: true
    withdraw?: true
    deposit?: true
  }

  export type WalletSumAggregateInputType = {
    id?: true
    balance?: true
    bonus?: true
    bet?: true
    withdraw?: true
    deposit?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    balance?: true
    bonus?: true
    bet?: true
    withdraw?: true
    deposit?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    balance?: true
    bonus?: true
    bet?: true
    withdraw?: true
    deposit?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    balance?: true
    bonus?: true
    bet?: true
    withdraw?: true
    deposit?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet to aggregate.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type walletGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
    orderBy?: walletOrderByWithAggregationInput | walletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: walletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }


  export type WalletGroupByOutputType = {
    id: number
    balance: number | null
    bonus: number | null
    bet: number | null
    withdraw: number | null
    deposit: number | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends walletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type walletSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    bonus?: boolean
    bet?: boolean
    withdraw?: boolean
    deposit?: boolean
    user?: boolean | wallet$userArgs<ExtArgs>
    wallet_transaction?: boolean | wallet$wallet_transactionArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type walletSelectScalar = {
    id?: boolean
    balance?: boolean
    bonus?: boolean
    bet?: boolean
    withdraw?: boolean
    deposit?: boolean
  }

  export type walletInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | wallet$userArgs<ExtArgs>
    wallet_transaction?: boolean | wallet$wallet_transactionArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeArgs<ExtArgs>
  }


  type walletGetPayload<S extends boolean | null | undefined | walletArgs> = $Types.GetResult<walletPayload, S>

  type walletCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<walletFindManyArgs, 'select' | 'include'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface walletDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet'], meta: { name: 'wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {walletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends walletFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, walletFindUniqueArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {walletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends walletFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends walletFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindFirstArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends walletFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends walletFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<walletPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Wallet.
     * @param {walletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
    **/
    create<T extends walletCreateArgs<ExtArgs>>(
      args: SelectSubset<T, walletCreateArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Wallets.
     *     @param {walletCreateManyArgs} args - Arguments to create many Wallets.
     *     @example
     *     // Create many Wallets
     *     const wallet = await prisma.wallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends walletCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {walletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
    **/
    delete<T extends walletDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, walletDeleteArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {walletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends walletUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpdateArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {walletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends walletDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, walletDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends walletUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {walletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
    **/
    upsert<T extends walletUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, walletUpsertArgs<ExtArgs>>
    ): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletCountArgs>(
      args?: Subset<T, walletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletGroupByArgs['orderBy'] }
        : { orderBy?: walletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet model
   */
  readonly fields: walletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__walletClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends wallet$userArgs<ExtArgs> = {}>(args?: Subset<T, wallet$userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    wallet_transaction<T extends wallet$wallet_transactionArgs<ExtArgs> = {}>(args?: Subset<T, wallet$wallet_transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the wallet model
   */ 
  interface walletFieldRefs {
    readonly id: FieldRef<"wallet", 'Int'>
    readonly balance: FieldRef<"wallet", 'Float'>
    readonly bonus: FieldRef<"wallet", 'Float'>
    readonly bet: FieldRef<"wallet", 'Float'>
    readonly withdraw: FieldRef<"wallet", 'Float'>
    readonly deposit: FieldRef<"wallet", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * wallet findUnique
   */
  export type walletFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet findUniqueOrThrow
   */
  export type walletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet findFirst
   */
  export type walletFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }


  /**
   * wallet findFirstOrThrow
   */
  export type walletFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }


  /**
   * wallet findMany
   */
  export type walletFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }


  /**
   * wallet create
   */
  export type walletCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet.
     */
    data?: XOR<walletCreateInput, walletUncheckedCreateInput>
  }


  /**
   * wallet createMany
   */
  export type walletCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletCreateManyInput | walletCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * wallet update
   */
  export type walletUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet.
     */
    data: XOR<walletUpdateInput, walletUncheckedUpdateInput>
    /**
     * Choose, which wallet to update.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet updateMany
   */
  export type walletUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletWhereInput
  }


  /**
   * wallet upsert
   */
  export type walletUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet to update in case it exists.
     */
    where: walletWhereUniqueInput
    /**
     * In case the wallet found by the `where` argument doesn't exist, create a new wallet with this data.
     */
    create: XOR<walletCreateInput, walletUncheckedCreateInput>
    /**
     * In case the wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletUpdateInput, walletUncheckedUpdateInput>
  }


  /**
   * wallet delete
   */
  export type walletDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter which wallet to delete.
     */
    where: walletWhereUniqueInput
  }


  /**
   * wallet deleteMany
   */
  export type walletDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletWhereInput
  }


  /**
   * wallet.user
   */
  export type wallet$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * wallet.wallet_transaction
   */
  export type wallet$wallet_transactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    where?: wallet_transactionWhereInput
    orderBy?: wallet_transactionOrderByWithRelationInput | wallet_transactionOrderByWithRelationInput[]
    cursor?: wallet_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Wallet_transactionScalarFieldEnum | Wallet_transactionScalarFieldEnum[]
  }


  /**
   * wallet without action
   */
  export type walletArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: walletInclude<ExtArgs> | null
  }



  /**
   * Model wallet_transaction
   */


  export type AggregateWallet_transaction = {
    _count: Wallet_transactionCountAggregateOutputType | null
    _avg: Wallet_transactionAvgAggregateOutputType | null
    _sum: Wallet_transactionSumAggregateOutputType | null
    _min: Wallet_transactionMinAggregateOutputType | null
    _max: Wallet_transactionMaxAggregateOutputType | null
  }

  export type Wallet_transactionAvgAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    amount: number | null
    user_id: number | null
  }

  export type Wallet_transactionSumAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    amount: number | null
    user_id: number | null
  }

  export type Wallet_transactionMinAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    amount: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    type: string | null
    api_collected: boolean | null
    user_id: number | null
    uuid: string | null
  }

  export type Wallet_transactionMaxAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    amount: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    type: string | null
    api_collected: boolean | null
    user_id: number | null
    uuid: string | null
  }

  export type Wallet_transactionCountAggregateOutputType = {
    id: number
    wallet_id: number
    amount: number
    created_at: number
    updated_at: number
    deleted_at: number
    type: number
    api_collected: number
    user_id: number
    uuid: number
    _all: number
  }


  export type Wallet_transactionAvgAggregateInputType = {
    id?: true
    wallet_id?: true
    amount?: true
    user_id?: true
  }

  export type Wallet_transactionSumAggregateInputType = {
    id?: true
    wallet_id?: true
    amount?: true
    user_id?: true
  }

  export type Wallet_transactionMinAggregateInputType = {
    id?: true
    wallet_id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    type?: true
    api_collected?: true
    user_id?: true
    uuid?: true
  }

  export type Wallet_transactionMaxAggregateInputType = {
    id?: true
    wallet_id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    type?: true
    api_collected?: true
    user_id?: true
    uuid?: true
  }

  export type Wallet_transactionCountAggregateInputType = {
    id?: true
    wallet_id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    type?: true
    api_collected?: true
    user_id?: true
    uuid?: true
    _all?: true
  }

  export type Wallet_transactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_transaction to aggregate.
     */
    where?: wallet_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transactions to fetch.
     */
    orderBy?: wallet_transactionOrderByWithRelationInput | wallet_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_transactions
    **/
    _count?: true | Wallet_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_transactionMaxAggregateInputType
  }

  export type GetWallet_transactionAggregateType<T extends Wallet_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_transaction[P]>
      : GetScalarType<T[P], AggregateWallet_transaction[P]>
  }




  export type wallet_transactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: wallet_transactionWhereInput
    orderBy?: wallet_transactionOrderByWithAggregationInput | wallet_transactionOrderByWithAggregationInput[]
    by: Wallet_transactionScalarFieldEnum[] | Wallet_transactionScalarFieldEnum
    having?: wallet_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_transactionCountAggregateInputType | true
    _avg?: Wallet_transactionAvgAggregateInputType
    _sum?: Wallet_transactionSumAggregateInputType
    _min?: Wallet_transactionMinAggregateInputType
    _max?: Wallet_transactionMaxAggregateInputType
  }


  export type Wallet_transactionGroupByOutputType = {
    id: number
    wallet_id: number
    amount: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    type: string
    api_collected: boolean | null
    user_id: number | null
    uuid: string
    _count: Wallet_transactionCountAggregateOutputType | null
    _avg: Wallet_transactionAvgAggregateOutputType | null
    _sum: Wallet_transactionSumAggregateOutputType | null
    _min: Wallet_transactionMinAggregateOutputType | null
    _max: Wallet_transactionMaxAggregateOutputType | null
  }

  type GetWallet_transactionGroupByPayload<T extends wallet_transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_transactionGroupByOutputType[P]>
        }
      >
    >


  export type wallet_transactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_id?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    type?: boolean
    api_collected?: boolean
    user_id?: boolean
    uuid?: boolean
    wallet?: boolean | walletArgs<ExtArgs>
    user?: boolean | wallet_transaction$userArgs<ExtArgs>
  }, ExtArgs["result"]["wallet_transaction"]>

  export type wallet_transactionSelectScalar = {
    id?: boolean
    wallet_id?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    type?: boolean
    api_collected?: boolean
    user_id?: boolean
    uuid?: boolean
  }

  export type wallet_transactionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    wallet?: boolean | walletArgs<ExtArgs>
    user?: boolean | wallet_transaction$userArgs<ExtArgs>
  }


  type wallet_transactionGetPayload<S extends boolean | null | undefined | wallet_transactionArgs> = $Types.GetResult<wallet_transactionPayload, S>

  type wallet_transactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<wallet_transactionFindManyArgs, 'select' | 'include'> & {
      select?: Wallet_transactionCountAggregateInputType | true
    }

  export interface wallet_transactionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_transaction'], meta: { name: 'wallet_transaction' } }
    /**
     * Find zero or one Wallet_transaction that matches the filter.
     * @param {wallet_transactionFindUniqueArgs} args - Arguments to find a Wallet_transaction
     * @example
     * // Get one Wallet_transaction
     * const wallet_transaction = await prisma.wallet_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends wallet_transactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, wallet_transactionFindUniqueArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Wallet_transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {wallet_transactionFindUniqueOrThrowArgs} args - Arguments to find a Wallet_transaction
     * @example
     * // Get one Wallet_transaction
     * const wallet_transaction = await prisma.wallet_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends wallet_transactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, wallet_transactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Wallet_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transactionFindFirstArgs} args - Arguments to find a Wallet_transaction
     * @example
     * // Get one Wallet_transaction
     * const wallet_transaction = await prisma.wallet_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends wallet_transactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, wallet_transactionFindFirstArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Wallet_transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transactionFindFirstOrThrowArgs} args - Arguments to find a Wallet_transaction
     * @example
     * // Get one Wallet_transaction
     * const wallet_transaction = await prisma.wallet_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends wallet_transactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, wallet_transactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Wallet_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_transactions
     * const wallet_transactions = await prisma.wallet_transaction.findMany()
     * 
     * // Get first 10 Wallet_transactions
     * const wallet_transactions = await prisma.wallet_transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_transactionWithIdOnly = await prisma.wallet_transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends wallet_transactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, wallet_transactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Wallet_transaction.
     * @param {wallet_transactionCreateArgs} args - Arguments to create a Wallet_transaction.
     * @example
     * // Create one Wallet_transaction
     * const Wallet_transaction = await prisma.wallet_transaction.create({
     *   data: {
     *     // ... data to create a Wallet_transaction
     *   }
     * })
     * 
    **/
    create<T extends wallet_transactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, wallet_transactionCreateArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Wallet_transactions.
     *     @param {wallet_transactionCreateManyArgs} args - Arguments to create many Wallet_transactions.
     *     @example
     *     // Create many Wallet_transactions
     *     const wallet_transaction = await prisma.wallet_transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends wallet_transactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, wallet_transactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_transaction.
     * @param {wallet_transactionDeleteArgs} args - Arguments to delete one Wallet_transaction.
     * @example
     * // Delete one Wallet_transaction
     * const Wallet_transaction = await prisma.wallet_transaction.delete({
     *   where: {
     *     // ... filter to delete one Wallet_transaction
     *   }
     * })
     * 
    **/
    delete<T extends wallet_transactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, wallet_transactionDeleteArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Wallet_transaction.
     * @param {wallet_transactionUpdateArgs} args - Arguments to update one Wallet_transaction.
     * @example
     * // Update one Wallet_transaction
     * const wallet_transaction = await prisma.wallet_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends wallet_transactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, wallet_transactionUpdateArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Wallet_transactions.
     * @param {wallet_transactionDeleteManyArgs} args - Arguments to filter Wallet_transactions to delete.
     * @example
     * // Delete a few Wallet_transactions
     * const { count } = await prisma.wallet_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends wallet_transactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, wallet_transactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_transactions
     * const wallet_transaction = await prisma.wallet_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends wallet_transactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, wallet_transactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_transaction.
     * @param {wallet_transactionUpsertArgs} args - Arguments to update or create a Wallet_transaction.
     * @example
     * // Update or create a Wallet_transaction
     * const wallet_transaction = await prisma.wallet_transaction.upsert({
     *   create: {
     *     // ... data to create a Wallet_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_transaction we want to update
     *   }
     * })
    **/
    upsert<T extends wallet_transactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, wallet_transactionUpsertArgs<ExtArgs>>
    ): Prisma__wallet_transactionClient<$Types.GetResult<wallet_transactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Wallet_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transactionCountArgs} args - Arguments to filter Wallet_transactions to count.
     * @example
     * // Count the number of Wallet_transactions
     * const count = await prisma.wallet_transaction.count({
     *   where: {
     *     // ... the filter for the Wallet_transactions we want to count
     *   }
     * })
    **/
    count<T extends wallet_transactionCountArgs>(
      args?: Subset<T, wallet_transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_transactionAggregateArgs>(args: Subset<T, Wallet_transactionAggregateArgs>): Prisma.PrismaPromise<GetWallet_transactionAggregateType<T>>

    /**
     * Group by Wallet_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_transactionGroupByArgs['orderBy'] }
        : { orderBy?: wallet_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_transactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_transaction model
   */
  readonly fields: wallet_transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__wallet_transactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    wallet<T extends walletArgs<ExtArgs> = {}>(args?: Subset<T, walletArgs<ExtArgs>>): Prisma__walletClient<$Types.GetResult<walletPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    user<T extends wallet_transaction$userArgs<ExtArgs> = {}>(args?: Subset<T, wallet_transaction$userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the wallet_transaction model
   */ 
  interface wallet_transactionFieldRefs {
    readonly id: FieldRef<"wallet_transaction", 'Int'>
    readonly wallet_id: FieldRef<"wallet_transaction", 'Int'>
    readonly amount: FieldRef<"wallet_transaction", 'Float'>
    readonly created_at: FieldRef<"wallet_transaction", 'DateTime'>
    readonly updated_at: FieldRef<"wallet_transaction", 'DateTime'>
    readonly deleted_at: FieldRef<"wallet_transaction", 'DateTime'>
    readonly type: FieldRef<"wallet_transaction", 'String'>
    readonly api_collected: FieldRef<"wallet_transaction", 'Boolean'>
    readonly user_id: FieldRef<"wallet_transaction", 'Int'>
    readonly uuid: FieldRef<"wallet_transaction", 'String'>
  }
    

  // Custom InputTypes

  /**
   * wallet_transaction findUnique
   */
  export type wallet_transactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * Filter, which wallet_transaction to fetch.
     */
    where: wallet_transactionWhereUniqueInput
  }


  /**
   * wallet_transaction findUniqueOrThrow
   */
  export type wallet_transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * Filter, which wallet_transaction to fetch.
     */
    where: wallet_transactionWhereUniqueInput
  }


  /**
   * wallet_transaction findFirst
   */
  export type wallet_transactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * Filter, which wallet_transaction to fetch.
     */
    where?: wallet_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transactions to fetch.
     */
    orderBy?: wallet_transactionOrderByWithRelationInput | wallet_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_transactions.
     */
    cursor?: wallet_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_transactions.
     */
    distinct?: Wallet_transactionScalarFieldEnum | Wallet_transactionScalarFieldEnum[]
  }


  /**
   * wallet_transaction findFirstOrThrow
   */
  export type wallet_transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * Filter, which wallet_transaction to fetch.
     */
    where?: wallet_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transactions to fetch.
     */
    orderBy?: wallet_transactionOrderByWithRelationInput | wallet_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_transactions.
     */
    cursor?: wallet_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_transactions.
     */
    distinct?: Wallet_transactionScalarFieldEnum | Wallet_transactionScalarFieldEnum[]
  }


  /**
   * wallet_transaction findMany
   */
  export type wallet_transactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * Filter, which wallet_transactions to fetch.
     */
    where?: wallet_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transactions to fetch.
     */
    orderBy?: wallet_transactionOrderByWithRelationInput | wallet_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_transactions.
     */
    cursor?: wallet_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transactions.
     */
    skip?: number
    distinct?: Wallet_transactionScalarFieldEnum | Wallet_transactionScalarFieldEnum[]
  }


  /**
   * wallet_transaction create
   */
  export type wallet_transactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet_transaction.
     */
    data: XOR<wallet_transactionCreateInput, wallet_transactionUncheckedCreateInput>
  }


  /**
   * wallet_transaction createMany
   */
  export type wallet_transactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_transactions.
     */
    data: wallet_transactionCreateManyInput | wallet_transactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * wallet_transaction update
   */
  export type wallet_transactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet_transaction.
     */
    data: XOR<wallet_transactionUpdateInput, wallet_transactionUncheckedUpdateInput>
    /**
     * Choose, which wallet_transaction to update.
     */
    where: wallet_transactionWhereUniqueInput
  }


  /**
   * wallet_transaction updateMany
   */
  export type wallet_transactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_transactions.
     */
    data: XOR<wallet_transactionUpdateManyMutationInput, wallet_transactionUncheckedUpdateManyInput>
    /**
     * Filter which wallet_transactions to update
     */
    where?: wallet_transactionWhereInput
  }


  /**
   * wallet_transaction upsert
   */
  export type wallet_transactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet_transaction to update in case it exists.
     */
    where: wallet_transactionWhereUniqueInput
    /**
     * In case the wallet_transaction found by the `where` argument doesn't exist, create a new wallet_transaction with this data.
     */
    create: XOR<wallet_transactionCreateInput, wallet_transactionUncheckedCreateInput>
    /**
     * In case the wallet_transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_transactionUpdateInput, wallet_transactionUncheckedUpdateInput>
  }


  /**
   * wallet_transaction delete
   */
  export type wallet_transactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
    /**
     * Filter which wallet_transaction to delete.
     */
    where: wallet_transactionWhereUniqueInput
  }


  /**
   * wallet_transaction deleteMany
   */
  export type wallet_transactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_transactions to delete
     */
    where?: wallet_transactionWhereInput
  }


  /**
   * wallet_transaction.user
   */
  export type wallet_transaction$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * wallet_transaction without action
   */
  export type wallet_transactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transaction
     */
    select?: wallet_transactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wallet_transactionInclude<ExtArgs> | null
  }



  /**
   * Model salsa_games
   */


  export type AggregateSalsa_games = {
    _count: Salsa_gamesCountAggregateOutputType | null
    _avg: Salsa_gamesAvgAggregateOutputType | null
    _sum: Salsa_gamesSumAggregateOutputType | null
    _min: Salsa_gamesMinAggregateOutputType | null
    _max: Salsa_gamesMaxAggregateOutputType | null
  }

  export type Salsa_gamesAvgAggregateOutputType = {
    id: number | null
  }

  export type Salsa_gamesSumAggregateOutputType = {
    id: number | null
  }

  export type Salsa_gamesMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    isSlot: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Salsa_gamesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    isSlot: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Salsa_gamesCountAggregateOutputType = {
    id: number
    name: number
    code: number
    isSlot: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type Salsa_gamesAvgAggregateInputType = {
    id?: true
  }

  export type Salsa_gamesSumAggregateInputType = {
    id?: true
  }

  export type Salsa_gamesMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isSlot?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Salsa_gamesMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isSlot?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Salsa_gamesCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isSlot?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Salsa_gamesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which salsa_games to aggregate.
     */
    where?: salsa_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salsa_games to fetch.
     */
    orderBy?: salsa_gamesOrderByWithRelationInput | salsa_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: salsa_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salsa_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salsa_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned salsa_games
    **/
    _count?: true | Salsa_gamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Salsa_gamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Salsa_gamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Salsa_gamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Salsa_gamesMaxAggregateInputType
  }

  export type GetSalsa_gamesAggregateType<T extends Salsa_gamesAggregateArgs> = {
        [P in keyof T & keyof AggregateSalsa_games]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalsa_games[P]>
      : GetScalarType<T[P], AggregateSalsa_games[P]>
  }




  export type salsa_gamesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: salsa_gamesWhereInput
    orderBy?: salsa_gamesOrderByWithAggregationInput | salsa_gamesOrderByWithAggregationInput[]
    by: Salsa_gamesScalarFieldEnum[] | Salsa_gamesScalarFieldEnum
    having?: salsa_gamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Salsa_gamesCountAggregateInputType | true
    _avg?: Salsa_gamesAvgAggregateInputType
    _sum?: Salsa_gamesSumAggregateInputType
    _min?: Salsa_gamesMinAggregateInputType
    _max?: Salsa_gamesMaxAggregateInputType
  }


  export type Salsa_gamesGroupByOutputType = {
    id: number
    name: string
    code: string
    isSlot: boolean
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: Salsa_gamesCountAggregateOutputType | null
    _avg: Salsa_gamesAvgAggregateOutputType | null
    _sum: Salsa_gamesSumAggregateOutputType | null
    _min: Salsa_gamesMinAggregateOutputType | null
    _max: Salsa_gamesMaxAggregateOutputType | null
  }

  type GetSalsa_gamesGroupByPayload<T extends salsa_gamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Salsa_gamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Salsa_gamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Salsa_gamesGroupByOutputType[P]>
            : GetScalarType<T[P], Salsa_gamesGroupByOutputType[P]>
        }
      >
    >


  export type salsa_gamesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isSlot?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["salsa_games"]>

  export type salsa_gamesSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    isSlot?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }


  type salsa_gamesGetPayload<S extends boolean | null | undefined | salsa_gamesArgs> = $Types.GetResult<salsa_gamesPayload, S>

  type salsa_gamesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<salsa_gamesFindManyArgs, 'select' | 'include'> & {
      select?: Salsa_gamesCountAggregateInputType | true
    }

  export interface salsa_gamesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['salsa_games'], meta: { name: 'salsa_games' } }
    /**
     * Find zero or one Salsa_games that matches the filter.
     * @param {salsa_gamesFindUniqueArgs} args - Arguments to find a Salsa_games
     * @example
     * // Get one Salsa_games
     * const salsa_games = await prisma.salsa_games.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends salsa_gamesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, salsa_gamesFindUniqueArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Salsa_games that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {salsa_gamesFindUniqueOrThrowArgs} args - Arguments to find a Salsa_games
     * @example
     * // Get one Salsa_games
     * const salsa_games = await prisma.salsa_games.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends salsa_gamesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salsa_gamesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Salsa_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salsa_gamesFindFirstArgs} args - Arguments to find a Salsa_games
     * @example
     * // Get one Salsa_games
     * const salsa_games = await prisma.salsa_games.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends salsa_gamesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, salsa_gamesFindFirstArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Salsa_games that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salsa_gamesFindFirstOrThrowArgs} args - Arguments to find a Salsa_games
     * @example
     * // Get one Salsa_games
     * const salsa_games = await prisma.salsa_games.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends salsa_gamesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salsa_gamesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Salsa_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salsa_gamesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salsa_games
     * const salsa_games = await prisma.salsa_games.findMany()
     * 
     * // Get first 10 Salsa_games
     * const salsa_games = await prisma.salsa_games.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salsa_gamesWithIdOnly = await prisma.salsa_games.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends salsa_gamesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salsa_gamesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Salsa_games.
     * @param {salsa_gamesCreateArgs} args - Arguments to create a Salsa_games.
     * @example
     * // Create one Salsa_games
     * const Salsa_games = await prisma.salsa_games.create({
     *   data: {
     *     // ... data to create a Salsa_games
     *   }
     * })
     * 
    **/
    create<T extends salsa_gamesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, salsa_gamesCreateArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Salsa_games.
     *     @param {salsa_gamesCreateManyArgs} args - Arguments to create many Salsa_games.
     *     @example
     *     // Create many Salsa_games
     *     const salsa_games = await prisma.salsa_games.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends salsa_gamesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salsa_gamesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Salsa_games.
     * @param {salsa_gamesDeleteArgs} args - Arguments to delete one Salsa_games.
     * @example
     * // Delete one Salsa_games
     * const Salsa_games = await prisma.salsa_games.delete({
     *   where: {
     *     // ... filter to delete one Salsa_games
     *   }
     * })
     * 
    **/
    delete<T extends salsa_gamesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, salsa_gamesDeleteArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Salsa_games.
     * @param {salsa_gamesUpdateArgs} args - Arguments to update one Salsa_games.
     * @example
     * // Update one Salsa_games
     * const salsa_games = await prisma.salsa_games.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends salsa_gamesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, salsa_gamesUpdateArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Salsa_games.
     * @param {salsa_gamesDeleteManyArgs} args - Arguments to filter Salsa_games to delete.
     * @example
     * // Delete a few Salsa_games
     * const { count } = await prisma.salsa_games.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends salsa_gamesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salsa_gamesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salsa_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salsa_gamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salsa_games
     * const salsa_games = await prisma.salsa_games.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends salsa_gamesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, salsa_gamesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Salsa_games.
     * @param {salsa_gamesUpsertArgs} args - Arguments to update or create a Salsa_games.
     * @example
     * // Update or create a Salsa_games
     * const salsa_games = await prisma.salsa_games.upsert({
     *   create: {
     *     // ... data to create a Salsa_games
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salsa_games we want to update
     *   }
     * })
    **/
    upsert<T extends salsa_gamesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, salsa_gamesUpsertArgs<ExtArgs>>
    ): Prisma__salsa_gamesClient<$Types.GetResult<salsa_gamesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Salsa_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salsa_gamesCountArgs} args - Arguments to filter Salsa_games to count.
     * @example
     * // Count the number of Salsa_games
     * const count = await prisma.salsa_games.count({
     *   where: {
     *     // ... the filter for the Salsa_games we want to count
     *   }
     * })
    **/
    count<T extends salsa_gamesCountArgs>(
      args?: Subset<T, salsa_gamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Salsa_gamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salsa_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Salsa_gamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Salsa_gamesAggregateArgs>(args: Subset<T, Salsa_gamesAggregateArgs>): Prisma.PrismaPromise<GetSalsa_gamesAggregateType<T>>

    /**
     * Group by Salsa_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salsa_gamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends salsa_gamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: salsa_gamesGroupByArgs['orderBy'] }
        : { orderBy?: salsa_gamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, salsa_gamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalsa_gamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the salsa_games model
   */
  readonly fields: salsa_gamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for salsa_games.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__salsa_gamesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the salsa_games model
   */ 
  interface salsa_gamesFieldRefs {
    readonly id: FieldRef<"salsa_games", 'Int'>
    readonly name: FieldRef<"salsa_games", 'String'>
    readonly code: FieldRef<"salsa_games", 'String'>
    readonly isSlot: FieldRef<"salsa_games", 'Boolean'>
    readonly created_at: FieldRef<"salsa_games", 'DateTime'>
    readonly updated_at: FieldRef<"salsa_games", 'DateTime'>
    readonly deleted_at: FieldRef<"salsa_games", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * salsa_games findUnique
   */
  export type salsa_gamesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * Filter, which salsa_games to fetch.
     */
    where: salsa_gamesWhereUniqueInput
  }


  /**
   * salsa_games findUniqueOrThrow
   */
  export type salsa_gamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * Filter, which salsa_games to fetch.
     */
    where: salsa_gamesWhereUniqueInput
  }


  /**
   * salsa_games findFirst
   */
  export type salsa_gamesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * Filter, which salsa_games to fetch.
     */
    where?: salsa_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salsa_games to fetch.
     */
    orderBy?: salsa_gamesOrderByWithRelationInput | salsa_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salsa_games.
     */
    cursor?: salsa_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salsa_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salsa_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salsa_games.
     */
    distinct?: Salsa_gamesScalarFieldEnum | Salsa_gamesScalarFieldEnum[]
  }


  /**
   * salsa_games findFirstOrThrow
   */
  export type salsa_gamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * Filter, which salsa_games to fetch.
     */
    where?: salsa_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salsa_games to fetch.
     */
    orderBy?: salsa_gamesOrderByWithRelationInput | salsa_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salsa_games.
     */
    cursor?: salsa_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salsa_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salsa_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salsa_games.
     */
    distinct?: Salsa_gamesScalarFieldEnum | Salsa_gamesScalarFieldEnum[]
  }


  /**
   * salsa_games findMany
   */
  export type salsa_gamesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * Filter, which salsa_games to fetch.
     */
    where?: salsa_gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salsa_games to fetch.
     */
    orderBy?: salsa_gamesOrderByWithRelationInput | salsa_gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing salsa_games.
     */
    cursor?: salsa_gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salsa_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salsa_games.
     */
    skip?: number
    distinct?: Salsa_gamesScalarFieldEnum | Salsa_gamesScalarFieldEnum[]
  }


  /**
   * salsa_games create
   */
  export type salsa_gamesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * The data needed to create a salsa_games.
     */
    data: XOR<salsa_gamesCreateInput, salsa_gamesUncheckedCreateInput>
  }


  /**
   * salsa_games createMany
   */
  export type salsa_gamesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many salsa_games.
     */
    data: salsa_gamesCreateManyInput | salsa_gamesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * salsa_games update
   */
  export type salsa_gamesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * The data needed to update a salsa_games.
     */
    data: XOR<salsa_gamesUpdateInput, salsa_gamesUncheckedUpdateInput>
    /**
     * Choose, which salsa_games to update.
     */
    where: salsa_gamesWhereUniqueInput
  }


  /**
   * salsa_games updateMany
   */
  export type salsa_gamesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update salsa_games.
     */
    data: XOR<salsa_gamesUpdateManyMutationInput, salsa_gamesUncheckedUpdateManyInput>
    /**
     * Filter which salsa_games to update
     */
    where?: salsa_gamesWhereInput
  }


  /**
   * salsa_games upsert
   */
  export type salsa_gamesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * The filter to search for the salsa_games to update in case it exists.
     */
    where: salsa_gamesWhereUniqueInput
    /**
     * In case the salsa_games found by the `where` argument doesn't exist, create a new salsa_games with this data.
     */
    create: XOR<salsa_gamesCreateInput, salsa_gamesUncheckedCreateInput>
    /**
     * In case the salsa_games was found with the provided `where` argument, update it with this data.
     */
    update: XOR<salsa_gamesUpdateInput, salsa_gamesUncheckedUpdateInput>
  }


  /**
   * salsa_games delete
   */
  export type salsa_gamesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
    /**
     * Filter which salsa_games to delete.
     */
    where: salsa_gamesWhereUniqueInput
  }


  /**
   * salsa_games deleteMany
   */
  export type salsa_gamesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which salsa_games to delete
     */
    where?: salsa_gamesWhereInput
  }


  /**
   * salsa_games without action
   */
  export type salsa_gamesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salsa_games
     */
    select?: salsa_gamesSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Api_requestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    request: 'request',
    response: 'response',
    created_at: 'created_at'
  };

  export type Api_requestScalarFieldEnum = (typeof Api_requestScalarFieldEnum)[keyof typeof Api_requestScalarFieldEnum]


  export const Auth_userScalarFieldEnum: {
    id: 'id',
    email: 'email',
    roles: 'roles',
    password: 'password',
    created_at: 'created_at',
    updated_at: 'updated_at',
    username: 'username'
  };

  export type Auth_userScalarFieldEnum = (typeof Auth_userScalarFieldEnum)[keyof typeof Auth_userScalarFieldEnum]


  export const Banner_more_profitableScalarFieldEnum: {
    id: 'id',
    banner_id: 'banner_id',
    slot_settings_id: 'slot_settings_id',
    banner_file_id: 'banner_file_id',
    name: 'name',
    game_url: 'game_url',
    created_at: 'created_at',
    updated_at: 'updated_at',
    active: 'active'
  };

  export type Banner_more_profitableScalarFieldEnum = (typeof Banner_more_profitableScalarFieldEnum)[keyof typeof Banner_more_profitableScalarFieldEnum]


  export const Banner_more_profitable_fileScalarFieldEnum: {
    id: 'id',
    file: 'file',
    upload_at: 'upload_at'
  };

  export type Banner_more_profitable_fileScalarFieldEnum = (typeof Banner_more_profitable_fileScalarFieldEnum)[keyof typeof Banner_more_profitable_fileScalarFieldEnum]


  export const Bet_operationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    slot_game_id: 'slot_game_id',
    bet_transaction_id: 'bet_transaction_id',
    status: 'status',
    amount: 'amount',
    round_id: 'round_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bet_operationsScalarFieldEnum = (typeof Bet_operationsScalarFieldEnum)[keyof typeof Bet_operationsScalarFieldEnum]


  export const Casino_most_popularScalarFieldEnum: {
    id: 'id',
    qty_lines: 'qty_lines',
    qty_columns: 'qty_columns'
  };

  export type Casino_most_popularScalarFieldEnum = (typeof Casino_most_popularScalarFieldEnum)[keyof typeof Casino_most_popularScalarFieldEnum]


  export const Casino_most_popular_slot_gamesScalarFieldEnum: {
    casino_most_popular_id: 'casino_most_popular_id',
    slot_games_id: 'slot_games_id'
  };

  export type Casino_most_popular_slot_gamesScalarFieldEnum = (typeof Casino_most_popular_slot_gamesScalarFieldEnum)[keyof typeof Casino_most_popular_slot_gamesScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    settings_id: 'settings_id',
    key_id_prod: 'key_id_prod',
    key_secret_prod: 'key_secret_prod',
    key_id_stage: 'key_id_stage',
    key_secret_stage: 'key_secret_stage',
    currency: 'currency',
    language: 'language',
    url_return: 'url_return',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    prod_callback: 'prod_callback',
    stage_callback: 'stage_callback'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const Client_auth_userScalarFieldEnum: {
    client_id: 'client_id',
    auth_user_id: 'auth_user_id'
  };

  export type Client_auth_userScalarFieldEnum = (typeof Client_auth_userScalarFieldEnum)[keyof typeof Client_auth_userScalarFieldEnum]


  export const Doctrine_migration_versionsScalarFieldEnum: {
    version: 'version',
    executed_at: 'executed_at',
    execution_time: 'execution_time'
  };

  export type Doctrine_migration_versionsScalarFieldEnum = (typeof Doctrine_migration_versionsScalarFieldEnum)[keyof typeof Doctrine_migration_versionsScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    file: 'file',
    upload_at: 'upload_at'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const Layout_colorsScalarFieldEnum: {
    id: 'id',
    settings_id: 'settings_id',
    name: 'name',
    hexadecimal: 'hexadecimal'
  };

  export type Layout_colorsScalarFieldEnum = (typeof Layout_colorsScalarFieldEnum)[keyof typeof Layout_colorsScalarFieldEnum]


  export const Live_casino_most_popularScalarFieldEnum: {
    id: 'id',
    qty_lines: 'qty_lines',
    qty_columns: 'qty_columns'
  };

  export type Live_casino_most_popularScalarFieldEnum = (typeof Live_casino_most_popularScalarFieldEnum)[keyof typeof Live_casino_most_popularScalarFieldEnum]


  export const Live_casino_most_popular_slot_gamesScalarFieldEnum: {
    live_casino_most_popular_id: 'live_casino_most_popular_id',
    slot_games_id: 'slot_games_id'
  };

  export type Live_casino_most_popular_slot_gamesScalarFieldEnum = (typeof Live_casino_most_popular_slot_gamesScalarFieldEnum)[keyof typeof Live_casino_most_popular_slot_gamesScalarFieldEnum]


  export const Messenger_messagesScalarFieldEnum: {
    id: 'id',
    body: 'body',
    headers: 'headers',
    queue_name: 'queue_name',
    created_at: 'created_at',
    available_at: 'available_at',
    delivered_at: 'delivered_at'
  };

  export type Messenger_messagesScalarFieldEnum = (typeof Messenger_messagesScalarFieldEnum)[keyof typeof Messenger_messagesScalarFieldEnum]


  export const OperationsScalarFieldEnum: {
    id: 'id',
    active: 'active',
    whithdraw_minimum: 'whithdraw_minimum',
    withdraw_maximum: 'withdraw_maximum',
    withdraw_fee: 'withdraw_fee',
    deposit_minimum: 'deposit_minimum',
    deposit_maximum: 'deposit_maximum',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OperationsScalarFieldEnum = (typeof OperationsScalarFieldEnum)[keyof typeof OperationsScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    client_percent: 'client_percent',
    base_percent: 'base_percent'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const Referral_historyScalarFieldEnum: {
    id: 'id',
    referral_id: 'referral_id',
    user_id: 'user_id',
    game: 'game',
    amount: 'amount',
    type: 'type',
    available: 'available',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Referral_historyScalarFieldEnum = (typeof Referral_historyScalarFieldEnum)[keyof typeof Referral_historyScalarFieldEnum]


  export const Referral_settingsScalarFieldEnum: {
    id: 'id',
    cpa: 'cpa',
    rev_share_percent: 'rev_share_percent',
    referral_type: 'referral_type'
  };

  export type Referral_settingsScalarFieldEnum = (typeof Referral_settingsScalarFieldEnum)[keyof typeof Referral_settingsScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    operations_id: 'operations_id',
    slot_settings_id: 'slot_settings_id',
    client_id: 'client_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const Slot_gamesScalarFieldEnum: {
    id: 'id',
    provider_id: 'provider_id',
    uuid: 'uuid',
    name: 'name',
    image: 'image',
    type: 'type',
    has_lobby: 'has_lobby',
    is_mobile: 'is_mobile',
    has_freespins: 'has_freespins',
    has_tables: 'has_tables',
    freespin_valid_until_full_day: 'freespin_valid_until_full_day',
    slug: 'slug'
  };

  export type Slot_gamesScalarFieldEnum = (typeof Slot_gamesScalarFieldEnum)[keyof typeof Slot_gamesScalarFieldEnum]


  export const Slot_settingsScalarFieldEnum: {
    id: 'id',
    casino_most_popular_id: 'casino_most_popular_id',
    live_casino_most_popular_id: 'live_casino_most_popular_id'
  };

  export type Slot_settingsScalarFieldEnum = (typeof Slot_settingsScalarFieldEnum)[keyof typeof Slot_settingsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    wallet_id: 'wallet_id',
    client_id: 'client_id',
    referral_id: 'referral_id',
    referral_settings_id: 'referral_settings_id',
    external_id: 'external_id',
    username: 'username',
    balance: 'balance',
    created_at: 'created_at',
    updated_at: 'updated_at',
    session: 'session',
    cpa_collected: 'cpa_collected',
    is_referrer: 'is_referrer'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    bonus: 'bonus',
    bet: 'bet',
    withdraw: 'withdraw',
    deposit: 'deposit'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const Wallet_transactionScalarFieldEnum: {
    id: 'id',
    wallet_id: 'wallet_id',
    amount: 'amount',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    type: 'type',
    api_collected: 'api_collected',
    user_id: 'user_id',
    uuid: 'uuid'
  };

  export type Wallet_transactionScalarFieldEnum = (typeof Wallet_transactionScalarFieldEnum)[keyof typeof Wallet_transactionScalarFieldEnum]


  export const Salsa_gamesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    isSlot: 'isSlot',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Salsa_gamesScalarFieldEnum = (typeof Salsa_gamesScalarFieldEnum)[keyof typeof Salsa_gamesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    
  /**
   * Deep Input Types
   */


  export type api_requestWhereInput = {
    AND?: api_requestWhereInput | api_requestWhereInput[]
    OR?: api_requestWhereInput[]
    NOT?: api_requestWhereInput | api_requestWhereInput[]
    id?: IntFilter<"api_request"> | number
    name?: StringFilter<"api_request"> | string
    request?: JsonFilter<"api_request">
    response?: JsonFilter<"api_request">
    created_at?: DateTimeFilter<"api_request"> | Date | string
  }

  export type api_requestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    request?: SortOrder
    response?: SortOrder
    created_at?: SortOrder
  }

  export type api_requestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: api_requestWhereInput | api_requestWhereInput[]
    OR?: api_requestWhereInput[]
    NOT?: api_requestWhereInput | api_requestWhereInput[]
    name?: StringFilter<"api_request"> | string
    request?: JsonFilter<"api_request">
    response?: JsonFilter<"api_request">
    created_at?: DateTimeFilter<"api_request"> | Date | string
  }, "id">

  export type api_requestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    request?: SortOrder
    response?: SortOrder
    created_at?: SortOrder
    _count?: api_requestCountOrderByAggregateInput
    _avg?: api_requestAvgOrderByAggregateInput
    _max?: api_requestMaxOrderByAggregateInput
    _min?: api_requestMinOrderByAggregateInput
    _sum?: api_requestSumOrderByAggregateInput
  }

  export type api_requestScalarWhereWithAggregatesInput = {
    AND?: api_requestScalarWhereWithAggregatesInput | api_requestScalarWhereWithAggregatesInput[]
    OR?: api_requestScalarWhereWithAggregatesInput[]
    NOT?: api_requestScalarWhereWithAggregatesInput | api_requestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"api_request"> | number
    name?: StringWithAggregatesFilter<"api_request"> | string
    request?: JsonWithAggregatesFilter<"api_request">
    response?: JsonWithAggregatesFilter<"api_request">
    created_at?: DateTimeWithAggregatesFilter<"api_request"> | Date | string
  }

  export type auth_userWhereInput = {
    AND?: auth_userWhereInput | auth_userWhereInput[]
    OR?: auth_userWhereInput[]
    NOT?: auth_userWhereInput | auth_userWhereInput[]
    id?: IntFilter<"auth_user"> | number
    email?: StringFilter<"auth_user"> | string
    roles?: JsonFilter<"auth_user">
    password?: StringFilter<"auth_user"> | string
    created_at?: DateTimeFilter<"auth_user"> | Date | string
    updated_at?: DateTimeFilter<"auth_user"> | Date | string
    username?: StringFilter<"auth_user"> | string
    client_auth_user?: Client_auth_userListRelationFilter
  }

  export type auth_userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    roles?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    client_auth_user?: client_auth_userOrderByRelationAggregateInput
  }

  export type auth_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: auth_userWhereInput | auth_userWhereInput[]
    OR?: auth_userWhereInput[]
    NOT?: auth_userWhereInput | auth_userWhereInput[]
    roles?: JsonFilter<"auth_user">
    password?: StringFilter<"auth_user"> | string
    created_at?: DateTimeFilter<"auth_user"> | Date | string
    updated_at?: DateTimeFilter<"auth_user"> | Date | string
    username?: StringFilter<"auth_user"> | string
    client_auth_user?: Client_auth_userListRelationFilter
  }, "id" | "email">

  export type auth_userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    roles?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    _count?: auth_userCountOrderByAggregateInput
    _avg?: auth_userAvgOrderByAggregateInput
    _max?: auth_userMaxOrderByAggregateInput
    _min?: auth_userMinOrderByAggregateInput
    _sum?: auth_userSumOrderByAggregateInput
  }

  export type auth_userScalarWhereWithAggregatesInput = {
    AND?: auth_userScalarWhereWithAggregatesInput | auth_userScalarWhereWithAggregatesInput[]
    OR?: auth_userScalarWhereWithAggregatesInput[]
    NOT?: auth_userScalarWhereWithAggregatesInput | auth_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"auth_user"> | number
    email?: StringWithAggregatesFilter<"auth_user"> | string
    roles?: JsonWithAggregatesFilter<"auth_user">
    password?: StringWithAggregatesFilter<"auth_user"> | string
    created_at?: DateTimeWithAggregatesFilter<"auth_user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"auth_user"> | Date | string
    username?: StringWithAggregatesFilter<"auth_user"> | string
  }

  export type banner_more_profitableWhereInput = {
    AND?: banner_more_profitableWhereInput | banner_more_profitableWhereInput[]
    OR?: banner_more_profitableWhereInput[]
    NOT?: banner_more_profitableWhereInput | banner_more_profitableWhereInput[]
    id?: IntFilter<"banner_more_profitable"> | number
    banner_id?: IntNullableFilter<"banner_more_profitable"> | number | null
    slot_settings_id?: IntNullableFilter<"banner_more_profitable"> | number | null
    banner_file_id?: IntNullableFilter<"banner_more_profitable"> | number | null
    name?: StringFilter<"banner_more_profitable"> | string
    game_url?: StringFilter<"banner_more_profitable"> | string
    created_at?: DateTimeFilter<"banner_more_profitable"> | Date | string
    updated_at?: DateTimeFilter<"banner_more_profitable"> | Date | string
    active?: BoolFilter<"banner_more_profitable"> | boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: XOR<Banner_more_profitable_fileNullableRelationFilter, banner_more_profitable_fileWhereInput> | null
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: XOR<Banner_more_profitable_fileNullableRelationFilter, banner_more_profitable_fileWhereInput> | null
  }

  export type banner_more_profitableOrderByWithRelationInput = {
    id?: SortOrder
    banner_id?: SortOrderInput | SortOrder
    slot_settings_id?: SortOrderInput | SortOrder
    banner_file_id?: SortOrderInput | SortOrder
    name?: SortOrder
    game_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitable_fileOrderByWithRelationInput
    slot_settings?: slot_settingsOrderByWithRelationInput
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitable_fileOrderByWithRelationInput
  }

  export type banner_more_profitableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    banner_id?: number
    banner_file_id?: number
    AND?: banner_more_profitableWhereInput | banner_more_profitableWhereInput[]
    OR?: banner_more_profitableWhereInput[]
    NOT?: banner_more_profitableWhereInput | banner_more_profitableWhereInput[]
    slot_settings_id?: IntNullableFilter<"banner_more_profitable"> | number | null
    name?: StringFilter<"banner_more_profitable"> | string
    game_url?: StringFilter<"banner_more_profitable"> | string
    created_at?: DateTimeFilter<"banner_more_profitable"> | Date | string
    updated_at?: DateTimeFilter<"banner_more_profitable"> | Date | string
    active?: BoolFilter<"banner_more_profitable"> | boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: XOR<Banner_more_profitable_fileNullableRelationFilter, banner_more_profitable_fileWhereInput> | null
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: XOR<Banner_more_profitable_fileNullableRelationFilter, banner_more_profitable_fileWhereInput> | null
  }, "id" | "banner_id" | "banner_file_id">

  export type banner_more_profitableOrderByWithAggregationInput = {
    id?: SortOrder
    banner_id?: SortOrderInput | SortOrder
    slot_settings_id?: SortOrderInput | SortOrder
    banner_file_id?: SortOrderInput | SortOrder
    name?: SortOrder
    game_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
    _count?: banner_more_profitableCountOrderByAggregateInput
    _avg?: banner_more_profitableAvgOrderByAggregateInput
    _max?: banner_more_profitableMaxOrderByAggregateInput
    _min?: banner_more_profitableMinOrderByAggregateInput
    _sum?: banner_more_profitableSumOrderByAggregateInput
  }

  export type banner_more_profitableScalarWhereWithAggregatesInput = {
    AND?: banner_more_profitableScalarWhereWithAggregatesInput | banner_more_profitableScalarWhereWithAggregatesInput[]
    OR?: banner_more_profitableScalarWhereWithAggregatesInput[]
    NOT?: banner_more_profitableScalarWhereWithAggregatesInput | banner_more_profitableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"banner_more_profitable"> | number
    banner_id?: IntNullableWithAggregatesFilter<"banner_more_profitable"> | number | null
    slot_settings_id?: IntNullableWithAggregatesFilter<"banner_more_profitable"> | number | null
    banner_file_id?: IntNullableWithAggregatesFilter<"banner_more_profitable"> | number | null
    name?: StringWithAggregatesFilter<"banner_more_profitable"> | string
    game_url?: StringWithAggregatesFilter<"banner_more_profitable"> | string
    created_at?: DateTimeWithAggregatesFilter<"banner_more_profitable"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"banner_more_profitable"> | Date | string
    active?: BoolWithAggregatesFilter<"banner_more_profitable"> | boolean
  }

  export type banner_more_profitable_fileWhereInput = {
    AND?: banner_more_profitable_fileWhereInput | banner_more_profitable_fileWhereInput[]
    OR?: banner_more_profitable_fileWhereInput[]
    NOT?: banner_more_profitable_fileWhereInput | banner_more_profitable_fileWhereInput[]
    id?: IntFilter<"banner_more_profitable_file"> | number
    file?: StringFilter<"banner_more_profitable_file"> | string
    upload_at?: DateTimeFilter<"banner_more_profitable_file"> | Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: XOR<Banner_more_profitableNullableRelationFilter, banner_more_profitableWhereInput> | null
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: XOR<Banner_more_profitableNullableRelationFilter, banner_more_profitableWhereInput> | null
  }

  export type banner_more_profitable_fileOrderByWithRelationInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableOrderByWithRelationInput
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableOrderByWithRelationInput
  }

  export type banner_more_profitable_fileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: banner_more_profitable_fileWhereInput | banner_more_profitable_fileWhereInput[]
    OR?: banner_more_profitable_fileWhereInput[]
    NOT?: banner_more_profitable_fileWhereInput | banner_more_profitable_fileWhereInput[]
    file?: StringFilter<"banner_more_profitable_file"> | string
    upload_at?: DateTimeFilter<"banner_more_profitable_file"> | Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: XOR<Banner_more_profitableNullableRelationFilter, banner_more_profitableWhereInput> | null
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: XOR<Banner_more_profitableNullableRelationFilter, banner_more_profitableWhereInput> | null
  }, "id">

  export type banner_more_profitable_fileOrderByWithAggregationInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
    _count?: banner_more_profitable_fileCountOrderByAggregateInput
    _avg?: banner_more_profitable_fileAvgOrderByAggregateInput
    _max?: banner_more_profitable_fileMaxOrderByAggregateInput
    _min?: banner_more_profitable_fileMinOrderByAggregateInput
    _sum?: banner_more_profitable_fileSumOrderByAggregateInput
  }

  export type banner_more_profitable_fileScalarWhereWithAggregatesInput = {
    AND?: banner_more_profitable_fileScalarWhereWithAggregatesInput | banner_more_profitable_fileScalarWhereWithAggregatesInput[]
    OR?: banner_more_profitable_fileScalarWhereWithAggregatesInput[]
    NOT?: banner_more_profitable_fileScalarWhereWithAggregatesInput | banner_more_profitable_fileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"banner_more_profitable_file"> | number
    file?: StringWithAggregatesFilter<"banner_more_profitable_file"> | string
    upload_at?: DateTimeWithAggregatesFilter<"banner_more_profitable_file"> | Date | string
  }

  export type bet_operationsWhereInput = {
    AND?: bet_operationsWhereInput | bet_operationsWhereInput[]
    OR?: bet_operationsWhereInput[]
    NOT?: bet_operationsWhereInput | bet_operationsWhereInput[]
    id?: IntFilter<"bet_operations"> | number
    user_id?: IntFilter<"bet_operations"> | number
    slot_game_id?: IntFilter<"bet_operations"> | number
    bet_transaction_id?: StringFilter<"bet_operations"> | string
    status?: StringFilter<"bet_operations"> | string
    amount?: FloatFilter<"bet_operations"> | number
    round_id?: StringNullableFilter<"bet_operations"> | string | null
    created_at?: DateTimeFilter<"bet_operations"> | Date | string
    updated_at?: DateTimeFilter<"bet_operations"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    slot_games?: XOR<Slot_gamesRelationFilter, slot_gamesWhereInput>
  }

  export type bet_operationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    slot_game_id?: SortOrder
    bet_transaction_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    round_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
    slot_games?: slot_gamesOrderByWithRelationInput
  }

  export type bet_operationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bet_operationsWhereInput | bet_operationsWhereInput[]
    OR?: bet_operationsWhereInput[]
    NOT?: bet_operationsWhereInput | bet_operationsWhereInput[]
    user_id?: IntFilter<"bet_operations"> | number
    slot_game_id?: IntFilter<"bet_operations"> | number
    bet_transaction_id?: StringFilter<"bet_operations"> | string
    status?: StringFilter<"bet_operations"> | string
    amount?: FloatFilter<"bet_operations"> | number
    round_id?: StringNullableFilter<"bet_operations"> | string | null
    created_at?: DateTimeFilter<"bet_operations"> | Date | string
    updated_at?: DateTimeFilter<"bet_operations"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    slot_games?: XOR<Slot_gamesRelationFilter, slot_gamesWhereInput>
  }, "id">

  export type bet_operationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    slot_game_id?: SortOrder
    bet_transaction_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    round_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: bet_operationsCountOrderByAggregateInput
    _avg?: bet_operationsAvgOrderByAggregateInput
    _max?: bet_operationsMaxOrderByAggregateInput
    _min?: bet_operationsMinOrderByAggregateInput
    _sum?: bet_operationsSumOrderByAggregateInput
  }

  export type bet_operationsScalarWhereWithAggregatesInput = {
    AND?: bet_operationsScalarWhereWithAggregatesInput | bet_operationsScalarWhereWithAggregatesInput[]
    OR?: bet_operationsScalarWhereWithAggregatesInput[]
    NOT?: bet_operationsScalarWhereWithAggregatesInput | bet_operationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bet_operations"> | number
    user_id?: IntWithAggregatesFilter<"bet_operations"> | number
    slot_game_id?: IntWithAggregatesFilter<"bet_operations"> | number
    bet_transaction_id?: StringWithAggregatesFilter<"bet_operations"> | string
    status?: StringWithAggregatesFilter<"bet_operations"> | string
    amount?: FloatWithAggregatesFilter<"bet_operations"> | number
    round_id?: StringNullableWithAggregatesFilter<"bet_operations"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"bet_operations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"bet_operations"> | Date | string
  }

  export type casino_most_popularWhereInput = {
    AND?: casino_most_popularWhereInput | casino_most_popularWhereInput[]
    OR?: casino_most_popularWhereInput[]
    NOT?: casino_most_popularWhereInput | casino_most_popularWhereInput[]
    id?: IntFilter<"casino_most_popular"> | number
    qty_lines?: IntFilter<"casino_most_popular"> | number
    qty_columns?: IntFilter<"casino_most_popular"> | number
    casino_most_popular_slot_games?: Casino_most_popular_slot_gamesListRelationFilter
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
  }

  export type casino_most_popularOrderByWithRelationInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesOrderByRelationAggregateInput
    slot_settings?: slot_settingsOrderByWithRelationInput
  }

  export type casino_most_popularWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: casino_most_popularWhereInput | casino_most_popularWhereInput[]
    OR?: casino_most_popularWhereInput[]
    NOT?: casino_most_popularWhereInput | casino_most_popularWhereInput[]
    qty_lines?: IntFilter<"casino_most_popular"> | number
    qty_columns?: IntFilter<"casino_most_popular"> | number
    casino_most_popular_slot_games?: Casino_most_popular_slot_gamesListRelationFilter
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
  }, "id">

  export type casino_most_popularOrderByWithAggregationInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
    _count?: casino_most_popularCountOrderByAggregateInput
    _avg?: casino_most_popularAvgOrderByAggregateInput
    _max?: casino_most_popularMaxOrderByAggregateInput
    _min?: casino_most_popularMinOrderByAggregateInput
    _sum?: casino_most_popularSumOrderByAggregateInput
  }

  export type casino_most_popularScalarWhereWithAggregatesInput = {
    AND?: casino_most_popularScalarWhereWithAggregatesInput | casino_most_popularScalarWhereWithAggregatesInput[]
    OR?: casino_most_popularScalarWhereWithAggregatesInput[]
    NOT?: casino_most_popularScalarWhereWithAggregatesInput | casino_most_popularScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"casino_most_popular"> | number
    qty_lines?: IntWithAggregatesFilter<"casino_most_popular"> | number
    qty_columns?: IntWithAggregatesFilter<"casino_most_popular"> | number
  }

  export type casino_most_popular_slot_gamesWhereInput = {
    AND?: casino_most_popular_slot_gamesWhereInput | casino_most_popular_slot_gamesWhereInput[]
    OR?: casino_most_popular_slot_gamesWhereInput[]
    NOT?: casino_most_popular_slot_gamesWhereInput | casino_most_popular_slot_gamesWhereInput[]
    casino_most_popular_id?: IntFilter<"casino_most_popular_slot_games"> | number
    slot_games_id?: IntFilter<"casino_most_popular_slot_games"> | number
    slot_games?: XOR<Slot_gamesRelationFilter, slot_gamesWhereInput>
    casino_most_popular?: XOR<Casino_most_popularRelationFilter, casino_most_popularWhereInput>
  }

  export type casino_most_popular_slot_gamesOrderByWithRelationInput = {
    casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
    slot_games?: slot_gamesOrderByWithRelationInput
    casino_most_popular?: casino_most_popularOrderByWithRelationInput
  }

  export type casino_most_popular_slot_gamesWhereUniqueInput = Prisma.AtLeast<{
    casino_most_popular_id_slot_games_id?: casino_most_popular_slot_gamesCasino_most_popular_idSlot_games_idCompoundUniqueInput
    AND?: casino_most_popular_slot_gamesWhereInput | casino_most_popular_slot_gamesWhereInput[]
    OR?: casino_most_popular_slot_gamesWhereInput[]
    NOT?: casino_most_popular_slot_gamesWhereInput | casino_most_popular_slot_gamesWhereInput[]
    casino_most_popular_id?: IntFilter<"casino_most_popular_slot_games"> | number
    slot_games_id?: IntFilter<"casino_most_popular_slot_games"> | number
    slot_games?: XOR<Slot_gamesRelationFilter, slot_gamesWhereInput>
    casino_most_popular?: XOR<Casino_most_popularRelationFilter, casino_most_popularWhereInput>
  }, "casino_most_popular_id_slot_games_id">

  export type casino_most_popular_slot_gamesOrderByWithAggregationInput = {
    casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
    _count?: casino_most_popular_slot_gamesCountOrderByAggregateInput
    _avg?: casino_most_popular_slot_gamesAvgOrderByAggregateInput
    _max?: casino_most_popular_slot_gamesMaxOrderByAggregateInput
    _min?: casino_most_popular_slot_gamesMinOrderByAggregateInput
    _sum?: casino_most_popular_slot_gamesSumOrderByAggregateInput
  }

  export type casino_most_popular_slot_gamesScalarWhereWithAggregatesInput = {
    AND?: casino_most_popular_slot_gamesScalarWhereWithAggregatesInput | casino_most_popular_slot_gamesScalarWhereWithAggregatesInput[]
    OR?: casino_most_popular_slot_gamesScalarWhereWithAggregatesInput[]
    NOT?: casino_most_popular_slot_gamesScalarWhereWithAggregatesInput | casino_most_popular_slot_gamesScalarWhereWithAggregatesInput[]
    casino_most_popular_id?: IntWithAggregatesFilter<"casino_most_popular_slot_games"> | number
    slot_games_id?: IntWithAggregatesFilter<"casino_most_popular_slot_games"> | number
  }

  export type clientWhereInput = {
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    id?: IntFilter<"client"> | number
    settings_id?: IntNullableFilter<"client"> | number | null
    key_id_prod?: StringNullableFilter<"client"> | string | null
    key_secret_prod?: StringNullableFilter<"client"> | string | null
    key_id_stage?: StringNullableFilter<"client"> | string | null
    key_secret_stage?: StringNullableFilter<"client"> | string | null
    currency?: StringNullableFilter<"client"> | string | null
    language?: StringNullableFilter<"client"> | string | null
    url_return?: StringNullableFilter<"client"> | string | null
    created_at?: DateTimeFilter<"client"> | Date | string
    updated_at?: DateTimeFilter<"client"> | Date | string
    name?: StringNullableFilter<"client"> | string | null
    prod_callback?: StringNullableFilter<"client"> | string | null
    stage_callback?: StringNullableFilter<"client"> | string | null
    settings_client_settings_idTosettings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
    client_auth_user?: Client_auth_userListRelationFilter
    settings_settings_client_idToclient?: SettingsListRelationFilter
    user?: UserListRelationFilter
  }

  export type clientOrderByWithRelationInput = {
    id?: SortOrder
    settings_id?: SortOrderInput | SortOrder
    key_id_prod?: SortOrderInput | SortOrder
    key_secret_prod?: SortOrderInput | SortOrder
    key_id_stage?: SortOrderInput | SortOrder
    key_secret_stage?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    url_return?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrderInput | SortOrder
    prod_callback?: SortOrderInput | SortOrder
    stage_callback?: SortOrderInput | SortOrder
    settings_client_settings_idTosettings?: settingsOrderByWithRelationInput
    client_auth_user?: client_auth_userOrderByRelationAggregateInput
    settings_settings_client_idToclient?: settingsOrderByRelationAggregateInput
    user?: userOrderByRelationAggregateInput
  }

  export type clientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    settings_id?: number
    AND?: clientWhereInput | clientWhereInput[]
    OR?: clientWhereInput[]
    NOT?: clientWhereInput | clientWhereInput[]
    key_id_prod?: StringNullableFilter<"client"> | string | null
    key_secret_prod?: StringNullableFilter<"client"> | string | null
    key_id_stage?: StringNullableFilter<"client"> | string | null
    key_secret_stage?: StringNullableFilter<"client"> | string | null
    currency?: StringNullableFilter<"client"> | string | null
    language?: StringNullableFilter<"client"> | string | null
    url_return?: StringNullableFilter<"client"> | string | null
    created_at?: DateTimeFilter<"client"> | Date | string
    updated_at?: DateTimeFilter<"client"> | Date | string
    name?: StringNullableFilter<"client"> | string | null
    prod_callback?: StringNullableFilter<"client"> | string | null
    stage_callback?: StringNullableFilter<"client"> | string | null
    settings_client_settings_idTosettings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
    client_auth_user?: Client_auth_userListRelationFilter
    settings_settings_client_idToclient?: SettingsListRelationFilter
    user?: UserListRelationFilter
  }, "id" | "settings_id">

  export type clientOrderByWithAggregationInput = {
    id?: SortOrder
    settings_id?: SortOrderInput | SortOrder
    key_id_prod?: SortOrderInput | SortOrder
    key_secret_prod?: SortOrderInput | SortOrder
    key_id_stage?: SortOrderInput | SortOrder
    key_secret_stage?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    url_return?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrderInput | SortOrder
    prod_callback?: SortOrderInput | SortOrder
    stage_callback?: SortOrderInput | SortOrder
    _count?: clientCountOrderByAggregateInput
    _avg?: clientAvgOrderByAggregateInput
    _max?: clientMaxOrderByAggregateInput
    _min?: clientMinOrderByAggregateInput
    _sum?: clientSumOrderByAggregateInput
  }

  export type clientScalarWhereWithAggregatesInput = {
    AND?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    OR?: clientScalarWhereWithAggregatesInput[]
    NOT?: clientScalarWhereWithAggregatesInput | clientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"client"> | number
    settings_id?: IntNullableWithAggregatesFilter<"client"> | number | null
    key_id_prod?: StringNullableWithAggregatesFilter<"client"> | string | null
    key_secret_prod?: StringNullableWithAggregatesFilter<"client"> | string | null
    key_id_stage?: StringNullableWithAggregatesFilter<"client"> | string | null
    key_secret_stage?: StringNullableWithAggregatesFilter<"client"> | string | null
    currency?: StringNullableWithAggregatesFilter<"client"> | string | null
    language?: StringNullableWithAggregatesFilter<"client"> | string | null
    url_return?: StringNullableWithAggregatesFilter<"client"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"client"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"client"> | Date | string
    name?: StringNullableWithAggregatesFilter<"client"> | string | null
    prod_callback?: StringNullableWithAggregatesFilter<"client"> | string | null
    stage_callback?: StringNullableWithAggregatesFilter<"client"> | string | null
  }

  export type client_auth_userWhereInput = {
    AND?: client_auth_userWhereInput | client_auth_userWhereInput[]
    OR?: client_auth_userWhereInput[]
    NOT?: client_auth_userWhereInput | client_auth_userWhereInput[]
    client_id?: IntFilter<"client_auth_user"> | number
    auth_user_id?: IntFilter<"client_auth_user"> | number
    client?: XOR<ClientRelationFilter, clientWhereInput>
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }

  export type client_auth_userOrderByWithRelationInput = {
    client_id?: SortOrder
    auth_user_id?: SortOrder
    client?: clientOrderByWithRelationInput
    auth_user?: auth_userOrderByWithRelationInput
  }

  export type client_auth_userWhereUniqueInput = Prisma.AtLeast<{
    client_id_auth_user_id?: client_auth_userClient_idAuth_user_idCompoundUniqueInput
    AND?: client_auth_userWhereInput | client_auth_userWhereInput[]
    OR?: client_auth_userWhereInput[]
    NOT?: client_auth_userWhereInput | client_auth_userWhereInput[]
    client_id?: IntFilter<"client_auth_user"> | number
    auth_user_id?: IntFilter<"client_auth_user"> | number
    client?: XOR<ClientRelationFilter, clientWhereInput>
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }, "client_id_auth_user_id">

  export type client_auth_userOrderByWithAggregationInput = {
    client_id?: SortOrder
    auth_user_id?: SortOrder
    _count?: client_auth_userCountOrderByAggregateInput
    _avg?: client_auth_userAvgOrderByAggregateInput
    _max?: client_auth_userMaxOrderByAggregateInput
    _min?: client_auth_userMinOrderByAggregateInput
    _sum?: client_auth_userSumOrderByAggregateInput
  }

  export type client_auth_userScalarWhereWithAggregatesInput = {
    AND?: client_auth_userScalarWhereWithAggregatesInput | client_auth_userScalarWhereWithAggregatesInput[]
    OR?: client_auth_userScalarWhereWithAggregatesInput[]
    NOT?: client_auth_userScalarWhereWithAggregatesInput | client_auth_userScalarWhereWithAggregatesInput[]
    client_id?: IntWithAggregatesFilter<"client_auth_user"> | number
    auth_user_id?: IntWithAggregatesFilter<"client_auth_user"> | number
  }

  export type doctrine_migration_versionsWhereInput = {
    AND?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    OR?: doctrine_migration_versionsWhereInput[]
    NOT?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    version?: StringFilter<"doctrine_migration_versions"> | string
    executed_at?: DateTimeNullableFilter<"doctrine_migration_versions"> | Date | string | null
    execution_time?: IntNullableFilter<"doctrine_migration_versions"> | number | null
  }

  export type doctrine_migration_versionsOrderByWithRelationInput = {
    version?: SortOrder
    executed_at?: SortOrderInput | SortOrder
    execution_time?: SortOrderInput | SortOrder
  }

  export type doctrine_migration_versionsWhereUniqueInput = Prisma.AtLeast<{
    version?: string
    AND?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    OR?: doctrine_migration_versionsWhereInput[]
    NOT?: doctrine_migration_versionsWhereInput | doctrine_migration_versionsWhereInput[]
    executed_at?: DateTimeNullableFilter<"doctrine_migration_versions"> | Date | string | null
    execution_time?: IntNullableFilter<"doctrine_migration_versions"> | number | null
  }, "version">

  export type doctrine_migration_versionsOrderByWithAggregationInput = {
    version?: SortOrder
    executed_at?: SortOrderInput | SortOrder
    execution_time?: SortOrderInput | SortOrder
    _count?: doctrine_migration_versionsCountOrderByAggregateInput
    _avg?: doctrine_migration_versionsAvgOrderByAggregateInput
    _max?: doctrine_migration_versionsMaxOrderByAggregateInput
    _min?: doctrine_migration_versionsMinOrderByAggregateInput
    _sum?: doctrine_migration_versionsSumOrderByAggregateInput
  }

  export type doctrine_migration_versionsScalarWhereWithAggregatesInput = {
    AND?: doctrine_migration_versionsScalarWhereWithAggregatesInput | doctrine_migration_versionsScalarWhereWithAggregatesInput[]
    OR?: doctrine_migration_versionsScalarWhereWithAggregatesInput[]
    NOT?: doctrine_migration_versionsScalarWhereWithAggregatesInput | doctrine_migration_versionsScalarWhereWithAggregatesInput[]
    version?: StringWithAggregatesFilter<"doctrine_migration_versions"> | string
    executed_at?: DateTimeNullableWithAggregatesFilter<"doctrine_migration_versions"> | Date | string | null
    execution_time?: IntNullableWithAggregatesFilter<"doctrine_migration_versions"> | number | null
  }

  export type fileWhereInput = {
    AND?: fileWhereInput | fileWhereInput[]
    OR?: fileWhereInput[]
    NOT?: fileWhereInput | fileWhereInput[]
    id?: IntFilter<"file"> | number
    file?: StringFilter<"file"> | string
    upload_at?: DateTimeFilter<"file"> | Date | string
  }

  export type fileOrderByWithRelationInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
  }

  export type fileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fileWhereInput | fileWhereInput[]
    OR?: fileWhereInput[]
    NOT?: fileWhereInput | fileWhereInput[]
    file?: StringFilter<"file"> | string
    upload_at?: DateTimeFilter<"file"> | Date | string
  }, "id">

  export type fileOrderByWithAggregationInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
    _count?: fileCountOrderByAggregateInput
    _avg?: fileAvgOrderByAggregateInput
    _max?: fileMaxOrderByAggregateInput
    _min?: fileMinOrderByAggregateInput
    _sum?: fileSumOrderByAggregateInput
  }

  export type fileScalarWhereWithAggregatesInput = {
    AND?: fileScalarWhereWithAggregatesInput | fileScalarWhereWithAggregatesInput[]
    OR?: fileScalarWhereWithAggregatesInput[]
    NOT?: fileScalarWhereWithAggregatesInput | fileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"file"> | number
    file?: StringWithAggregatesFilter<"file"> | string
    upload_at?: DateTimeWithAggregatesFilter<"file"> | Date | string
  }

  export type layout_colorsWhereInput = {
    AND?: layout_colorsWhereInput | layout_colorsWhereInput[]
    OR?: layout_colorsWhereInput[]
    NOT?: layout_colorsWhereInput | layout_colorsWhereInput[]
    id?: IntFilter<"layout_colors"> | number
    settings_id?: IntNullableFilter<"layout_colors"> | number | null
    name?: StringFilter<"layout_colors"> | string
    hexadecimal?: StringFilter<"layout_colors"> | string
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
  }

  export type layout_colorsOrderByWithRelationInput = {
    id?: SortOrder
    settings_id?: SortOrderInput | SortOrder
    name?: SortOrder
    hexadecimal?: SortOrder
    settings?: settingsOrderByWithRelationInput
  }

  export type layout_colorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: layout_colorsWhereInput | layout_colorsWhereInput[]
    OR?: layout_colorsWhereInput[]
    NOT?: layout_colorsWhereInput | layout_colorsWhereInput[]
    settings_id?: IntNullableFilter<"layout_colors"> | number | null
    name?: StringFilter<"layout_colors"> | string
    hexadecimal?: StringFilter<"layout_colors"> | string
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
  }, "id">

  export type layout_colorsOrderByWithAggregationInput = {
    id?: SortOrder
    settings_id?: SortOrderInput | SortOrder
    name?: SortOrder
    hexadecimal?: SortOrder
    _count?: layout_colorsCountOrderByAggregateInput
    _avg?: layout_colorsAvgOrderByAggregateInput
    _max?: layout_colorsMaxOrderByAggregateInput
    _min?: layout_colorsMinOrderByAggregateInput
    _sum?: layout_colorsSumOrderByAggregateInput
  }

  export type layout_colorsScalarWhereWithAggregatesInput = {
    AND?: layout_colorsScalarWhereWithAggregatesInput | layout_colorsScalarWhereWithAggregatesInput[]
    OR?: layout_colorsScalarWhereWithAggregatesInput[]
    NOT?: layout_colorsScalarWhereWithAggregatesInput | layout_colorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"layout_colors"> | number
    settings_id?: IntNullableWithAggregatesFilter<"layout_colors"> | number | null
    name?: StringWithAggregatesFilter<"layout_colors"> | string
    hexadecimal?: StringWithAggregatesFilter<"layout_colors"> | string
  }

  export type live_casino_most_popularWhereInput = {
    AND?: live_casino_most_popularWhereInput | live_casino_most_popularWhereInput[]
    OR?: live_casino_most_popularWhereInput[]
    NOT?: live_casino_most_popularWhereInput | live_casino_most_popularWhereInput[]
    id?: IntFilter<"live_casino_most_popular"> | number
    qty_lines?: IntFilter<"live_casino_most_popular"> | number
    qty_columns?: IntFilter<"live_casino_most_popular"> | number
    live_casino_most_popular_slot_games?: Live_casino_most_popular_slot_gamesListRelationFilter
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
  }

  export type live_casino_most_popularOrderByWithRelationInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesOrderByRelationAggregateInput
    slot_settings?: slot_settingsOrderByWithRelationInput
  }

  export type live_casino_most_popularWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: live_casino_most_popularWhereInput | live_casino_most_popularWhereInput[]
    OR?: live_casino_most_popularWhereInput[]
    NOT?: live_casino_most_popularWhereInput | live_casino_most_popularWhereInput[]
    qty_lines?: IntFilter<"live_casino_most_popular"> | number
    qty_columns?: IntFilter<"live_casino_most_popular"> | number
    live_casino_most_popular_slot_games?: Live_casino_most_popular_slot_gamesListRelationFilter
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
  }, "id">

  export type live_casino_most_popularOrderByWithAggregationInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
    _count?: live_casino_most_popularCountOrderByAggregateInput
    _avg?: live_casino_most_popularAvgOrderByAggregateInput
    _max?: live_casino_most_popularMaxOrderByAggregateInput
    _min?: live_casino_most_popularMinOrderByAggregateInput
    _sum?: live_casino_most_popularSumOrderByAggregateInput
  }

  export type live_casino_most_popularScalarWhereWithAggregatesInput = {
    AND?: live_casino_most_popularScalarWhereWithAggregatesInput | live_casino_most_popularScalarWhereWithAggregatesInput[]
    OR?: live_casino_most_popularScalarWhereWithAggregatesInput[]
    NOT?: live_casino_most_popularScalarWhereWithAggregatesInput | live_casino_most_popularScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"live_casino_most_popular"> | number
    qty_lines?: IntWithAggregatesFilter<"live_casino_most_popular"> | number
    qty_columns?: IntWithAggregatesFilter<"live_casino_most_popular"> | number
  }

  export type live_casino_most_popular_slot_gamesWhereInput = {
    AND?: live_casino_most_popular_slot_gamesWhereInput | live_casino_most_popular_slot_gamesWhereInput[]
    OR?: live_casino_most_popular_slot_gamesWhereInput[]
    NOT?: live_casino_most_popular_slot_gamesWhereInput | live_casino_most_popular_slot_gamesWhereInput[]
    live_casino_most_popular_id?: IntFilter<"live_casino_most_popular_slot_games"> | number
    slot_games_id?: IntFilter<"live_casino_most_popular_slot_games"> | number
    live_casino_most_popular?: XOR<Live_casino_most_popularRelationFilter, live_casino_most_popularWhereInput>
    slot_games?: XOR<Slot_gamesRelationFilter, slot_gamesWhereInput>
  }

  export type live_casino_most_popular_slot_gamesOrderByWithRelationInput = {
    live_casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
    live_casino_most_popular?: live_casino_most_popularOrderByWithRelationInput
    slot_games?: slot_gamesOrderByWithRelationInput
  }

  export type live_casino_most_popular_slot_gamesWhereUniqueInput = Prisma.AtLeast<{
    live_casino_most_popular_id_slot_games_id?: live_casino_most_popular_slot_gamesLive_casino_most_popular_idSlot_games_idCompoundUniqueInput
    AND?: live_casino_most_popular_slot_gamesWhereInput | live_casino_most_popular_slot_gamesWhereInput[]
    OR?: live_casino_most_popular_slot_gamesWhereInput[]
    NOT?: live_casino_most_popular_slot_gamesWhereInput | live_casino_most_popular_slot_gamesWhereInput[]
    live_casino_most_popular_id?: IntFilter<"live_casino_most_popular_slot_games"> | number
    slot_games_id?: IntFilter<"live_casino_most_popular_slot_games"> | number
    live_casino_most_popular?: XOR<Live_casino_most_popularRelationFilter, live_casino_most_popularWhereInput>
    slot_games?: XOR<Slot_gamesRelationFilter, slot_gamesWhereInput>
  }, "live_casino_most_popular_id_slot_games_id">

  export type live_casino_most_popular_slot_gamesOrderByWithAggregationInput = {
    live_casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
    _count?: live_casino_most_popular_slot_gamesCountOrderByAggregateInput
    _avg?: live_casino_most_popular_slot_gamesAvgOrderByAggregateInput
    _max?: live_casino_most_popular_slot_gamesMaxOrderByAggregateInput
    _min?: live_casino_most_popular_slot_gamesMinOrderByAggregateInput
    _sum?: live_casino_most_popular_slot_gamesSumOrderByAggregateInput
  }

  export type live_casino_most_popular_slot_gamesScalarWhereWithAggregatesInput = {
    AND?: live_casino_most_popular_slot_gamesScalarWhereWithAggregatesInput | live_casino_most_popular_slot_gamesScalarWhereWithAggregatesInput[]
    OR?: live_casino_most_popular_slot_gamesScalarWhereWithAggregatesInput[]
    NOT?: live_casino_most_popular_slot_gamesScalarWhereWithAggregatesInput | live_casino_most_popular_slot_gamesScalarWhereWithAggregatesInput[]
    live_casino_most_popular_id?: IntWithAggregatesFilter<"live_casino_most_popular_slot_games"> | number
    slot_games_id?: IntWithAggregatesFilter<"live_casino_most_popular_slot_games"> | number
  }

  export type messenger_messagesWhereInput = {
    AND?: messenger_messagesWhereInput | messenger_messagesWhereInput[]
    OR?: messenger_messagesWhereInput[]
    NOT?: messenger_messagesWhereInput | messenger_messagesWhereInput[]
    id?: BigIntFilter<"messenger_messages"> | bigint | number
    body?: StringFilter<"messenger_messages"> | string
    headers?: StringFilter<"messenger_messages"> | string
    queue_name?: StringFilter<"messenger_messages"> | string
    created_at?: DateTimeFilter<"messenger_messages"> | Date | string
    available_at?: DateTimeFilter<"messenger_messages"> | Date | string
    delivered_at?: DateTimeNullableFilter<"messenger_messages"> | Date | string | null
  }

  export type messenger_messagesOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrderInput | SortOrder
  }

  export type messenger_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: messenger_messagesWhereInput | messenger_messagesWhereInput[]
    OR?: messenger_messagesWhereInput[]
    NOT?: messenger_messagesWhereInput | messenger_messagesWhereInput[]
    body?: StringFilter<"messenger_messages"> | string
    headers?: StringFilter<"messenger_messages"> | string
    queue_name?: StringFilter<"messenger_messages"> | string
    created_at?: DateTimeFilter<"messenger_messages"> | Date | string
    available_at?: DateTimeFilter<"messenger_messages"> | Date | string
    delivered_at?: DateTimeNullableFilter<"messenger_messages"> | Date | string | null
  }, "id">

  export type messenger_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrderInput | SortOrder
    _count?: messenger_messagesCountOrderByAggregateInput
    _avg?: messenger_messagesAvgOrderByAggregateInput
    _max?: messenger_messagesMaxOrderByAggregateInput
    _min?: messenger_messagesMinOrderByAggregateInput
    _sum?: messenger_messagesSumOrderByAggregateInput
  }

  export type messenger_messagesScalarWhereWithAggregatesInput = {
    AND?: messenger_messagesScalarWhereWithAggregatesInput | messenger_messagesScalarWhereWithAggregatesInput[]
    OR?: messenger_messagesScalarWhereWithAggregatesInput[]
    NOT?: messenger_messagesScalarWhereWithAggregatesInput | messenger_messagesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"messenger_messages"> | bigint | number
    body?: StringWithAggregatesFilter<"messenger_messages"> | string
    headers?: StringWithAggregatesFilter<"messenger_messages"> | string
    queue_name?: StringWithAggregatesFilter<"messenger_messages"> | string
    created_at?: DateTimeWithAggregatesFilter<"messenger_messages"> | Date | string
    available_at?: DateTimeWithAggregatesFilter<"messenger_messages"> | Date | string
    delivered_at?: DateTimeNullableWithAggregatesFilter<"messenger_messages"> | Date | string | null
  }

  export type operationsWhereInput = {
    AND?: operationsWhereInput | operationsWhereInput[]
    OR?: operationsWhereInput[]
    NOT?: operationsWhereInput | operationsWhereInput[]
    id?: IntFilter<"operations"> | number
    active?: BoolFilter<"operations"> | boolean
    whithdraw_minimum?: FloatFilter<"operations"> | number
    withdraw_maximum?: FloatFilter<"operations"> | number
    withdraw_fee?: FloatFilter<"operations"> | number
    deposit_minimum?: FloatFilter<"operations"> | number
    deposit_maximum?: FloatFilter<"operations"> | number
    created_at?: DateTimeFilter<"operations"> | Date | string
    updated_at?: DateTimeFilter<"operations"> | Date | string
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
  }

  export type operationsOrderByWithRelationInput = {
    id?: SortOrder
    active?: SortOrder
    whithdraw_minimum?: SortOrder
    withdraw_maximum?: SortOrder
    withdraw_fee?: SortOrder
    deposit_minimum?: SortOrder
    deposit_maximum?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    settings?: settingsOrderByWithRelationInput
  }

  export type operationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: operationsWhereInput | operationsWhereInput[]
    OR?: operationsWhereInput[]
    NOT?: operationsWhereInput | operationsWhereInput[]
    active?: BoolFilter<"operations"> | boolean
    whithdraw_minimum?: FloatFilter<"operations"> | number
    withdraw_maximum?: FloatFilter<"operations"> | number
    withdraw_fee?: FloatFilter<"operations"> | number
    deposit_minimum?: FloatFilter<"operations"> | number
    deposit_maximum?: FloatFilter<"operations"> | number
    created_at?: DateTimeFilter<"operations"> | Date | string
    updated_at?: DateTimeFilter<"operations"> | Date | string
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
  }, "id">

  export type operationsOrderByWithAggregationInput = {
    id?: SortOrder
    active?: SortOrder
    whithdraw_minimum?: SortOrder
    withdraw_maximum?: SortOrder
    withdraw_fee?: SortOrder
    deposit_minimum?: SortOrder
    deposit_maximum?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: operationsCountOrderByAggregateInput
    _avg?: operationsAvgOrderByAggregateInput
    _max?: operationsMaxOrderByAggregateInput
    _min?: operationsMinOrderByAggregateInput
    _sum?: operationsSumOrderByAggregateInput
  }

  export type operationsScalarWhereWithAggregatesInput = {
    AND?: operationsScalarWhereWithAggregatesInput | operationsScalarWhereWithAggregatesInput[]
    OR?: operationsScalarWhereWithAggregatesInput[]
    NOT?: operationsScalarWhereWithAggregatesInput | operationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"operations"> | number
    active?: BoolWithAggregatesFilter<"operations"> | boolean
    whithdraw_minimum?: FloatWithAggregatesFilter<"operations"> | number
    withdraw_maximum?: FloatWithAggregatesFilter<"operations"> | number
    withdraw_fee?: FloatWithAggregatesFilter<"operations"> | number
    deposit_minimum?: FloatWithAggregatesFilter<"operations"> | number
    deposit_maximum?: FloatWithAggregatesFilter<"operations"> | number
    created_at?: DateTimeWithAggregatesFilter<"operations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"operations"> | Date | string
  }

  export type providerWhereInput = {
    AND?: providerWhereInput | providerWhereInput[]
    OR?: providerWhereInput[]
    NOT?: providerWhereInput | providerWhereInput[]
    id?: IntFilter<"provider"> | number
    name?: StringFilter<"provider"> | string
    client_percent?: IntNullableFilter<"provider"> | number | null
    base_percent?: IntNullableFilter<"provider"> | number | null
    slot_games?: Slot_gamesListRelationFilter
  }

  export type providerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    client_percent?: SortOrderInput | SortOrder
    base_percent?: SortOrderInput | SortOrder
    slot_games?: slot_gamesOrderByRelationAggregateInput
  }

  export type providerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: providerWhereInput | providerWhereInput[]
    OR?: providerWhereInput[]
    NOT?: providerWhereInput | providerWhereInput[]
    name?: StringFilter<"provider"> | string
    client_percent?: IntNullableFilter<"provider"> | number | null
    base_percent?: IntNullableFilter<"provider"> | number | null
    slot_games?: Slot_gamesListRelationFilter
  }, "id">

  export type providerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    client_percent?: SortOrderInput | SortOrder
    base_percent?: SortOrderInput | SortOrder
    _count?: providerCountOrderByAggregateInput
    _avg?: providerAvgOrderByAggregateInput
    _max?: providerMaxOrderByAggregateInput
    _min?: providerMinOrderByAggregateInput
    _sum?: providerSumOrderByAggregateInput
  }

  export type providerScalarWhereWithAggregatesInput = {
    AND?: providerScalarWhereWithAggregatesInput | providerScalarWhereWithAggregatesInput[]
    OR?: providerScalarWhereWithAggregatesInput[]
    NOT?: providerScalarWhereWithAggregatesInput | providerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"provider"> | number
    name?: StringWithAggregatesFilter<"provider"> | string
    client_percent?: IntNullableWithAggregatesFilter<"provider"> | number | null
    base_percent?: IntNullableWithAggregatesFilter<"provider"> | number | null
  }

  export type referral_historyWhereInput = {
    AND?: referral_historyWhereInput | referral_historyWhereInput[]
    OR?: referral_historyWhereInput[]
    NOT?: referral_historyWhereInput | referral_historyWhereInput[]
    id?: IntFilter<"referral_history"> | number
    referral_id?: IntFilter<"referral_history"> | number
    user_id?: IntNullableFilter<"referral_history"> | number | null
    game?: StringNullableFilter<"referral_history"> | string | null
    amount?: FloatNullableFilter<"referral_history"> | number | null
    type?: StringNullableFilter<"referral_history"> | string | null
    available?: BoolNullableFilter<"referral_history"> | boolean | null
    created_at?: DateTimeNullableFilter<"referral_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"referral_history"> | Date | string | null
    user_referral_history_referral_idTouser?: XOR<UserRelationFilter, userWhereInput>
    user_referral_history_user_idTouser?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type referral_historyOrderByWithRelationInput = {
    id?: SortOrder
    referral_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    game?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    available?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_referral_history_referral_idTouser?: userOrderByWithRelationInput
    user_referral_history_user_idTouser?: userOrderByWithRelationInput
  }

  export type referral_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: referral_historyWhereInput | referral_historyWhereInput[]
    OR?: referral_historyWhereInput[]
    NOT?: referral_historyWhereInput | referral_historyWhereInput[]
    referral_id?: IntFilter<"referral_history"> | number
    user_id?: IntNullableFilter<"referral_history"> | number | null
    game?: StringNullableFilter<"referral_history"> | string | null
    amount?: FloatNullableFilter<"referral_history"> | number | null
    type?: StringNullableFilter<"referral_history"> | string | null
    available?: BoolNullableFilter<"referral_history"> | boolean | null
    created_at?: DateTimeNullableFilter<"referral_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"referral_history"> | Date | string | null
    user_referral_history_referral_idTouser?: XOR<UserRelationFilter, userWhereInput>
    user_referral_history_user_idTouser?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type referral_historyOrderByWithAggregationInput = {
    id?: SortOrder
    referral_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    game?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    available?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: referral_historyCountOrderByAggregateInput
    _avg?: referral_historyAvgOrderByAggregateInput
    _max?: referral_historyMaxOrderByAggregateInput
    _min?: referral_historyMinOrderByAggregateInput
    _sum?: referral_historySumOrderByAggregateInput
  }

  export type referral_historyScalarWhereWithAggregatesInput = {
    AND?: referral_historyScalarWhereWithAggregatesInput | referral_historyScalarWhereWithAggregatesInput[]
    OR?: referral_historyScalarWhereWithAggregatesInput[]
    NOT?: referral_historyScalarWhereWithAggregatesInput | referral_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"referral_history"> | number
    referral_id?: IntWithAggregatesFilter<"referral_history"> | number
    user_id?: IntNullableWithAggregatesFilter<"referral_history"> | number | null
    game?: StringNullableWithAggregatesFilter<"referral_history"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"referral_history"> | number | null
    type?: StringNullableWithAggregatesFilter<"referral_history"> | string | null
    available?: BoolNullableWithAggregatesFilter<"referral_history"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"referral_history"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"referral_history"> | Date | string | null
  }

  export type referral_settingsWhereInput = {
    AND?: referral_settingsWhereInput | referral_settingsWhereInput[]
    OR?: referral_settingsWhereInput[]
    NOT?: referral_settingsWhereInput | referral_settingsWhereInput[]
    id?: IntFilter<"referral_settings"> | number
    cpa?: IntNullableFilter<"referral_settings"> | number | null
    rev_share_percent?: IntNullableFilter<"referral_settings"> | number | null
    referral_type?: StringNullableFilter<"referral_settings"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type referral_settingsOrderByWithRelationInput = {
    id?: SortOrder
    cpa?: SortOrderInput | SortOrder
    rev_share_percent?: SortOrderInput | SortOrder
    referral_type?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type referral_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: referral_settingsWhereInput | referral_settingsWhereInput[]
    OR?: referral_settingsWhereInput[]
    NOT?: referral_settingsWhereInput | referral_settingsWhereInput[]
    cpa?: IntNullableFilter<"referral_settings"> | number | null
    rev_share_percent?: IntNullableFilter<"referral_settings"> | number | null
    referral_type?: StringNullableFilter<"referral_settings"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type referral_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    cpa?: SortOrderInput | SortOrder
    rev_share_percent?: SortOrderInput | SortOrder
    referral_type?: SortOrderInput | SortOrder
    _count?: referral_settingsCountOrderByAggregateInput
    _avg?: referral_settingsAvgOrderByAggregateInput
    _max?: referral_settingsMaxOrderByAggregateInput
    _min?: referral_settingsMinOrderByAggregateInput
    _sum?: referral_settingsSumOrderByAggregateInput
  }

  export type referral_settingsScalarWhereWithAggregatesInput = {
    AND?: referral_settingsScalarWhereWithAggregatesInput | referral_settingsScalarWhereWithAggregatesInput[]
    OR?: referral_settingsScalarWhereWithAggregatesInput[]
    NOT?: referral_settingsScalarWhereWithAggregatesInput | referral_settingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"referral_settings"> | number
    cpa?: IntNullableWithAggregatesFilter<"referral_settings"> | number | null
    rev_share_percent?: IntNullableWithAggregatesFilter<"referral_settings"> | number | null
    referral_type?: StringNullableWithAggregatesFilter<"referral_settings"> | string | null
  }

  export type settingsWhereInput = {
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    id?: IntFilter<"settings"> | number
    operations_id?: IntNullableFilter<"settings"> | number | null
    slot_settings_id?: IntNullableFilter<"settings"> | number | null
    client_id?: IntFilter<"settings"> | number
    created_at?: DateTimeFilter<"settings"> | Date | string
    updated_at?: DateTimeFilter<"settings"> | Date | string
    client_client_settings_idTosettings?: XOR<ClientNullableRelationFilter, clientWhereInput> | null
    layout_colors?: Layout_colorsListRelationFilter
    client_settings_client_idToclient?: XOR<ClientRelationFilter, clientWhereInput>
    operations?: XOR<OperationsNullableRelationFilter, operationsWhereInput> | null
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
  }

  export type settingsOrderByWithRelationInput = {
    id?: SortOrder
    operations_id?: SortOrderInput | SortOrder
    slot_settings_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client_client_settings_idTosettings?: clientOrderByWithRelationInput
    layout_colors?: layout_colorsOrderByRelationAggregateInput
    client_settings_client_idToclient?: clientOrderByWithRelationInput
    operations?: operationsOrderByWithRelationInput
    slot_settings?: slot_settingsOrderByWithRelationInput
  }

  export type settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    operations_id?: number
    slot_settings_id?: number
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    client_id?: IntFilter<"settings"> | number
    created_at?: DateTimeFilter<"settings"> | Date | string
    updated_at?: DateTimeFilter<"settings"> | Date | string
    client_client_settings_idTosettings?: XOR<ClientNullableRelationFilter, clientWhereInput> | null
    layout_colors?: Layout_colorsListRelationFilter
    client_settings_client_idToclient?: XOR<ClientRelationFilter, clientWhereInput>
    operations?: XOR<OperationsNullableRelationFilter, operationsWhereInput> | null
    slot_settings?: XOR<Slot_settingsNullableRelationFilter, slot_settingsWhereInput> | null
  }, "id" | "operations_id" | "slot_settings_id">

  export type settingsOrderByWithAggregationInput = {
    id?: SortOrder
    operations_id?: SortOrderInput | SortOrder
    slot_settings_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: settingsCountOrderByAggregateInput
    _avg?: settingsAvgOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
    _sum?: settingsSumOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    OR?: settingsScalarWhereWithAggregatesInput[]
    NOT?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"settings"> | number
    operations_id?: IntNullableWithAggregatesFilter<"settings"> | number | null
    slot_settings_id?: IntNullableWithAggregatesFilter<"settings"> | number | null
    client_id?: IntWithAggregatesFilter<"settings"> | number
    created_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string
  }

  export type slot_gamesWhereInput = {
    AND?: slot_gamesWhereInput | slot_gamesWhereInput[]
    OR?: slot_gamesWhereInput[]
    NOT?: slot_gamesWhereInput | slot_gamesWhereInput[]
    id?: IntFilter<"slot_games"> | number
    provider_id?: IntFilter<"slot_games"> | number
    uuid?: StringFilter<"slot_games"> | string
    name?: StringFilter<"slot_games"> | string
    image?: StringFilter<"slot_games"> | string
    type?: StringFilter<"slot_games"> | string
    has_lobby?: BoolFilter<"slot_games"> | boolean
    is_mobile?: BoolFilter<"slot_games"> | boolean
    has_freespins?: BoolFilter<"slot_games"> | boolean
    has_tables?: BoolFilter<"slot_games"> | boolean
    freespin_valid_until_full_day?: BoolFilter<"slot_games"> | boolean
    slug?: StringNullableFilter<"slot_games"> | string | null
    bet_operations?: Bet_operationsListRelationFilter
    casino_most_popular_slot_games?: Casino_most_popular_slot_gamesListRelationFilter
    live_casino_most_popular_slot_games?: Live_casino_most_popular_slot_gamesListRelationFilter
    provider?: XOR<ProviderRelationFilter, providerWhereInput>
  }

  export type slot_gamesOrderByWithRelationInput = {
    id?: SortOrder
    provider_id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    has_lobby?: SortOrder
    is_mobile?: SortOrder
    has_freespins?: SortOrder
    has_tables?: SortOrder
    freespin_valid_until_full_day?: SortOrder
    slug?: SortOrderInput | SortOrder
    bet_operations?: bet_operationsOrderByRelationAggregateInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesOrderByRelationAggregateInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesOrderByRelationAggregateInput
    provider?: providerOrderByWithRelationInput
  }

  export type slot_gamesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: slot_gamesWhereInput | slot_gamesWhereInput[]
    OR?: slot_gamesWhereInput[]
    NOT?: slot_gamesWhereInput | slot_gamesWhereInput[]
    provider_id?: IntFilter<"slot_games"> | number
    uuid?: StringFilter<"slot_games"> | string
    name?: StringFilter<"slot_games"> | string
    image?: StringFilter<"slot_games"> | string
    type?: StringFilter<"slot_games"> | string
    has_lobby?: BoolFilter<"slot_games"> | boolean
    is_mobile?: BoolFilter<"slot_games"> | boolean
    has_freespins?: BoolFilter<"slot_games"> | boolean
    has_tables?: BoolFilter<"slot_games"> | boolean
    freespin_valid_until_full_day?: BoolFilter<"slot_games"> | boolean
    slug?: StringNullableFilter<"slot_games"> | string | null
    bet_operations?: Bet_operationsListRelationFilter
    casino_most_popular_slot_games?: Casino_most_popular_slot_gamesListRelationFilter
    live_casino_most_popular_slot_games?: Live_casino_most_popular_slot_gamesListRelationFilter
    provider?: XOR<ProviderRelationFilter, providerWhereInput>
  }, "id">

  export type slot_gamesOrderByWithAggregationInput = {
    id?: SortOrder
    provider_id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    has_lobby?: SortOrder
    is_mobile?: SortOrder
    has_freespins?: SortOrder
    has_tables?: SortOrder
    freespin_valid_until_full_day?: SortOrder
    slug?: SortOrderInput | SortOrder
    _count?: slot_gamesCountOrderByAggregateInput
    _avg?: slot_gamesAvgOrderByAggregateInput
    _max?: slot_gamesMaxOrderByAggregateInput
    _min?: slot_gamesMinOrderByAggregateInput
    _sum?: slot_gamesSumOrderByAggregateInput
  }

  export type slot_gamesScalarWhereWithAggregatesInput = {
    AND?: slot_gamesScalarWhereWithAggregatesInput | slot_gamesScalarWhereWithAggregatesInput[]
    OR?: slot_gamesScalarWhereWithAggregatesInput[]
    NOT?: slot_gamesScalarWhereWithAggregatesInput | slot_gamesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"slot_games"> | number
    provider_id?: IntWithAggregatesFilter<"slot_games"> | number
    uuid?: StringWithAggregatesFilter<"slot_games"> | string
    name?: StringWithAggregatesFilter<"slot_games"> | string
    image?: StringWithAggregatesFilter<"slot_games"> | string
    type?: StringWithAggregatesFilter<"slot_games"> | string
    has_lobby?: BoolWithAggregatesFilter<"slot_games"> | boolean
    is_mobile?: BoolWithAggregatesFilter<"slot_games"> | boolean
    has_freespins?: BoolWithAggregatesFilter<"slot_games"> | boolean
    has_tables?: BoolWithAggregatesFilter<"slot_games"> | boolean
    freespin_valid_until_full_day?: BoolWithAggregatesFilter<"slot_games"> | boolean
    slug?: StringNullableWithAggregatesFilter<"slot_games"> | string | null
  }

  export type slot_settingsWhereInput = {
    AND?: slot_settingsWhereInput | slot_settingsWhereInput[]
    OR?: slot_settingsWhereInput[]
    NOT?: slot_settingsWhereInput | slot_settingsWhereInput[]
    id?: IntFilter<"slot_settings"> | number
    casino_most_popular_id?: IntNullableFilter<"slot_settings"> | number | null
    live_casino_most_popular_id?: IntNullableFilter<"slot_settings"> | number | null
    banner_more_profitable?: Banner_more_profitableListRelationFilter
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
    live_casino_most_popular?: XOR<Live_casino_most_popularNullableRelationFilter, live_casino_most_popularWhereInput> | null
    casino_most_popular?: XOR<Casino_most_popularNullableRelationFilter, casino_most_popularWhereInput> | null
  }

  export type slot_settingsOrderByWithRelationInput = {
    id?: SortOrder
    casino_most_popular_id?: SortOrderInput | SortOrder
    live_casino_most_popular_id?: SortOrderInput | SortOrder
    banner_more_profitable?: banner_more_profitableOrderByRelationAggregateInput
    settings?: settingsOrderByWithRelationInput
    live_casino_most_popular?: live_casino_most_popularOrderByWithRelationInput
    casino_most_popular?: casino_most_popularOrderByWithRelationInput
  }

  export type slot_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    casino_most_popular_id?: number
    live_casino_most_popular_id?: number
    AND?: slot_settingsWhereInput | slot_settingsWhereInput[]
    OR?: slot_settingsWhereInput[]
    NOT?: slot_settingsWhereInput | slot_settingsWhereInput[]
    banner_more_profitable?: Banner_more_profitableListRelationFilter
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
    live_casino_most_popular?: XOR<Live_casino_most_popularNullableRelationFilter, live_casino_most_popularWhereInput> | null
    casino_most_popular?: XOR<Casino_most_popularNullableRelationFilter, casino_most_popularWhereInput> | null
  }, "id" | "casino_most_popular_id" | "live_casino_most_popular_id">

  export type slot_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    casino_most_popular_id?: SortOrderInput | SortOrder
    live_casino_most_popular_id?: SortOrderInput | SortOrder
    _count?: slot_settingsCountOrderByAggregateInput
    _avg?: slot_settingsAvgOrderByAggregateInput
    _max?: slot_settingsMaxOrderByAggregateInput
    _min?: slot_settingsMinOrderByAggregateInput
    _sum?: slot_settingsSumOrderByAggregateInput
  }

  export type slot_settingsScalarWhereWithAggregatesInput = {
    AND?: slot_settingsScalarWhereWithAggregatesInput | slot_settingsScalarWhereWithAggregatesInput[]
    OR?: slot_settingsScalarWhereWithAggregatesInput[]
    NOT?: slot_settingsScalarWhereWithAggregatesInput | slot_settingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"slot_settings"> | number
    casino_most_popular_id?: IntNullableWithAggregatesFilter<"slot_settings"> | number | null
    live_casino_most_popular_id?: IntNullableWithAggregatesFilter<"slot_settings"> | number | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    wallet_id?: IntFilter<"user"> | number
    client_id?: IntFilter<"user"> | number
    referral_id?: IntNullableFilter<"user"> | number | null
    referral_settings_id?: IntNullableFilter<"user"> | number | null
    external_id?: IntFilter<"user"> | number
    username?: StringFilter<"user"> | string
    balance?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    session?: StringNullableFilter<"user"> | string | null
    cpa_collected?: BoolNullableFilter<"user"> | boolean | null
    is_referrer?: BoolNullableFilter<"user"> | boolean | null
    bet_operations?: Bet_operationsListRelationFilter
    referral_history_referral_history_referral_idTouser?: Referral_historyListRelationFilter
    referral_history_referral_history_user_idTouser?: Referral_historyListRelationFilter
    client?: XOR<ClientRelationFilter, clientWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    other_user?: UserListRelationFilter
    referral_settings?: XOR<Referral_settingsNullableRelationFilter, referral_settingsWhereInput> | null
    wallet?: XOR<WalletRelationFilter, walletWhereInput>
    wallet_transaction?: Wallet_transactionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    client_id?: SortOrder
    referral_id?: SortOrderInput | SortOrder
    referral_settings_id?: SortOrderInput | SortOrder
    external_id?: SortOrder
    username?: SortOrder
    balance?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    session?: SortOrderInput | SortOrder
    cpa_collected?: SortOrderInput | SortOrder
    is_referrer?: SortOrderInput | SortOrder
    bet_operations?: bet_operationsOrderByRelationAggregateInput
    referral_history_referral_history_referral_idTouser?: referral_historyOrderByRelationAggregateInput
    referral_history_referral_history_user_idTouser?: referral_historyOrderByRelationAggregateInput
    client?: clientOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    other_user?: userOrderByRelationAggregateInput
    referral_settings?: referral_settingsOrderByWithRelationInput
    wallet?: walletOrderByWithRelationInput
    wallet_transaction?: wallet_transactionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    wallet_id?: number
    referral_settings_id?: number
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    client_id?: IntFilter<"user"> | number
    referral_id?: IntNullableFilter<"user"> | number | null
    external_id?: IntFilter<"user"> | number
    username?: StringFilter<"user"> | string
    balance?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    session?: StringNullableFilter<"user"> | string | null
    cpa_collected?: BoolNullableFilter<"user"> | boolean | null
    is_referrer?: BoolNullableFilter<"user"> | boolean | null
    bet_operations?: Bet_operationsListRelationFilter
    referral_history_referral_history_referral_idTouser?: Referral_historyListRelationFilter
    referral_history_referral_history_user_idTouser?: Referral_historyListRelationFilter
    client?: XOR<ClientRelationFilter, clientWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    other_user?: UserListRelationFilter
    referral_settings?: XOR<Referral_settingsNullableRelationFilter, referral_settingsWhereInput> | null
    wallet?: XOR<WalletRelationFilter, walletWhereInput>
    wallet_transaction?: Wallet_transactionListRelationFilter
  }, "id" | "wallet_id" | "referral_settings_id">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    client_id?: SortOrder
    referral_id?: SortOrderInput | SortOrder
    referral_settings_id?: SortOrderInput | SortOrder
    external_id?: SortOrder
    username?: SortOrder
    balance?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    session?: SortOrderInput | SortOrder
    cpa_collected?: SortOrderInput | SortOrder
    is_referrer?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    wallet_id?: IntWithAggregatesFilter<"user"> | number
    client_id?: IntWithAggregatesFilter<"user"> | number
    referral_id?: IntNullableWithAggregatesFilter<"user"> | number | null
    referral_settings_id?: IntNullableWithAggregatesFilter<"user"> | number | null
    external_id?: IntWithAggregatesFilter<"user"> | number
    username?: StringWithAggregatesFilter<"user"> | string
    balance?: DecimalNullableWithAggregatesFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    session?: StringNullableWithAggregatesFilter<"user"> | string | null
    cpa_collected?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    is_referrer?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
  }

  export type walletWhereInput = {
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    id?: IntFilter<"wallet"> | number
    balance?: FloatNullableFilter<"wallet"> | number | null
    bonus?: FloatNullableFilter<"wallet"> | number | null
    bet?: FloatNullableFilter<"wallet"> | number | null
    withdraw?: FloatNullableFilter<"wallet"> | number | null
    deposit?: FloatNullableFilter<"wallet"> | number | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    wallet_transaction?: Wallet_transactionListRelationFilter
  }

  export type walletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrderInput | SortOrder
    bonus?: SortOrderInput | SortOrder
    bet?: SortOrderInput | SortOrder
    withdraw?: SortOrderInput | SortOrder
    deposit?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    wallet_transaction?: wallet_transactionOrderByRelationAggregateInput
  }

  export type walletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    balance?: FloatNullableFilter<"wallet"> | number | null
    bonus?: FloatNullableFilter<"wallet"> | number | null
    bet?: FloatNullableFilter<"wallet"> | number | null
    withdraw?: FloatNullableFilter<"wallet"> | number | null
    deposit?: FloatNullableFilter<"wallet"> | number | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    wallet_transaction?: Wallet_transactionListRelationFilter
  }, "id">

  export type walletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrderInput | SortOrder
    bonus?: SortOrderInput | SortOrder
    bet?: SortOrderInput | SortOrder
    withdraw?: SortOrderInput | SortOrder
    deposit?: SortOrderInput | SortOrder
    _count?: walletCountOrderByAggregateInput
    _avg?: walletAvgOrderByAggregateInput
    _max?: walletMaxOrderByAggregateInput
    _min?: walletMinOrderByAggregateInput
    _sum?: walletSumOrderByAggregateInput
  }

  export type walletScalarWhereWithAggregatesInput = {
    AND?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    OR?: walletScalarWhereWithAggregatesInput[]
    NOT?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet"> | number
    balance?: FloatNullableWithAggregatesFilter<"wallet"> | number | null
    bonus?: FloatNullableWithAggregatesFilter<"wallet"> | number | null
    bet?: FloatNullableWithAggregatesFilter<"wallet"> | number | null
    withdraw?: FloatNullableWithAggregatesFilter<"wallet"> | number | null
    deposit?: FloatNullableWithAggregatesFilter<"wallet"> | number | null
  }

  export type wallet_transactionWhereInput = {
    AND?: wallet_transactionWhereInput | wallet_transactionWhereInput[]
    OR?: wallet_transactionWhereInput[]
    NOT?: wallet_transactionWhereInput | wallet_transactionWhereInput[]
    id?: IntFilter<"wallet_transaction"> | number
    wallet_id?: IntFilter<"wallet_transaction"> | number
    amount?: FloatFilter<"wallet_transaction"> | number
    created_at?: DateTimeFilter<"wallet_transaction"> | Date | string
    updated_at?: DateTimeFilter<"wallet_transaction"> | Date | string
    deleted_at?: DateTimeNullableFilter<"wallet_transaction"> | Date | string | null
    type?: StringFilter<"wallet_transaction"> | string
    api_collected?: BoolNullableFilter<"wallet_transaction"> | boolean | null
    user_id?: IntNullableFilter<"wallet_transaction"> | number | null
    uuid?: StringFilter<"wallet_transaction"> | string
    wallet?: XOR<WalletRelationFilter, walletWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type wallet_transactionOrderByWithRelationInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    type?: SortOrder
    api_collected?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    uuid?: SortOrder
    wallet?: walletOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type wallet_transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wallet_transactionWhereInput | wallet_transactionWhereInput[]
    OR?: wallet_transactionWhereInput[]
    NOT?: wallet_transactionWhereInput | wallet_transactionWhereInput[]
    wallet_id?: IntFilter<"wallet_transaction"> | number
    amount?: FloatFilter<"wallet_transaction"> | number
    created_at?: DateTimeFilter<"wallet_transaction"> | Date | string
    updated_at?: DateTimeFilter<"wallet_transaction"> | Date | string
    deleted_at?: DateTimeNullableFilter<"wallet_transaction"> | Date | string | null
    type?: StringFilter<"wallet_transaction"> | string
    api_collected?: BoolNullableFilter<"wallet_transaction"> | boolean | null
    user_id?: IntNullableFilter<"wallet_transaction"> | number | null
    uuid?: StringFilter<"wallet_transaction"> | string
    wallet?: XOR<WalletRelationFilter, walletWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type wallet_transactionOrderByWithAggregationInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    type?: SortOrder
    api_collected?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    uuid?: SortOrder
    _count?: wallet_transactionCountOrderByAggregateInput
    _avg?: wallet_transactionAvgOrderByAggregateInput
    _max?: wallet_transactionMaxOrderByAggregateInput
    _min?: wallet_transactionMinOrderByAggregateInput
    _sum?: wallet_transactionSumOrderByAggregateInput
  }

  export type wallet_transactionScalarWhereWithAggregatesInput = {
    AND?: wallet_transactionScalarWhereWithAggregatesInput | wallet_transactionScalarWhereWithAggregatesInput[]
    OR?: wallet_transactionScalarWhereWithAggregatesInput[]
    NOT?: wallet_transactionScalarWhereWithAggregatesInput | wallet_transactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet_transaction"> | number
    wallet_id?: IntWithAggregatesFilter<"wallet_transaction"> | number
    amount?: FloatWithAggregatesFilter<"wallet_transaction"> | number
    created_at?: DateTimeWithAggregatesFilter<"wallet_transaction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"wallet_transaction"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"wallet_transaction"> | Date | string | null
    type?: StringWithAggregatesFilter<"wallet_transaction"> | string
    api_collected?: BoolNullableWithAggregatesFilter<"wallet_transaction"> | boolean | null
    user_id?: IntNullableWithAggregatesFilter<"wallet_transaction"> | number | null
    uuid?: StringWithAggregatesFilter<"wallet_transaction"> | string
  }

  export type salsa_gamesWhereInput = {
    AND?: salsa_gamesWhereInput | salsa_gamesWhereInput[]
    OR?: salsa_gamesWhereInput[]
    NOT?: salsa_gamesWhereInput | salsa_gamesWhereInput[]
    id?: IntFilter<"salsa_games"> | number
    name?: StringFilter<"salsa_games"> | string
    code?: StringFilter<"salsa_games"> | string
    isSlot?: BoolFilter<"salsa_games"> | boolean
    created_at?: DateTimeFilter<"salsa_games"> | Date | string
    updated_at?: DateTimeFilter<"salsa_games"> | Date | string
    deleted_at?: DateTimeNullableFilter<"salsa_games"> | Date | string | null
  }

  export type salsa_gamesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isSlot?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
  }

  export type salsa_gamesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: salsa_gamesWhereInput | salsa_gamesWhereInput[]
    OR?: salsa_gamesWhereInput[]
    NOT?: salsa_gamesWhereInput | salsa_gamesWhereInput[]
    name?: StringFilter<"salsa_games"> | string
    code?: StringFilter<"salsa_games"> | string
    isSlot?: BoolFilter<"salsa_games"> | boolean
    created_at?: DateTimeFilter<"salsa_games"> | Date | string
    updated_at?: DateTimeFilter<"salsa_games"> | Date | string
    deleted_at?: DateTimeNullableFilter<"salsa_games"> | Date | string | null
  }, "id">

  export type salsa_gamesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isSlot?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: salsa_gamesCountOrderByAggregateInput
    _avg?: salsa_gamesAvgOrderByAggregateInput
    _max?: salsa_gamesMaxOrderByAggregateInput
    _min?: salsa_gamesMinOrderByAggregateInput
    _sum?: salsa_gamesSumOrderByAggregateInput
  }

  export type salsa_gamesScalarWhereWithAggregatesInput = {
    AND?: salsa_gamesScalarWhereWithAggregatesInput | salsa_gamesScalarWhereWithAggregatesInput[]
    OR?: salsa_gamesScalarWhereWithAggregatesInput[]
    NOT?: salsa_gamesScalarWhereWithAggregatesInput | salsa_gamesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"salsa_games"> | number
    name?: StringWithAggregatesFilter<"salsa_games"> | string
    code?: StringWithAggregatesFilter<"salsa_games"> | string
    isSlot?: BoolWithAggregatesFilter<"salsa_games"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"salsa_games"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"salsa_games"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"salsa_games"> | Date | string | null
  }

  export type api_requestCreateInput = {
    name: string
    request: JsonNullValueInput | InputJsonValue
    response: JsonNullValueInput | InputJsonValue
    created_at: Date | string
  }

  export type api_requestUncheckedCreateInput = {
    id?: number
    name: string
    request: JsonNullValueInput | InputJsonValue
    response: JsonNullValueInput | InputJsonValue
    created_at: Date | string
  }

  export type api_requestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_requestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_requestCreateManyInput = {
    id?: number
    name: string
    request: JsonNullValueInput | InputJsonValue
    response: JsonNullValueInput | InputJsonValue
    created_at: Date | string
  }

  export type api_requestUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_requestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auth_userCreateInput = {
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    created_at: Date | string
    updated_at: Date | string
    username: string
    client_auth_user?: client_auth_userCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateInput = {
    id?: number
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    created_at: Date | string
    updated_at: Date | string
    username: string
    client_auth_user?: client_auth_userUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    client_auth_user?: client_auth_userUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    client_auth_user?: client_auth_userUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userCreateManyInput = {
    id?: number
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    created_at: Date | string
    updated_at: Date | string
    username: string
  }

  export type auth_userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type auth_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type banner_more_profitableCreateInput = {
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    slot_settings?: slot_settingsCreateNestedOneWithoutBanner_more_profitableInput
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitableUncheckedCreateInput = {
    id?: number
    banner_id?: number | null
    slot_settings_id?: number | null
    banner_file_id?: number | null
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
  }

  export type banner_more_profitableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutBanner_more_profitableNestedInput
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    banner_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_file_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type banner_more_profitableCreateManyInput = {
    id?: number
    banner_id?: number | null
    slot_settings_id?: number | null
    banner_file_id?: number | null
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
  }

  export type banner_more_profitableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type banner_more_profitableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    banner_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_file_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type banner_more_profitable_fileCreateInput = {
    file: string
    upload_at: Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitable_fileUncheckedCreateInput = {
    id?: number
    file: string
    upload_at: Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableUncheckedCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableUncheckedCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitable_fileUpdateInput = {
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitable_fileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableUncheckedUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableUncheckedUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitable_fileCreateManyInput = {
    id?: number
    file: string
    upload_at: Date | string
  }

  export type banner_more_profitable_fileUpdateManyMutationInput = {
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type banner_more_profitable_fileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bet_operationsCreateInput = {
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    user: userCreateNestedOneWithoutBet_operationsInput
    slot_games: slot_gamesCreateNestedOneWithoutBet_operationsInput
  }

  export type bet_operationsUncheckedCreateInput = {
    id?: number
    user_id: number
    slot_game_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type bet_operationsUpdateInput = {
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutBet_operationsNestedInput
    slot_games?: slot_gamesUpdateOneRequiredWithoutBet_operationsNestedInput
  }

  export type bet_operationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    slot_game_id?: IntFieldUpdateOperationsInput | number
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bet_operationsCreateManyInput = {
    id?: number
    user_id: number
    slot_game_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type bet_operationsUpdateManyMutationInput = {
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bet_operationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    slot_game_id?: IntFieldUpdateOperationsInput | number
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type casino_most_popularCreateInput = {
    qty_lines: number
    qty_columns: number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesCreateNestedManyWithoutCasino_most_popularInput
    slot_settings?: slot_settingsCreateNestedOneWithoutCasino_most_popularInput
  }

  export type casino_most_popularUncheckedCreateInput = {
    id?: number
    qty_lines: number
    qty_columns: number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutCasino_most_popularInput
    slot_settings?: slot_settingsUncheckedCreateNestedOneWithoutCasino_most_popularInput
  }

  export type casino_most_popularUpdateInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUpdateManyWithoutCasino_most_popularNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutCasino_most_popularNestedInput
  }

  export type casino_most_popularUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedUpdateManyWithoutCasino_most_popularNestedInput
    slot_settings?: slot_settingsUncheckedUpdateOneWithoutCasino_most_popularNestedInput
  }

  export type casino_most_popularCreateManyInput = {
    id?: number
    qty_lines: number
    qty_columns: number
  }

  export type casino_most_popularUpdateManyMutationInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
  }

  export type casino_most_popularUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
  }

  export type casino_most_popular_slot_gamesCreateInput = {
    slot_games: slot_gamesCreateNestedOneWithoutCasino_most_popular_slot_gamesInput
    casino_most_popular: casino_most_popularCreateNestedOneWithoutCasino_most_popular_slot_gamesInput
  }

  export type casino_most_popular_slot_gamesUncheckedCreateInput = {
    casino_most_popular_id: number
    slot_games_id: number
  }

  export type casino_most_popular_slot_gamesUpdateInput = {
    slot_games?: slot_gamesUpdateOneRequiredWithoutCasino_most_popular_slot_gamesNestedInput
    casino_most_popular?: casino_most_popularUpdateOneRequiredWithoutCasino_most_popular_slot_gamesNestedInput
  }

  export type casino_most_popular_slot_gamesUncheckedUpdateInput = {
    casino_most_popular_id?: IntFieldUpdateOperationsInput | number
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type casino_most_popular_slot_gamesCreateManyInput = {
    casino_most_popular_id: number
    slot_games_id: number
  }

  export type casino_most_popular_slot_gamesUpdateManyMutationInput = {

  }

  export type casino_most_popular_slot_gamesUncheckedUpdateManyInput = {
    casino_most_popular_id?: IntFieldUpdateOperationsInput | number
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type clientCreateInput = {
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    settings_client_settings_idTosettings?: settingsCreateNestedOneWithoutClient_client_settings_idTosettingsInput
    client_auth_user?: client_auth_userCreateNestedManyWithoutClientInput
    settings_settings_client_idToclient?: settingsCreateNestedManyWithoutClient_settings_client_idToclientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateInput = {
    id?: number
    settings_id?: number | null
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    client_auth_user?: client_auth_userUncheckedCreateNestedManyWithoutClientInput
    settings_settings_client_idToclient?: settingsUncheckedCreateNestedManyWithoutClient_settings_client_idToclientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientUpdateInput = {
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    settings_client_settings_idTosettings?: settingsUpdateOneWithoutClient_client_settings_idTosettingsNestedInput
    client_auth_user?: client_auth_userUpdateManyWithoutClientNestedInput
    settings_settings_client_idToclient?: settingsUpdateManyWithoutClient_settings_client_idToclientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    client_auth_user?: client_auth_userUncheckedUpdateManyWithoutClientNestedInput
    settings_settings_client_idToclient?: settingsUncheckedUpdateManyWithoutClient_settings_client_idToclientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type clientCreateManyInput = {
    id?: number
    settings_id?: number | null
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
  }

  export type clientUpdateManyMutationInput = {
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_auth_userCreateInput = {
    client: clientCreateNestedOneWithoutClient_auth_userInput
    auth_user: auth_userCreateNestedOneWithoutClient_auth_userInput
  }

  export type client_auth_userUncheckedCreateInput = {
    client_id: number
    auth_user_id: number
  }

  export type client_auth_userUpdateInput = {
    client?: clientUpdateOneRequiredWithoutClient_auth_userNestedInput
    auth_user?: auth_userUpdateOneRequiredWithoutClient_auth_userNestedInput
  }

  export type client_auth_userUncheckedUpdateInput = {
    client_id?: IntFieldUpdateOperationsInput | number
    auth_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type client_auth_userCreateManyInput = {
    client_id: number
    auth_user_id: number
  }

  export type client_auth_userUpdateManyMutationInput = {

  }

  export type client_auth_userUncheckedUpdateManyInput = {
    client_id?: IntFieldUpdateOperationsInput | number
    auth_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type doctrine_migration_versionsCreateInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUncheckedCreateInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsCreateManyInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fileCreateInput = {
    file: string
    upload_at: Date | string
  }

  export type fileUncheckedCreateInput = {
    id?: number
    file: string
    upload_at: Date | string
  }

  export type fileUpdateInput = {
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fileCreateManyInput = {
    id?: number
    file: string
    upload_at: Date | string
  }

  export type fileUpdateManyMutationInput = {
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type layout_colorsCreateInput = {
    name: string
    hexadecimal: string
    settings?: settingsCreateNestedOneWithoutLayout_colorsInput
  }

  export type layout_colorsUncheckedCreateInput = {
    id?: number
    settings_id?: number | null
    name: string
    hexadecimal: string
  }

  export type layout_colorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    hexadecimal?: StringFieldUpdateOperationsInput | string
    settings?: settingsUpdateOneWithoutLayout_colorsNestedInput
  }

  export type layout_colorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    hexadecimal?: StringFieldUpdateOperationsInput | string
  }

  export type layout_colorsCreateManyInput = {
    id?: number
    settings_id?: number | null
    name: string
    hexadecimal: string
  }

  export type layout_colorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    hexadecimal?: StringFieldUpdateOperationsInput | string
  }

  export type layout_colorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    hexadecimal?: StringFieldUpdateOperationsInput | string
  }

  export type live_casino_most_popularCreateInput = {
    qty_lines: number
    qty_columns: number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesCreateNestedManyWithoutLive_casino_most_popularInput
    slot_settings?: slot_settingsCreateNestedOneWithoutLive_casino_most_popularInput
  }

  export type live_casino_most_popularUncheckedCreateInput = {
    id?: number
    qty_lines: number
    qty_columns: number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutLive_casino_most_popularInput
    slot_settings?: slot_settingsUncheckedCreateNestedOneWithoutLive_casino_most_popularInput
  }

  export type live_casino_most_popularUpdateInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUpdateManyWithoutLive_casino_most_popularNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutLive_casino_most_popularNestedInput
  }

  export type live_casino_most_popularUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutLive_casino_most_popularNestedInput
    slot_settings?: slot_settingsUncheckedUpdateOneWithoutLive_casino_most_popularNestedInput
  }

  export type live_casino_most_popularCreateManyInput = {
    id?: number
    qty_lines: number
    qty_columns: number
  }

  export type live_casino_most_popularUpdateManyMutationInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
  }

  export type live_casino_most_popularUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
  }

  export type live_casino_most_popular_slot_gamesCreateInput = {
    live_casino_most_popular: live_casino_most_popularCreateNestedOneWithoutLive_casino_most_popular_slot_gamesInput
    slot_games: slot_gamesCreateNestedOneWithoutLive_casino_most_popular_slot_gamesInput
  }

  export type live_casino_most_popular_slot_gamesUncheckedCreateInput = {
    live_casino_most_popular_id: number
    slot_games_id: number
  }

  export type live_casino_most_popular_slot_gamesUpdateInput = {
    live_casino_most_popular?: live_casino_most_popularUpdateOneRequiredWithoutLive_casino_most_popular_slot_gamesNestedInput
    slot_games?: slot_gamesUpdateOneRequiredWithoutLive_casino_most_popular_slot_gamesNestedInput
  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateInput = {
    live_casino_most_popular_id?: IntFieldUpdateOperationsInput | number
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type live_casino_most_popular_slot_gamesCreateManyInput = {
    live_casino_most_popular_id: number
    slot_games_id: number
  }

  export type live_casino_most_popular_slot_gamesUpdateManyMutationInput = {

  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateManyInput = {
    live_casino_most_popular_id?: IntFieldUpdateOperationsInput | number
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type messenger_messagesCreateInput = {
    id?: bigint | number
    body: string
    headers: string
    queue_name: string
    created_at: Date | string
    available_at: Date | string
    delivered_at?: Date | string | null
  }

  export type messenger_messagesUncheckedCreateInput = {
    id?: bigint | number
    body: string
    headers: string
    queue_name: string
    created_at: Date | string
    available_at: Date | string
    delivered_at?: Date | string | null
  }

  export type messenger_messagesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messenger_messagesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messenger_messagesCreateManyInput = {
    id?: bigint | number
    body: string
    headers: string
    queue_name: string
    created_at: Date | string
    available_at: Date | string
    delivered_at?: Date | string | null
  }

  export type messenger_messagesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messenger_messagesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type operationsCreateInput = {
    active: boolean
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: Date | string
    updated_at: Date | string
    settings?: settingsCreateNestedOneWithoutOperationsInput
  }

  export type operationsUncheckedCreateInput = {
    id?: number
    active: boolean
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: Date | string
    updated_at: Date | string
    settings?: settingsUncheckedCreateNestedOneWithoutOperationsInput
  }

  export type operationsUpdateInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    whithdraw_minimum?: FloatFieldUpdateOperationsInput | number
    withdraw_maximum?: FloatFieldUpdateOperationsInput | number
    withdraw_fee?: FloatFieldUpdateOperationsInput | number
    deposit_minimum?: FloatFieldUpdateOperationsInput | number
    deposit_maximum?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: settingsUpdateOneWithoutOperationsNestedInput
  }

  export type operationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    whithdraw_minimum?: FloatFieldUpdateOperationsInput | number
    withdraw_maximum?: FloatFieldUpdateOperationsInput | number
    withdraw_fee?: FloatFieldUpdateOperationsInput | number
    deposit_minimum?: FloatFieldUpdateOperationsInput | number
    deposit_maximum?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: settingsUncheckedUpdateOneWithoutOperationsNestedInput
  }

  export type operationsCreateManyInput = {
    id?: number
    active: boolean
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: Date | string
    updated_at: Date | string
  }

  export type operationsUpdateManyMutationInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    whithdraw_minimum?: FloatFieldUpdateOperationsInput | number
    withdraw_maximum?: FloatFieldUpdateOperationsInput | number
    withdraw_fee?: FloatFieldUpdateOperationsInput | number
    deposit_minimum?: FloatFieldUpdateOperationsInput | number
    deposit_maximum?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type operationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    whithdraw_minimum?: FloatFieldUpdateOperationsInput | number
    withdraw_maximum?: FloatFieldUpdateOperationsInput | number
    withdraw_fee?: FloatFieldUpdateOperationsInput | number
    deposit_minimum?: FloatFieldUpdateOperationsInput | number
    deposit_maximum?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providerCreateInput = {
    name: string
    client_percent?: number | null
    base_percent?: number | null
    slot_games?: slot_gamesCreateNestedManyWithoutProviderInput
  }

  export type providerUncheckedCreateInput = {
    id?: number
    name: string
    client_percent?: number | null
    base_percent?: number | null
    slot_games?: slot_gamesUncheckedCreateNestedManyWithoutProviderInput
  }

  export type providerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    client_percent?: NullableIntFieldUpdateOperationsInput | number | null
    base_percent?: NullableIntFieldUpdateOperationsInput | number | null
    slot_games?: slot_gamesUpdateManyWithoutProviderNestedInput
  }

  export type providerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    client_percent?: NullableIntFieldUpdateOperationsInput | number | null
    base_percent?: NullableIntFieldUpdateOperationsInput | number | null
    slot_games?: slot_gamesUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type providerCreateManyInput = {
    id?: number
    name: string
    client_percent?: number | null
    base_percent?: number | null
  }

  export type providerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    client_percent?: NullableIntFieldUpdateOperationsInput | number | null
    base_percent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type providerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    client_percent?: NullableIntFieldUpdateOperationsInput | number | null
    base_percent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type referral_historyCreateInput = {
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_referral_history_referral_idTouser: userCreateNestedOneWithoutReferral_history_referral_history_referral_idTouserInput
    user_referral_history_user_idTouser?: userCreateNestedOneWithoutReferral_history_referral_history_user_idTouserInput
  }

  export type referral_historyUncheckedCreateInput = {
    id?: number
    referral_id: number
    user_id?: number | null
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type referral_historyUpdateInput = {
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_referral_history_referral_idTouser?: userUpdateOneRequiredWithoutReferral_history_referral_history_referral_idTouserNestedInput
    user_referral_history_user_idTouser?: userUpdateOneWithoutReferral_history_referral_history_user_idTouserNestedInput
  }

  export type referral_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referral_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type referral_historyCreateManyInput = {
    id?: number
    referral_id: number
    user_id?: number | null
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type referral_historyUpdateManyMutationInput = {
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type referral_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referral_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type referral_settingsCreateInput = {
    cpa?: number | null
    rev_share_percent?: number | null
    referral_type?: string | null
    user?: userCreateNestedOneWithoutReferral_settingsInput
  }

  export type referral_settingsUncheckedCreateInput = {
    id?: number
    cpa?: number | null
    rev_share_percent?: number | null
    referral_type?: string | null
    user?: userUncheckedCreateNestedOneWithoutReferral_settingsInput
  }

  export type referral_settingsUpdateInput = {
    cpa?: NullableIntFieldUpdateOperationsInput | number | null
    rev_share_percent?: NullableIntFieldUpdateOperationsInput | number | null
    referral_type?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutReferral_settingsNestedInput
  }

  export type referral_settingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpa?: NullableIntFieldUpdateOperationsInput | number | null
    rev_share_percent?: NullableIntFieldUpdateOperationsInput | number | null
    referral_type?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUncheckedUpdateOneWithoutReferral_settingsNestedInput
  }

  export type referral_settingsCreateManyInput = {
    id?: number
    cpa?: number | null
    rev_share_percent?: number | null
    referral_type?: string | null
  }

  export type referral_settingsUpdateManyMutationInput = {
    cpa?: NullableIntFieldUpdateOperationsInput | number | null
    rev_share_percent?: NullableIntFieldUpdateOperationsInput | number | null
    referral_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type referral_settingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpa?: NullableIntFieldUpdateOperationsInput | number | null
    rev_share_percent?: NullableIntFieldUpdateOperationsInput | number | null
    referral_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsCreateInput = {
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsCreateNestedManyWithoutSettingsInput
    client_settings_client_idToclient: clientCreateNestedOneWithoutSettings_settings_client_idToclientInput
    operations?: operationsCreateNestedOneWithoutSettingsInput
    slot_settings?: slot_settingsCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateInput = {
    id?: number
    operations_id?: number | null
    slot_settings_id?: number | null
    client_id: number
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientUncheckedCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type settingsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUpdateManyWithoutSettingsNestedInput
    client_settings_client_idToclient?: clientUpdateOneRequiredWithoutSettings_settings_client_idToclientNestedInput
    operations?: operationsUpdateOneWithoutSettingsNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operations_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUncheckedUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type settingsCreateManyInput = {
    id?: number
    operations_id?: number | null
    slot_settings_id?: number | null
    client_id: number
    created_at: Date | string
    updated_at: Date | string
  }

  export type settingsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operations_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type slot_gamesCreateInput = {
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsCreateNestedManyWithoutSlot_gamesInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
    provider: providerCreateNestedOneWithoutSlot_gamesInput
  }

  export type slot_gamesUncheckedCreateInput = {
    id?: number
    provider_id: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutSlot_gamesInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
  }

  export type slot_gamesUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUpdateManyWithoutSlot_gamesNestedInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
    provider?: providerUpdateOneRequiredWithoutSlot_gamesNestedInput
  }

  export type slot_gamesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutSlot_gamesNestedInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
  }

  export type slot_gamesCreateManyInput = {
    id?: number
    provider_id: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
  }

  export type slot_gamesUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type slot_gamesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type slot_settingsCreateInput = {
    banner_more_profitable?: banner_more_profitableCreateNestedManyWithoutSlot_settingsInput
    settings?: settingsCreateNestedOneWithoutSlot_settingsInput
    live_casino_most_popular?: live_casino_most_popularCreateNestedOneWithoutSlot_settingsInput
    casino_most_popular?: casino_most_popularCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsUncheckedCreateInput = {
    id?: number
    casino_most_popular_id?: number | null
    live_casino_most_popular_id?: number | null
    banner_more_profitable?: banner_more_profitableUncheckedCreateNestedManyWithoutSlot_settingsInput
    settings?: settingsUncheckedCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsUpdateInput = {
    banner_more_profitable?: banner_more_profitableUpdateManyWithoutSlot_settingsNestedInput
    settings?: settingsUpdateOneWithoutSlot_settingsNestedInput
    live_casino_most_popular?: live_casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
    casino_most_popular?: casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
  }

  export type slot_settingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    live_casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_more_profitable?: banner_more_profitableUncheckedUpdateManyWithoutSlot_settingsNestedInput
    settings?: settingsUncheckedUpdateOneWithoutSlot_settingsNestedInput
  }

  export type slot_settingsCreateManyInput = {
    id?: number
    casino_most_popular_id?: number | null
    live_casino_most_popular_id?: number | null
  }

  export type slot_settingsUpdateManyMutationInput = {

  }

  export type slot_settingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    live_casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userCreateInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
  }

  export type userUpdateManyMutationInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type walletCreateInput = {
    balance?: number | null
    bonus?: number | null
    bet?: number | null
    withdraw?: number | null
    deposit?: number | null
    user?: userCreateNestedOneWithoutWalletInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutWalletInput
  }

  export type walletUncheckedCreateInput = {
    id?: number
    balance?: number | null
    bonus?: number | null
    bet?: number | null
    withdraw?: number | null
    deposit?: number | null
    user?: userUncheckedCreateNestedOneWithoutWalletInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type walletUpdateInput = {
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: userUpdateOneWithoutWalletNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: userUncheckedUpdateOneWithoutWalletNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type walletCreateManyInput = {
    id?: number
    balance?: number | null
    bonus?: number | null
    bet?: number | null
    withdraw?: number | null
    deposit?: number | null
  }

  export type walletUpdateManyMutationInput = {
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type walletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type wallet_transactionCreateInput = {
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    uuid: string
    wallet: walletCreateNestedOneWithoutWallet_transactionInput
    user?: userCreateNestedOneWithoutWallet_transactionInput
  }

  export type wallet_transactionUncheckedCreateInput = {
    id?: number
    wallet_id: number
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    user_id?: number | null
    uuid: string
  }

  export type wallet_transactionUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    wallet?: walletUpdateOneRequiredWithoutWallet_transactionNestedInput
    user?: userUpdateOneWithoutWallet_transactionNestedInput
  }

  export type wallet_transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transactionCreateManyInput = {
    id?: number
    wallet_id: number
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    user_id?: number | null
    uuid: string
  }

  export type wallet_transactionUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type salsa_gamesCreateInput = {
    name: string
    code: string
    isSlot?: boolean
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type salsa_gamesUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    isSlot?: boolean
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type salsa_gamesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isSlot?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salsa_gamesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isSlot?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salsa_gamesCreateManyInput = {
    id?: number
    name: string
    code: string
    isSlot?: boolean
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type salsa_gamesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isSlot?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type salsa_gamesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isSlot?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type api_requestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    request?: SortOrder
    response?: SortOrder
    created_at?: SortOrder
  }

  export type api_requestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type api_requestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type api_requestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type api_requestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Client_auth_userListRelationFilter = {
    every?: client_auth_userWhereInput
    some?: client_auth_userWhereInput
    none?: client_auth_userWhereInput
  }

  export type client_auth_userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    roles?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
  }

  export type auth_userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type auth_userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
  }

  export type auth_userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
  }

  export type auth_userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Banner_more_profitable_fileNullableRelationFilter = {
    is?: banner_more_profitable_fileWhereInput | null
    isNot?: banner_more_profitable_fileWhereInput | null
  }

  export type Slot_settingsNullableRelationFilter = {
    is?: slot_settingsWhereInput | null
    isNot?: slot_settingsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type banner_more_profitableCountOrderByAggregateInput = {
    id?: SortOrder
    banner_id?: SortOrder
    slot_settings_id?: SortOrder
    banner_file_id?: SortOrder
    name?: SortOrder
    game_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
  }

  export type banner_more_profitableAvgOrderByAggregateInput = {
    id?: SortOrder
    banner_id?: SortOrder
    slot_settings_id?: SortOrder
    banner_file_id?: SortOrder
  }

  export type banner_more_profitableMaxOrderByAggregateInput = {
    id?: SortOrder
    banner_id?: SortOrder
    slot_settings_id?: SortOrder
    banner_file_id?: SortOrder
    name?: SortOrder
    game_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
  }

  export type banner_more_profitableMinOrderByAggregateInput = {
    id?: SortOrder
    banner_id?: SortOrder
    slot_settings_id?: SortOrder
    banner_file_id?: SortOrder
    name?: SortOrder
    game_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active?: SortOrder
  }

  export type banner_more_profitableSumOrderByAggregateInput = {
    id?: SortOrder
    banner_id?: SortOrder
    slot_settings_id?: SortOrder
    banner_file_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Banner_more_profitableNullableRelationFilter = {
    is?: banner_more_profitableWhereInput | null
    isNot?: banner_more_profitableWhereInput | null
  }

  export type banner_more_profitable_fileCountOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
  }

  export type banner_more_profitable_fileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type banner_more_profitable_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
  }

  export type banner_more_profitable_fileMinOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
  }

  export type banner_more_profitable_fileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type Slot_gamesRelationFilter = {
    is?: slot_gamesWhereInput
    isNot?: slot_gamesWhereInput
  }

  export type bet_operationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    slot_game_id?: SortOrder
    bet_transaction_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    round_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bet_operationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    slot_game_id?: SortOrder
    amount?: SortOrder
  }

  export type bet_operationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    slot_game_id?: SortOrder
    bet_transaction_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    round_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bet_operationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    slot_game_id?: SortOrder
    bet_transaction_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    round_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bet_operationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    slot_game_id?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Casino_most_popular_slot_gamesListRelationFilter = {
    every?: casino_most_popular_slot_gamesWhereInput
    some?: casino_most_popular_slot_gamesWhereInput
    none?: casino_most_popular_slot_gamesWhereInput
  }

  export type casino_most_popular_slot_gamesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type casino_most_popularCountOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type casino_most_popularAvgOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type casino_most_popularMaxOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type casino_most_popularMinOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type casino_most_popularSumOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type Casino_most_popularRelationFilter = {
    is?: casino_most_popularWhereInput
    isNot?: casino_most_popularWhereInput
  }

  export type casino_most_popular_slot_gamesCasino_most_popular_idSlot_games_idCompoundUniqueInput = {
    casino_most_popular_id: number
    slot_games_id: number
  }

  export type casino_most_popular_slot_gamesCountOrderByAggregateInput = {
    casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type casino_most_popular_slot_gamesAvgOrderByAggregateInput = {
    casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type casino_most_popular_slot_gamesMaxOrderByAggregateInput = {
    casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type casino_most_popular_slot_gamesMinOrderByAggregateInput = {
    casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type casino_most_popular_slot_gamesSumOrderByAggregateInput = {
    casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type SettingsNullableRelationFilter = {
    is?: settingsWhereInput | null
    isNot?: settingsWhereInput | null
  }

  export type SettingsListRelationFilter = {
    every?: settingsWhereInput
    some?: settingsWhereInput
    none?: settingsWhereInput
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientCountOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
    key_id_prod?: SortOrder
    key_secret_prod?: SortOrder
    key_id_stage?: SortOrder
    key_secret_stage?: SortOrder
    currency?: SortOrder
    language?: SortOrder
    url_return?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    prod_callback?: SortOrder
    stage_callback?: SortOrder
  }

  export type clientAvgOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
  }

  export type clientMaxOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
    key_id_prod?: SortOrder
    key_secret_prod?: SortOrder
    key_id_stage?: SortOrder
    key_secret_stage?: SortOrder
    currency?: SortOrder
    language?: SortOrder
    url_return?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    prod_callback?: SortOrder
    stage_callback?: SortOrder
  }

  export type clientMinOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
    key_id_prod?: SortOrder
    key_secret_prod?: SortOrder
    key_id_stage?: SortOrder
    key_secret_stage?: SortOrder
    currency?: SortOrder
    language?: SortOrder
    url_return?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    prod_callback?: SortOrder
    stage_callback?: SortOrder
  }

  export type clientSumOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
  }

  export type ClientRelationFilter = {
    is?: clientWhereInput
    isNot?: clientWhereInput
  }

  export type Auth_userRelationFilter = {
    is?: auth_userWhereInput
    isNot?: auth_userWhereInput
  }

  export type client_auth_userClient_idAuth_user_idCompoundUniqueInput = {
    client_id: number
    auth_user_id: number
  }

  export type client_auth_userCountOrderByAggregateInput = {
    client_id?: SortOrder
    auth_user_id?: SortOrder
  }

  export type client_auth_userAvgOrderByAggregateInput = {
    client_id?: SortOrder
    auth_user_id?: SortOrder
  }

  export type client_auth_userMaxOrderByAggregateInput = {
    client_id?: SortOrder
    auth_user_id?: SortOrder
  }

  export type client_auth_userMinOrderByAggregateInput = {
    client_id?: SortOrder
    auth_user_id?: SortOrder
  }

  export type client_auth_userSumOrderByAggregateInput = {
    client_id?: SortOrder
    auth_user_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type doctrine_migration_versionsCountOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsAvgOrderByAggregateInput = {
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsMaxOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsMinOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsSumOrderByAggregateInput = {
    execution_time?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type fileCountOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
  }

  export type fileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fileMaxOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
  }

  export type fileMinOrderByAggregateInput = {
    id?: SortOrder
    file?: SortOrder
    upload_at?: SortOrder
  }

  export type fileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type layout_colorsCountOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
    name?: SortOrder
    hexadecimal?: SortOrder
  }

  export type layout_colorsAvgOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
  }

  export type layout_colorsMaxOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
    name?: SortOrder
    hexadecimal?: SortOrder
  }

  export type layout_colorsMinOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
    name?: SortOrder
    hexadecimal?: SortOrder
  }

  export type layout_colorsSumOrderByAggregateInput = {
    id?: SortOrder
    settings_id?: SortOrder
  }

  export type Live_casino_most_popular_slot_gamesListRelationFilter = {
    every?: live_casino_most_popular_slot_gamesWhereInput
    some?: live_casino_most_popular_slot_gamesWhereInput
    none?: live_casino_most_popular_slot_gamesWhereInput
  }

  export type live_casino_most_popular_slot_gamesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type live_casino_most_popularCountOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type live_casino_most_popularAvgOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type live_casino_most_popularMaxOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type live_casino_most_popularMinOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type live_casino_most_popularSumOrderByAggregateInput = {
    id?: SortOrder
    qty_lines?: SortOrder
    qty_columns?: SortOrder
  }

  export type Live_casino_most_popularRelationFilter = {
    is?: live_casino_most_popularWhereInput
    isNot?: live_casino_most_popularWhereInput
  }

  export type live_casino_most_popular_slot_gamesLive_casino_most_popular_idSlot_games_idCompoundUniqueInput = {
    live_casino_most_popular_id: number
    slot_games_id: number
  }

  export type live_casino_most_popular_slot_gamesCountOrderByAggregateInput = {
    live_casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type live_casino_most_popular_slot_gamesAvgOrderByAggregateInput = {
    live_casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type live_casino_most_popular_slot_gamesMaxOrderByAggregateInput = {
    live_casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type live_casino_most_popular_slot_gamesMinOrderByAggregateInput = {
    live_casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type live_casino_most_popular_slot_gamesSumOrderByAggregateInput = {
    live_casino_most_popular_id?: SortOrder
    slot_games_id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type messenger_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
  }

  export type messenger_messagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type messenger_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
  }

  export type messenger_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
  }

  export type messenger_messagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type operationsCountOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    whithdraw_minimum?: SortOrder
    withdraw_maximum?: SortOrder
    withdraw_fee?: SortOrder
    deposit_minimum?: SortOrder
    deposit_maximum?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type operationsAvgOrderByAggregateInput = {
    id?: SortOrder
    whithdraw_minimum?: SortOrder
    withdraw_maximum?: SortOrder
    withdraw_fee?: SortOrder
    deposit_minimum?: SortOrder
    deposit_maximum?: SortOrder
  }

  export type operationsMaxOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    whithdraw_minimum?: SortOrder
    withdraw_maximum?: SortOrder
    withdraw_fee?: SortOrder
    deposit_minimum?: SortOrder
    deposit_maximum?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type operationsMinOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    whithdraw_minimum?: SortOrder
    withdraw_maximum?: SortOrder
    withdraw_fee?: SortOrder
    deposit_minimum?: SortOrder
    deposit_maximum?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type operationsSumOrderByAggregateInput = {
    id?: SortOrder
    whithdraw_minimum?: SortOrder
    withdraw_maximum?: SortOrder
    withdraw_fee?: SortOrder
    deposit_minimum?: SortOrder
    deposit_maximum?: SortOrder
  }

  export type Slot_gamesListRelationFilter = {
    every?: slot_gamesWhereInput
    some?: slot_gamesWhereInput
    none?: slot_gamesWhereInput
  }

  export type slot_gamesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type providerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    client_percent?: SortOrder
    base_percent?: SortOrder
  }

  export type providerAvgOrderByAggregateInput = {
    id?: SortOrder
    client_percent?: SortOrder
    base_percent?: SortOrder
  }

  export type providerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    client_percent?: SortOrder
    base_percent?: SortOrder
  }

  export type providerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    client_percent?: SortOrder
    base_percent?: SortOrder
  }

  export type providerSumOrderByAggregateInput = {
    id?: SortOrder
    client_percent?: SortOrder
    base_percent?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type referral_historyCountOrderByAggregateInput = {
    id?: SortOrder
    referral_id?: SortOrder
    user_id?: SortOrder
    game?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    available?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type referral_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    referral_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type referral_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    referral_id?: SortOrder
    user_id?: SortOrder
    game?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    available?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type referral_historyMinOrderByAggregateInput = {
    id?: SortOrder
    referral_id?: SortOrder
    user_id?: SortOrder
    game?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    available?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type referral_historySumOrderByAggregateInput = {
    id?: SortOrder
    referral_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type referral_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    cpa?: SortOrder
    rev_share_percent?: SortOrder
    referral_type?: SortOrder
  }

  export type referral_settingsAvgOrderByAggregateInput = {
    id?: SortOrder
    cpa?: SortOrder
    rev_share_percent?: SortOrder
  }

  export type referral_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    cpa?: SortOrder
    rev_share_percent?: SortOrder
    referral_type?: SortOrder
  }

  export type referral_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    cpa?: SortOrder
    rev_share_percent?: SortOrder
    referral_type?: SortOrder
  }

  export type referral_settingsSumOrderByAggregateInput = {
    id?: SortOrder
    cpa?: SortOrder
    rev_share_percent?: SortOrder
  }

  export type ClientNullableRelationFilter = {
    is?: clientWhereInput | null
    isNot?: clientWhereInput | null
  }

  export type Layout_colorsListRelationFilter = {
    every?: layout_colorsWhereInput
    some?: layout_colorsWhereInput
    none?: layout_colorsWhereInput
  }

  export type OperationsNullableRelationFilter = {
    is?: operationsWhereInput | null
    isNot?: operationsWhereInput | null
  }

  export type layout_colorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type settingsCountOrderByAggregateInput = {
    id?: SortOrder
    operations_id?: SortOrder
    slot_settings_id?: SortOrder
    client_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsAvgOrderByAggregateInput = {
    id?: SortOrder
    operations_id?: SortOrder
    slot_settings_id?: SortOrder
    client_id?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    operations_id?: SortOrder
    slot_settings_id?: SortOrder
    client_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    id?: SortOrder
    operations_id?: SortOrder
    slot_settings_id?: SortOrder
    client_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsSumOrderByAggregateInput = {
    id?: SortOrder
    operations_id?: SortOrder
    slot_settings_id?: SortOrder
    client_id?: SortOrder
  }

  export type Bet_operationsListRelationFilter = {
    every?: bet_operationsWhereInput
    some?: bet_operationsWhereInput
    none?: bet_operationsWhereInput
  }

  export type ProviderRelationFilter = {
    is?: providerWhereInput
    isNot?: providerWhereInput
  }

  export type bet_operationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type slot_gamesCountOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    has_lobby?: SortOrder
    is_mobile?: SortOrder
    has_freespins?: SortOrder
    has_tables?: SortOrder
    freespin_valid_until_full_day?: SortOrder
    slug?: SortOrder
  }

  export type slot_gamesAvgOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
  }

  export type slot_gamesMaxOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    has_lobby?: SortOrder
    is_mobile?: SortOrder
    has_freespins?: SortOrder
    has_tables?: SortOrder
    freespin_valid_until_full_day?: SortOrder
    slug?: SortOrder
  }

  export type slot_gamesMinOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    has_lobby?: SortOrder
    is_mobile?: SortOrder
    has_freespins?: SortOrder
    has_tables?: SortOrder
    freespin_valid_until_full_day?: SortOrder
    slug?: SortOrder
  }

  export type slot_gamesSumOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
  }

  export type Banner_more_profitableListRelationFilter = {
    every?: banner_more_profitableWhereInput
    some?: banner_more_profitableWhereInput
    none?: banner_more_profitableWhereInput
  }

  export type Live_casino_most_popularNullableRelationFilter = {
    is?: live_casino_most_popularWhereInput | null
    isNot?: live_casino_most_popularWhereInput | null
  }

  export type Casino_most_popularNullableRelationFilter = {
    is?: casino_most_popularWhereInput | null
    isNot?: casino_most_popularWhereInput | null
  }

  export type banner_more_profitableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type slot_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    casino_most_popular_id?: SortOrder
    live_casino_most_popular_id?: SortOrder
  }

  export type slot_settingsAvgOrderByAggregateInput = {
    id?: SortOrder
    casino_most_popular_id?: SortOrder
    live_casino_most_popular_id?: SortOrder
  }

  export type slot_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    casino_most_popular_id?: SortOrder
    live_casino_most_popular_id?: SortOrder
  }

  export type slot_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    casino_most_popular_id?: SortOrder
    live_casino_most_popular_id?: SortOrder
  }

  export type slot_settingsSumOrderByAggregateInput = {
    id?: SortOrder
    casino_most_popular_id?: SortOrder
    live_casino_most_popular_id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Referral_historyListRelationFilter = {
    every?: referral_historyWhereInput
    some?: referral_historyWhereInput
    none?: referral_historyWhereInput
  }

  export type Referral_settingsNullableRelationFilter = {
    is?: referral_settingsWhereInput | null
    isNot?: referral_settingsWhereInput | null
  }

  export type WalletRelationFilter = {
    is?: walletWhereInput
    isNot?: walletWhereInput
  }

  export type Wallet_transactionListRelationFilter = {
    every?: wallet_transactionWhereInput
    some?: wallet_transactionWhereInput
    none?: wallet_transactionWhereInput
  }

  export type referral_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wallet_transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    client_id?: SortOrder
    referral_id?: SortOrder
    referral_settings_id?: SortOrder
    external_id?: SortOrder
    username?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    session?: SortOrder
    cpa_collected?: SortOrder
    is_referrer?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    client_id?: SortOrder
    referral_id?: SortOrder
    referral_settings_id?: SortOrder
    external_id?: SortOrder
    balance?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    client_id?: SortOrder
    referral_id?: SortOrder
    referral_settings_id?: SortOrder
    external_id?: SortOrder
    username?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    session?: SortOrder
    cpa_collected?: SortOrder
    is_referrer?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    client_id?: SortOrder
    referral_id?: SortOrder
    referral_settings_id?: SortOrder
    external_id?: SortOrder
    username?: SortOrder
    balance?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    session?: SortOrder
    cpa_collected?: SortOrder
    is_referrer?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    client_id?: SortOrder
    referral_id?: SortOrder
    referral_settings_id?: SortOrder
    external_id?: SortOrder
    balance?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type walletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    bonus?: SortOrder
    bet?: SortOrder
    withdraw?: SortOrder
    deposit?: SortOrder
  }

  export type walletAvgOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    bonus?: SortOrder
    bet?: SortOrder
    withdraw?: SortOrder
    deposit?: SortOrder
  }

  export type walletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    bonus?: SortOrder
    bet?: SortOrder
    withdraw?: SortOrder
    deposit?: SortOrder
  }

  export type walletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    bonus?: SortOrder
    bet?: SortOrder
    withdraw?: SortOrder
    deposit?: SortOrder
  }

  export type walletSumOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    bonus?: SortOrder
    bet?: SortOrder
    withdraw?: SortOrder
    deposit?: SortOrder
  }

  export type wallet_transactionCountOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    type?: SortOrder
    api_collected?: SortOrder
    user_id?: SortOrder
    uuid?: SortOrder
  }

  export type wallet_transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
  }

  export type wallet_transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    type?: SortOrder
    api_collected?: SortOrder
    user_id?: SortOrder
    uuid?: SortOrder
  }

  export type wallet_transactionMinOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    type?: SortOrder
    api_collected?: SortOrder
    user_id?: SortOrder
    uuid?: SortOrder
  }

  export type wallet_transactionSumOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
  }

  export type salsa_gamesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isSlot?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type salsa_gamesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type salsa_gamesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isSlot?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type salsa_gamesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isSlot?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type salsa_gamesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type client_auth_userCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<client_auth_userCreateWithoutAuth_userInput, client_auth_userUncheckedCreateWithoutAuth_userInput> | client_auth_userCreateWithoutAuth_userInput[] | client_auth_userUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutAuth_userInput | client_auth_userCreateOrConnectWithoutAuth_userInput[]
    createMany?: client_auth_userCreateManyAuth_userInputEnvelope
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
  }

  export type client_auth_userUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<client_auth_userCreateWithoutAuth_userInput, client_auth_userUncheckedCreateWithoutAuth_userInput> | client_auth_userCreateWithoutAuth_userInput[] | client_auth_userUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutAuth_userInput | client_auth_userCreateOrConnectWithoutAuth_userInput[]
    createMany?: client_auth_userCreateManyAuth_userInputEnvelope
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
  }

  export type client_auth_userUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<client_auth_userCreateWithoutAuth_userInput, client_auth_userUncheckedCreateWithoutAuth_userInput> | client_auth_userCreateWithoutAuth_userInput[] | client_auth_userUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutAuth_userInput | client_auth_userCreateOrConnectWithoutAuth_userInput[]
    upsert?: client_auth_userUpsertWithWhereUniqueWithoutAuth_userInput | client_auth_userUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: client_auth_userCreateManyAuth_userInputEnvelope
    set?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    disconnect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    delete?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    update?: client_auth_userUpdateWithWhereUniqueWithoutAuth_userInput | client_auth_userUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: client_auth_userUpdateManyWithWhereWithoutAuth_userInput | client_auth_userUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: client_auth_userScalarWhereInput | client_auth_userScalarWhereInput[]
  }

  export type client_auth_userUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<client_auth_userCreateWithoutAuth_userInput, client_auth_userUncheckedCreateWithoutAuth_userInput> | client_auth_userCreateWithoutAuth_userInput[] | client_auth_userUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutAuth_userInput | client_auth_userCreateOrConnectWithoutAuth_userInput[]
    upsert?: client_auth_userUpsertWithWhereUniqueWithoutAuth_userInput | client_auth_userUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: client_auth_userCreateManyAuth_userInputEnvelope
    set?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    disconnect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    delete?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    update?: client_auth_userUpdateWithWhereUniqueWithoutAuth_userInput | client_auth_userUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: client_auth_userUpdateManyWithWhereWithoutAuth_userInput | client_auth_userUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: client_auth_userScalarWhereInput | client_auth_userScalarWhereInput[]
  }

  export type banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    create?: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitable_fileCreateOrConnectWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    connect?: banner_more_profitable_fileWhereUniqueInput
  }

  export type slot_settingsCreateNestedOneWithoutBanner_more_profitableInput = {
    create?: XOR<slot_settingsCreateWithoutBanner_more_profitableInput, slot_settingsUncheckedCreateWithoutBanner_more_profitableInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutBanner_more_profitableInput
    connect?: slot_settingsWhereUniqueInput
  }

  export type banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    create?: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitable_fileCreateOrConnectWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    connect?: banner_more_profitable_fileWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput = {
    create?: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitable_fileCreateOrConnectWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    upsert?: banner_more_profitable_fileUpsertWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    disconnect?: banner_more_profitable_fileWhereInput | boolean
    delete?: banner_more_profitable_fileWhereInput | boolean
    connect?: banner_more_profitable_fileWhereUniqueInput
    update?: XOR<XOR<banner_more_profitable_fileUpdateToOneWithWhereWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>, banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
  }

  export type slot_settingsUpdateOneWithoutBanner_more_profitableNestedInput = {
    create?: XOR<slot_settingsCreateWithoutBanner_more_profitableInput, slot_settingsUncheckedCreateWithoutBanner_more_profitableInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutBanner_more_profitableInput
    upsert?: slot_settingsUpsertWithoutBanner_more_profitableInput
    disconnect?: slot_settingsWhereInput | boolean
    delete?: slot_settingsWhereInput | boolean
    connect?: slot_settingsWhereUniqueInput
    update?: XOR<XOR<slot_settingsUpdateToOneWithWhereWithoutBanner_more_profitableInput, slot_settingsUpdateWithoutBanner_more_profitableInput>, slot_settingsUncheckedUpdateWithoutBanner_more_profitableInput>
  }

  export type banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput = {
    create?: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitable_fileCreateOrConnectWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    upsert?: banner_more_profitable_fileUpsertWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    disconnect?: banner_more_profitable_fileWhereInput | boolean
    delete?: banner_more_profitable_fileWhereInput | boolean
    connect?: banner_more_profitable_fileWhereUniqueInput
    update?: XOR<XOR<banner_more_profitable_fileUpdateToOneWithWhereWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>, banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type banner_more_profitableCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    connect?: banner_more_profitableWhereUniqueInput
  }

  export type banner_more_profitableCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    connect?: banner_more_profitableWhereUniqueInput
  }

  export type banner_more_profitableUncheckedCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    connect?: banner_more_profitableWhereUniqueInput
  }

  export type banner_more_profitableUncheckedCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    connect?: banner_more_profitableWhereUniqueInput
  }

  export type banner_more_profitableUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    upsert?: banner_more_profitableUpsertWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    disconnect?: banner_more_profitableWhereInput | boolean
    delete?: banner_more_profitableWhereInput | boolean
    connect?: banner_more_profitableWhereUniqueInput
    update?: XOR<XOR<banner_more_profitableUpdateToOneWithWhereWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitableUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    upsert?: banner_more_profitableUpsertWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    disconnect?: banner_more_profitableWhereInput | boolean
    delete?: banner_more_profitableWhereInput | boolean
    connect?: banner_more_profitableWhereUniqueInput
    update?: XOR<XOR<banner_more_profitableUpdateToOneWithWhereWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitableUncheckedUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    upsert?: banner_more_profitableUpsertWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    disconnect?: banner_more_profitableWhereInput | boolean
    delete?: banner_more_profitableWhereInput | boolean
    connect?: banner_more_profitableWhereUniqueInput
    update?: XOR<XOR<banner_more_profitableUpdateToOneWithWhereWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitableUncheckedUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput = {
    create?: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    upsert?: banner_more_profitableUpsertWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
    disconnect?: banner_more_profitableWhereInput | boolean
    delete?: banner_more_profitableWhereInput | boolean
    connect?: banner_more_profitableWhereUniqueInput
    update?: XOR<XOR<banner_more_profitableUpdateToOneWithWhereWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
  }

  export type userCreateNestedOneWithoutBet_operationsInput = {
    create?: XOR<userCreateWithoutBet_operationsInput, userUncheckedCreateWithoutBet_operationsInput>
    connectOrCreate?: userCreateOrConnectWithoutBet_operationsInput
    connect?: userWhereUniqueInput
  }

  export type slot_gamesCreateNestedOneWithoutBet_operationsInput = {
    create?: XOR<slot_gamesCreateWithoutBet_operationsInput, slot_gamesUncheckedCreateWithoutBet_operationsInput>
    connectOrCreate?: slot_gamesCreateOrConnectWithoutBet_operationsInput
    connect?: slot_gamesWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type userUpdateOneRequiredWithoutBet_operationsNestedInput = {
    create?: XOR<userCreateWithoutBet_operationsInput, userUncheckedCreateWithoutBet_operationsInput>
    connectOrCreate?: userCreateOrConnectWithoutBet_operationsInput
    upsert?: userUpsertWithoutBet_operationsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBet_operationsInput, userUpdateWithoutBet_operationsInput>, userUncheckedUpdateWithoutBet_operationsInput>
  }

  export type slot_gamesUpdateOneRequiredWithoutBet_operationsNestedInput = {
    create?: XOR<slot_gamesCreateWithoutBet_operationsInput, slot_gamesUncheckedCreateWithoutBet_operationsInput>
    connectOrCreate?: slot_gamesCreateOrConnectWithoutBet_operationsInput
    upsert?: slot_gamesUpsertWithoutBet_operationsInput
    connect?: slot_gamesWhereUniqueInput
    update?: XOR<XOR<slot_gamesUpdateToOneWithWhereWithoutBet_operationsInput, slot_gamesUpdateWithoutBet_operationsInput>, slot_gamesUncheckedUpdateWithoutBet_operationsInput>
  }

  export type casino_most_popular_slot_gamesCreateNestedManyWithoutCasino_most_popularInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput> | casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput | casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput[]
    createMany?: casino_most_popular_slot_gamesCreateManyCasino_most_popularInputEnvelope
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type slot_settingsCreateNestedOneWithoutCasino_most_popularInput = {
    create?: XOR<slot_settingsCreateWithoutCasino_most_popularInput, slot_settingsUncheckedCreateWithoutCasino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutCasino_most_popularInput
    connect?: slot_settingsWhereUniqueInput
  }

  export type casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutCasino_most_popularInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput> | casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput | casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput[]
    createMany?: casino_most_popular_slot_gamesCreateManyCasino_most_popularInputEnvelope
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type slot_settingsUncheckedCreateNestedOneWithoutCasino_most_popularInput = {
    create?: XOR<slot_settingsCreateWithoutCasino_most_popularInput, slot_settingsUncheckedCreateWithoutCasino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutCasino_most_popularInput
    connect?: slot_settingsWhereUniqueInput
  }

  export type casino_most_popular_slot_gamesUpdateManyWithoutCasino_most_popularNestedInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput> | casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput | casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput[]
    upsert?: casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutCasino_most_popularInput | casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutCasino_most_popularInput[]
    createMany?: casino_most_popular_slot_gamesCreateManyCasino_most_popularInputEnvelope
    set?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutCasino_most_popularInput | casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutCasino_most_popularInput[]
    updateMany?: casino_most_popular_slot_gamesUpdateManyWithWhereWithoutCasino_most_popularInput | casino_most_popular_slot_gamesUpdateManyWithWhereWithoutCasino_most_popularInput[]
    deleteMany?: casino_most_popular_slot_gamesScalarWhereInput | casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type slot_settingsUpdateOneWithoutCasino_most_popularNestedInput = {
    create?: XOR<slot_settingsCreateWithoutCasino_most_popularInput, slot_settingsUncheckedCreateWithoutCasino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutCasino_most_popularInput
    upsert?: slot_settingsUpsertWithoutCasino_most_popularInput
    disconnect?: slot_settingsWhereInput | boolean
    delete?: slot_settingsWhereInput | boolean
    connect?: slot_settingsWhereUniqueInput
    update?: XOR<XOR<slot_settingsUpdateToOneWithWhereWithoutCasino_most_popularInput, slot_settingsUpdateWithoutCasino_most_popularInput>, slot_settingsUncheckedUpdateWithoutCasino_most_popularInput>
  }

  export type casino_most_popular_slot_gamesUncheckedUpdateManyWithoutCasino_most_popularNestedInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput> | casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput | casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput[]
    upsert?: casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutCasino_most_popularInput | casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutCasino_most_popularInput[]
    createMany?: casino_most_popular_slot_gamesCreateManyCasino_most_popularInputEnvelope
    set?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutCasino_most_popularInput | casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutCasino_most_popularInput[]
    updateMany?: casino_most_popular_slot_gamesUpdateManyWithWhereWithoutCasino_most_popularInput | casino_most_popular_slot_gamesUpdateManyWithWhereWithoutCasino_most_popularInput[]
    deleteMany?: casino_most_popular_slot_gamesScalarWhereInput | casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type slot_settingsUncheckedUpdateOneWithoutCasino_most_popularNestedInput = {
    create?: XOR<slot_settingsCreateWithoutCasino_most_popularInput, slot_settingsUncheckedCreateWithoutCasino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutCasino_most_popularInput
    upsert?: slot_settingsUpsertWithoutCasino_most_popularInput
    disconnect?: slot_settingsWhereInput | boolean
    delete?: slot_settingsWhereInput | boolean
    connect?: slot_settingsWhereUniqueInput
    update?: XOR<XOR<slot_settingsUpdateToOneWithWhereWithoutCasino_most_popularInput, slot_settingsUpdateWithoutCasino_most_popularInput>, slot_settingsUncheckedUpdateWithoutCasino_most_popularInput>
  }

  export type slot_gamesCreateNestedOneWithoutCasino_most_popular_slot_gamesInput = {
    create?: XOR<slot_gamesCreateWithoutCasino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
    connectOrCreate?: slot_gamesCreateOrConnectWithoutCasino_most_popular_slot_gamesInput
    connect?: slot_gamesWhereUniqueInput
  }

  export type casino_most_popularCreateNestedOneWithoutCasino_most_popular_slot_gamesInput = {
    create?: XOR<casino_most_popularCreateWithoutCasino_most_popular_slot_gamesInput, casino_most_popularUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
    connectOrCreate?: casino_most_popularCreateOrConnectWithoutCasino_most_popular_slot_gamesInput
    connect?: casino_most_popularWhereUniqueInput
  }

  export type slot_gamesUpdateOneRequiredWithoutCasino_most_popular_slot_gamesNestedInput = {
    create?: XOR<slot_gamesCreateWithoutCasino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
    connectOrCreate?: slot_gamesCreateOrConnectWithoutCasino_most_popular_slot_gamesInput
    upsert?: slot_gamesUpsertWithoutCasino_most_popular_slot_gamesInput
    connect?: slot_gamesWhereUniqueInput
    update?: XOR<XOR<slot_gamesUpdateToOneWithWhereWithoutCasino_most_popular_slot_gamesInput, slot_gamesUpdateWithoutCasino_most_popular_slot_gamesInput>, slot_gamesUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput>
  }

  export type casino_most_popularUpdateOneRequiredWithoutCasino_most_popular_slot_gamesNestedInput = {
    create?: XOR<casino_most_popularCreateWithoutCasino_most_popular_slot_gamesInput, casino_most_popularUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
    connectOrCreate?: casino_most_popularCreateOrConnectWithoutCasino_most_popular_slot_gamesInput
    upsert?: casino_most_popularUpsertWithoutCasino_most_popular_slot_gamesInput
    connect?: casino_most_popularWhereUniqueInput
    update?: XOR<XOR<casino_most_popularUpdateToOneWithWhereWithoutCasino_most_popular_slot_gamesInput, casino_most_popularUpdateWithoutCasino_most_popular_slot_gamesInput>, casino_most_popularUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput>
  }

  export type settingsCreateNestedOneWithoutClient_client_settings_idTosettingsInput = {
    create?: XOR<settingsCreateWithoutClient_client_settings_idTosettingsInput, settingsUncheckedCreateWithoutClient_client_settings_idTosettingsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutClient_client_settings_idTosettingsInput
    connect?: settingsWhereUniqueInput
  }

  export type client_auth_userCreateNestedManyWithoutClientInput = {
    create?: XOR<client_auth_userCreateWithoutClientInput, client_auth_userUncheckedCreateWithoutClientInput> | client_auth_userCreateWithoutClientInput[] | client_auth_userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutClientInput | client_auth_userCreateOrConnectWithoutClientInput[]
    createMany?: client_auth_userCreateManyClientInputEnvelope
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
  }

  export type settingsCreateNestedManyWithoutClient_settings_client_idToclientInput = {
    create?: XOR<settingsCreateWithoutClient_settings_client_idToclientInput, settingsUncheckedCreateWithoutClient_settings_client_idToclientInput> | settingsCreateWithoutClient_settings_client_idToclientInput[] | settingsUncheckedCreateWithoutClient_settings_client_idToclientInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutClient_settings_client_idToclientInput | settingsCreateOrConnectWithoutClient_settings_client_idToclientInput[]
    createMany?: settingsCreateManyClient_settings_client_idToclientInputEnvelope
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
  }

  export type userCreateNestedManyWithoutClientInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type client_auth_userUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<client_auth_userCreateWithoutClientInput, client_auth_userUncheckedCreateWithoutClientInput> | client_auth_userCreateWithoutClientInput[] | client_auth_userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutClientInput | client_auth_userCreateOrConnectWithoutClientInput[]
    createMany?: client_auth_userCreateManyClientInputEnvelope
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
  }

  export type settingsUncheckedCreateNestedManyWithoutClient_settings_client_idToclientInput = {
    create?: XOR<settingsCreateWithoutClient_settings_client_idToclientInput, settingsUncheckedCreateWithoutClient_settings_client_idToclientInput> | settingsCreateWithoutClient_settings_client_idToclientInput[] | settingsUncheckedCreateWithoutClient_settings_client_idToclientInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutClient_settings_client_idToclientInput | settingsCreateOrConnectWithoutClient_settings_client_idToclientInput[]
    createMany?: settingsCreateManyClient_settings_client_idToclientInputEnvelope
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type settingsUpdateOneWithoutClient_client_settings_idTosettingsNestedInput = {
    create?: XOR<settingsCreateWithoutClient_client_settings_idTosettingsInput, settingsUncheckedCreateWithoutClient_client_settings_idTosettingsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutClient_client_settings_idTosettingsInput
    upsert?: settingsUpsertWithoutClient_client_settings_idTosettingsInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutClient_client_settings_idTosettingsInput, settingsUpdateWithoutClient_client_settings_idTosettingsInput>, settingsUncheckedUpdateWithoutClient_client_settings_idTosettingsInput>
  }

  export type client_auth_userUpdateManyWithoutClientNestedInput = {
    create?: XOR<client_auth_userCreateWithoutClientInput, client_auth_userUncheckedCreateWithoutClientInput> | client_auth_userCreateWithoutClientInput[] | client_auth_userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutClientInput | client_auth_userCreateOrConnectWithoutClientInput[]
    upsert?: client_auth_userUpsertWithWhereUniqueWithoutClientInput | client_auth_userUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: client_auth_userCreateManyClientInputEnvelope
    set?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    disconnect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    delete?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    update?: client_auth_userUpdateWithWhereUniqueWithoutClientInput | client_auth_userUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: client_auth_userUpdateManyWithWhereWithoutClientInput | client_auth_userUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: client_auth_userScalarWhereInput | client_auth_userScalarWhereInput[]
  }

  export type settingsUpdateManyWithoutClient_settings_client_idToclientNestedInput = {
    create?: XOR<settingsCreateWithoutClient_settings_client_idToclientInput, settingsUncheckedCreateWithoutClient_settings_client_idToclientInput> | settingsCreateWithoutClient_settings_client_idToclientInput[] | settingsUncheckedCreateWithoutClient_settings_client_idToclientInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutClient_settings_client_idToclientInput | settingsCreateOrConnectWithoutClient_settings_client_idToclientInput[]
    upsert?: settingsUpsertWithWhereUniqueWithoutClient_settings_client_idToclientInput | settingsUpsertWithWhereUniqueWithoutClient_settings_client_idToclientInput[]
    createMany?: settingsCreateManyClient_settings_client_idToclientInputEnvelope
    set?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    disconnect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    delete?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    update?: settingsUpdateWithWhereUniqueWithoutClient_settings_client_idToclientInput | settingsUpdateWithWhereUniqueWithoutClient_settings_client_idToclientInput[]
    updateMany?: settingsUpdateManyWithWhereWithoutClient_settings_client_idToclientInput | settingsUpdateManyWithWhereWithoutClient_settings_client_idToclientInput[]
    deleteMany?: settingsScalarWhereInput | settingsScalarWhereInput[]
  }

  export type userUpdateManyWithoutClientNestedInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    upsert?: userUpsertWithWhereUniqueWithoutClientInput | userUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutClientInput | userUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: userUpdateManyWithWhereWithoutClientInput | userUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type client_auth_userUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<client_auth_userCreateWithoutClientInput, client_auth_userUncheckedCreateWithoutClientInput> | client_auth_userCreateWithoutClientInput[] | client_auth_userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: client_auth_userCreateOrConnectWithoutClientInput | client_auth_userCreateOrConnectWithoutClientInput[]
    upsert?: client_auth_userUpsertWithWhereUniqueWithoutClientInput | client_auth_userUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: client_auth_userCreateManyClientInputEnvelope
    set?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    disconnect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    delete?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    connect?: client_auth_userWhereUniqueInput | client_auth_userWhereUniqueInput[]
    update?: client_auth_userUpdateWithWhereUniqueWithoutClientInput | client_auth_userUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: client_auth_userUpdateManyWithWhereWithoutClientInput | client_auth_userUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: client_auth_userScalarWhereInput | client_auth_userScalarWhereInput[]
  }

  export type settingsUncheckedUpdateManyWithoutClient_settings_client_idToclientNestedInput = {
    create?: XOR<settingsCreateWithoutClient_settings_client_idToclientInput, settingsUncheckedCreateWithoutClient_settings_client_idToclientInput> | settingsCreateWithoutClient_settings_client_idToclientInput[] | settingsUncheckedCreateWithoutClient_settings_client_idToclientInput[]
    connectOrCreate?: settingsCreateOrConnectWithoutClient_settings_client_idToclientInput | settingsCreateOrConnectWithoutClient_settings_client_idToclientInput[]
    upsert?: settingsUpsertWithWhereUniqueWithoutClient_settings_client_idToclientInput | settingsUpsertWithWhereUniqueWithoutClient_settings_client_idToclientInput[]
    createMany?: settingsCreateManyClient_settings_client_idToclientInputEnvelope
    set?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    disconnect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    delete?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    connect?: settingsWhereUniqueInput | settingsWhereUniqueInput[]
    update?: settingsUpdateWithWhereUniqueWithoutClient_settings_client_idToclientInput | settingsUpdateWithWhereUniqueWithoutClient_settings_client_idToclientInput[]
    updateMany?: settingsUpdateManyWithWhereWithoutClient_settings_client_idToclientInput | settingsUpdateManyWithWhereWithoutClient_settings_client_idToclientInput[]
    deleteMany?: settingsScalarWhereInput | settingsScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput> | userCreateWithoutClientInput[] | userUncheckedCreateWithoutClientInput[]
    connectOrCreate?: userCreateOrConnectWithoutClientInput | userCreateOrConnectWithoutClientInput[]
    upsert?: userUpsertWithWhereUniqueWithoutClientInput | userUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: userCreateManyClientInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutClientInput | userUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: userUpdateManyWithWhereWithoutClientInput | userUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type clientCreateNestedOneWithoutClient_auth_userInput = {
    create?: XOR<clientCreateWithoutClient_auth_userInput, clientUncheckedCreateWithoutClient_auth_userInput>
    connectOrCreate?: clientCreateOrConnectWithoutClient_auth_userInput
    connect?: clientWhereUniqueInput
  }

  export type auth_userCreateNestedOneWithoutClient_auth_userInput = {
    create?: XOR<auth_userCreateWithoutClient_auth_userInput, auth_userUncheckedCreateWithoutClient_auth_userInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutClient_auth_userInput
    connect?: auth_userWhereUniqueInput
  }

  export type clientUpdateOneRequiredWithoutClient_auth_userNestedInput = {
    create?: XOR<clientCreateWithoutClient_auth_userInput, clientUncheckedCreateWithoutClient_auth_userInput>
    connectOrCreate?: clientCreateOrConnectWithoutClient_auth_userInput
    upsert?: clientUpsertWithoutClient_auth_userInput
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutClient_auth_userInput, clientUpdateWithoutClient_auth_userInput>, clientUncheckedUpdateWithoutClient_auth_userInput>
  }

  export type auth_userUpdateOneRequiredWithoutClient_auth_userNestedInput = {
    create?: XOR<auth_userCreateWithoutClient_auth_userInput, auth_userUncheckedCreateWithoutClient_auth_userInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutClient_auth_userInput
    upsert?: auth_userUpsertWithoutClient_auth_userInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutClient_auth_userInput, auth_userUpdateWithoutClient_auth_userInput>, auth_userUncheckedUpdateWithoutClient_auth_userInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type settingsCreateNestedOneWithoutLayout_colorsInput = {
    create?: XOR<settingsCreateWithoutLayout_colorsInput, settingsUncheckedCreateWithoutLayout_colorsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutLayout_colorsInput
    connect?: settingsWhereUniqueInput
  }

  export type settingsUpdateOneWithoutLayout_colorsNestedInput = {
    create?: XOR<settingsCreateWithoutLayout_colorsInput, settingsUncheckedCreateWithoutLayout_colorsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutLayout_colorsInput
    upsert?: settingsUpsertWithoutLayout_colorsInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutLayout_colorsInput, settingsUpdateWithoutLayout_colorsInput>, settingsUncheckedUpdateWithoutLayout_colorsInput>
  }

  export type live_casino_most_popular_slot_gamesCreateNestedManyWithoutLive_casino_most_popularInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput> | live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInputEnvelope
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type slot_settingsCreateNestedOneWithoutLive_casino_most_popularInput = {
    create?: XOR<slot_settingsCreateWithoutLive_casino_most_popularInput, slot_settingsUncheckedCreateWithoutLive_casino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutLive_casino_most_popularInput
    connect?: slot_settingsWhereUniqueInput
  }

  export type live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutLive_casino_most_popularInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput> | live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInputEnvelope
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type slot_settingsUncheckedCreateNestedOneWithoutLive_casino_most_popularInput = {
    create?: XOR<slot_settingsCreateWithoutLive_casino_most_popularInput, slot_settingsUncheckedCreateWithoutLive_casino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutLive_casino_most_popularInput
    connect?: slot_settingsWhereUniqueInput
  }

  export type live_casino_most_popular_slot_gamesUpdateManyWithoutLive_casino_most_popularNestedInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput> | live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput[]
    upsert?: live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutLive_casino_most_popularInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInputEnvelope
    set?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutLive_casino_most_popularInput[]
    updateMany?: live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutLive_casino_most_popularInput[]
    deleteMany?: live_casino_most_popular_slot_gamesScalarWhereInput | live_casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type slot_settingsUpdateOneWithoutLive_casino_most_popularNestedInput = {
    create?: XOR<slot_settingsCreateWithoutLive_casino_most_popularInput, slot_settingsUncheckedCreateWithoutLive_casino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutLive_casino_most_popularInput
    upsert?: slot_settingsUpsertWithoutLive_casino_most_popularInput
    disconnect?: slot_settingsWhereInput | boolean
    delete?: slot_settingsWhereInput | boolean
    connect?: slot_settingsWhereUniqueInput
    update?: XOR<XOR<slot_settingsUpdateToOneWithWhereWithoutLive_casino_most_popularInput, slot_settingsUpdateWithoutLive_casino_most_popularInput>, slot_settingsUncheckedUpdateWithoutLive_casino_most_popularInput>
  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutLive_casino_most_popularNestedInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput> | live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput[]
    upsert?: live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutLive_casino_most_popularInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInputEnvelope
    set?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutLive_casino_most_popularInput[]
    updateMany?: live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutLive_casino_most_popularInput | live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutLive_casino_most_popularInput[]
    deleteMany?: live_casino_most_popular_slot_gamesScalarWhereInput | live_casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type slot_settingsUncheckedUpdateOneWithoutLive_casino_most_popularNestedInput = {
    create?: XOR<slot_settingsCreateWithoutLive_casino_most_popularInput, slot_settingsUncheckedCreateWithoutLive_casino_most_popularInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutLive_casino_most_popularInput
    upsert?: slot_settingsUpsertWithoutLive_casino_most_popularInput
    disconnect?: slot_settingsWhereInput | boolean
    delete?: slot_settingsWhereInput | boolean
    connect?: slot_settingsWhereUniqueInput
    update?: XOR<XOR<slot_settingsUpdateToOneWithWhereWithoutLive_casino_most_popularInput, slot_settingsUpdateWithoutLive_casino_most_popularInput>, slot_settingsUncheckedUpdateWithoutLive_casino_most_popularInput>
  }

  export type live_casino_most_popularCreateNestedOneWithoutLive_casino_most_popular_slot_gamesInput = {
    create?: XOR<live_casino_most_popularCreateWithoutLive_casino_most_popular_slot_gamesInput, live_casino_most_popularUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
    connectOrCreate?: live_casino_most_popularCreateOrConnectWithoutLive_casino_most_popular_slot_gamesInput
    connect?: live_casino_most_popularWhereUniqueInput
  }

  export type slot_gamesCreateNestedOneWithoutLive_casino_most_popular_slot_gamesInput = {
    create?: XOR<slot_gamesCreateWithoutLive_casino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
    connectOrCreate?: slot_gamesCreateOrConnectWithoutLive_casino_most_popular_slot_gamesInput
    connect?: slot_gamesWhereUniqueInput
  }

  export type live_casino_most_popularUpdateOneRequiredWithoutLive_casino_most_popular_slot_gamesNestedInput = {
    create?: XOR<live_casino_most_popularCreateWithoutLive_casino_most_popular_slot_gamesInput, live_casino_most_popularUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
    connectOrCreate?: live_casino_most_popularCreateOrConnectWithoutLive_casino_most_popular_slot_gamesInput
    upsert?: live_casino_most_popularUpsertWithoutLive_casino_most_popular_slot_gamesInput
    connect?: live_casino_most_popularWhereUniqueInput
    update?: XOR<XOR<live_casino_most_popularUpdateToOneWithWhereWithoutLive_casino_most_popular_slot_gamesInput, live_casino_most_popularUpdateWithoutLive_casino_most_popular_slot_gamesInput>, live_casino_most_popularUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput>
  }

  export type slot_gamesUpdateOneRequiredWithoutLive_casino_most_popular_slot_gamesNestedInput = {
    create?: XOR<slot_gamesCreateWithoutLive_casino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
    connectOrCreate?: slot_gamesCreateOrConnectWithoutLive_casino_most_popular_slot_gamesInput
    upsert?: slot_gamesUpsertWithoutLive_casino_most_popular_slot_gamesInput
    connect?: slot_gamesWhereUniqueInput
    update?: XOR<XOR<slot_gamesUpdateToOneWithWhereWithoutLive_casino_most_popular_slot_gamesInput, slot_gamesUpdateWithoutLive_casino_most_popular_slot_gamesInput>, slot_gamesUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type settingsCreateNestedOneWithoutOperationsInput = {
    create?: XOR<settingsCreateWithoutOperationsInput, settingsUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutOperationsInput
    connect?: settingsWhereUniqueInput
  }

  export type settingsUncheckedCreateNestedOneWithoutOperationsInput = {
    create?: XOR<settingsCreateWithoutOperationsInput, settingsUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutOperationsInput
    connect?: settingsWhereUniqueInput
  }

  export type settingsUpdateOneWithoutOperationsNestedInput = {
    create?: XOR<settingsCreateWithoutOperationsInput, settingsUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutOperationsInput
    upsert?: settingsUpsertWithoutOperationsInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutOperationsInput, settingsUpdateWithoutOperationsInput>, settingsUncheckedUpdateWithoutOperationsInput>
  }

  export type settingsUncheckedUpdateOneWithoutOperationsNestedInput = {
    create?: XOR<settingsCreateWithoutOperationsInput, settingsUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutOperationsInput
    upsert?: settingsUpsertWithoutOperationsInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutOperationsInput, settingsUpdateWithoutOperationsInput>, settingsUncheckedUpdateWithoutOperationsInput>
  }

  export type slot_gamesCreateNestedManyWithoutProviderInput = {
    create?: XOR<slot_gamesCreateWithoutProviderInput, slot_gamesUncheckedCreateWithoutProviderInput> | slot_gamesCreateWithoutProviderInput[] | slot_gamesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: slot_gamesCreateOrConnectWithoutProviderInput | slot_gamesCreateOrConnectWithoutProviderInput[]
    createMany?: slot_gamesCreateManyProviderInputEnvelope
    connect?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
  }

  export type slot_gamesUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<slot_gamesCreateWithoutProviderInput, slot_gamesUncheckedCreateWithoutProviderInput> | slot_gamesCreateWithoutProviderInput[] | slot_gamesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: slot_gamesCreateOrConnectWithoutProviderInput | slot_gamesCreateOrConnectWithoutProviderInput[]
    createMany?: slot_gamesCreateManyProviderInputEnvelope
    connect?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
  }

  export type slot_gamesUpdateManyWithoutProviderNestedInput = {
    create?: XOR<slot_gamesCreateWithoutProviderInput, slot_gamesUncheckedCreateWithoutProviderInput> | slot_gamesCreateWithoutProviderInput[] | slot_gamesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: slot_gamesCreateOrConnectWithoutProviderInput | slot_gamesCreateOrConnectWithoutProviderInput[]
    upsert?: slot_gamesUpsertWithWhereUniqueWithoutProviderInput | slot_gamesUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: slot_gamesCreateManyProviderInputEnvelope
    set?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    disconnect?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    delete?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    connect?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    update?: slot_gamesUpdateWithWhereUniqueWithoutProviderInput | slot_gamesUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: slot_gamesUpdateManyWithWhereWithoutProviderInput | slot_gamesUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: slot_gamesScalarWhereInput | slot_gamesScalarWhereInput[]
  }

  export type slot_gamesUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<slot_gamesCreateWithoutProviderInput, slot_gamesUncheckedCreateWithoutProviderInput> | slot_gamesCreateWithoutProviderInput[] | slot_gamesUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: slot_gamesCreateOrConnectWithoutProviderInput | slot_gamesCreateOrConnectWithoutProviderInput[]
    upsert?: slot_gamesUpsertWithWhereUniqueWithoutProviderInput | slot_gamesUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: slot_gamesCreateManyProviderInputEnvelope
    set?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    disconnect?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    delete?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    connect?: slot_gamesWhereUniqueInput | slot_gamesWhereUniqueInput[]
    update?: slot_gamesUpdateWithWhereUniqueWithoutProviderInput | slot_gamesUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: slot_gamesUpdateManyWithWhereWithoutProviderInput | slot_gamesUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: slot_gamesScalarWhereInput | slot_gamesScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutReferral_history_referral_history_referral_idTouserInput = {
    create?: XOR<userCreateWithoutReferral_history_referral_history_referral_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_referral_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_history_referral_history_referral_idTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutReferral_history_referral_history_user_idTouserInput = {
    create?: XOR<userCreateWithoutReferral_history_referral_history_user_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_user_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_history_referral_history_user_idTouserInput
    connect?: userWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type userUpdateOneRequiredWithoutReferral_history_referral_history_referral_idTouserNestedInput = {
    create?: XOR<userCreateWithoutReferral_history_referral_history_referral_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_referral_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_history_referral_history_referral_idTouserInput
    upsert?: userUpsertWithoutReferral_history_referral_history_referral_idTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReferral_history_referral_history_referral_idTouserInput, userUpdateWithoutReferral_history_referral_history_referral_idTouserInput>, userUncheckedUpdateWithoutReferral_history_referral_history_referral_idTouserInput>
  }

  export type userUpdateOneWithoutReferral_history_referral_history_user_idTouserNestedInput = {
    create?: XOR<userCreateWithoutReferral_history_referral_history_user_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_user_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_history_referral_history_user_idTouserInput
    upsert?: userUpsertWithoutReferral_history_referral_history_user_idTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReferral_history_referral_history_user_idTouserInput, userUpdateWithoutReferral_history_referral_history_user_idTouserInput>, userUncheckedUpdateWithoutReferral_history_referral_history_user_idTouserInput>
  }

  export type userCreateNestedOneWithoutReferral_settingsInput = {
    create?: XOR<userCreateWithoutReferral_settingsInput, userUncheckedCreateWithoutReferral_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_settingsInput
    connect?: userWhereUniqueInput
  }

  export type userUncheckedCreateNestedOneWithoutReferral_settingsInput = {
    create?: XOR<userCreateWithoutReferral_settingsInput, userUncheckedCreateWithoutReferral_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_settingsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutReferral_settingsNestedInput = {
    create?: XOR<userCreateWithoutReferral_settingsInput, userUncheckedCreateWithoutReferral_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_settingsInput
    upsert?: userUpsertWithoutReferral_settingsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReferral_settingsInput, userUpdateWithoutReferral_settingsInput>, userUncheckedUpdateWithoutReferral_settingsInput>
  }

  export type userUncheckedUpdateOneWithoutReferral_settingsNestedInput = {
    create?: XOR<userCreateWithoutReferral_settingsInput, userUncheckedCreateWithoutReferral_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutReferral_settingsInput
    upsert?: userUpsertWithoutReferral_settingsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReferral_settingsInput, userUpdateWithoutReferral_settingsInput>, userUncheckedUpdateWithoutReferral_settingsInput>
  }

  export type clientCreateNestedOneWithoutSettings_client_settings_idTosettingsInput = {
    create?: XOR<clientCreateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedCreateWithoutSettings_client_settings_idTosettingsInput>
    connectOrCreate?: clientCreateOrConnectWithoutSettings_client_settings_idTosettingsInput
    connect?: clientWhereUniqueInput
  }

  export type layout_colorsCreateNestedManyWithoutSettingsInput = {
    create?: XOR<layout_colorsCreateWithoutSettingsInput, layout_colorsUncheckedCreateWithoutSettingsInput> | layout_colorsCreateWithoutSettingsInput[] | layout_colorsUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: layout_colorsCreateOrConnectWithoutSettingsInput | layout_colorsCreateOrConnectWithoutSettingsInput[]
    createMany?: layout_colorsCreateManySettingsInputEnvelope
    connect?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
  }

  export type clientCreateNestedOneWithoutSettings_settings_client_idToclientInput = {
    create?: XOR<clientCreateWithoutSettings_settings_client_idToclientInput, clientUncheckedCreateWithoutSettings_settings_client_idToclientInput>
    connectOrCreate?: clientCreateOrConnectWithoutSettings_settings_client_idToclientInput
    connect?: clientWhereUniqueInput
  }

  export type operationsCreateNestedOneWithoutSettingsInput = {
    create?: XOR<operationsCreateWithoutSettingsInput, operationsUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: operationsCreateOrConnectWithoutSettingsInput
    connect?: operationsWhereUniqueInput
  }

  export type slot_settingsCreateNestedOneWithoutSettingsInput = {
    create?: XOR<slot_settingsCreateWithoutSettingsInput, slot_settingsUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutSettingsInput
    connect?: slot_settingsWhereUniqueInput
  }

  export type clientUncheckedCreateNestedOneWithoutSettings_client_settings_idTosettingsInput = {
    create?: XOR<clientCreateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedCreateWithoutSettings_client_settings_idTosettingsInput>
    connectOrCreate?: clientCreateOrConnectWithoutSettings_client_settings_idTosettingsInput
    connect?: clientWhereUniqueInput
  }

  export type layout_colorsUncheckedCreateNestedManyWithoutSettingsInput = {
    create?: XOR<layout_colorsCreateWithoutSettingsInput, layout_colorsUncheckedCreateWithoutSettingsInput> | layout_colorsCreateWithoutSettingsInput[] | layout_colorsUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: layout_colorsCreateOrConnectWithoutSettingsInput | layout_colorsCreateOrConnectWithoutSettingsInput[]
    createMany?: layout_colorsCreateManySettingsInputEnvelope
    connect?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
  }

  export type clientUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput = {
    create?: XOR<clientCreateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedCreateWithoutSettings_client_settings_idTosettingsInput>
    connectOrCreate?: clientCreateOrConnectWithoutSettings_client_settings_idTosettingsInput
    upsert?: clientUpsertWithoutSettings_client_settings_idTosettingsInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutSettings_client_settings_idTosettingsInput, clientUpdateWithoutSettings_client_settings_idTosettingsInput>, clientUncheckedUpdateWithoutSettings_client_settings_idTosettingsInput>
  }

  export type layout_colorsUpdateManyWithoutSettingsNestedInput = {
    create?: XOR<layout_colorsCreateWithoutSettingsInput, layout_colorsUncheckedCreateWithoutSettingsInput> | layout_colorsCreateWithoutSettingsInput[] | layout_colorsUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: layout_colorsCreateOrConnectWithoutSettingsInput | layout_colorsCreateOrConnectWithoutSettingsInput[]
    upsert?: layout_colorsUpsertWithWhereUniqueWithoutSettingsInput | layout_colorsUpsertWithWhereUniqueWithoutSettingsInput[]
    createMany?: layout_colorsCreateManySettingsInputEnvelope
    set?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    disconnect?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    delete?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    connect?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    update?: layout_colorsUpdateWithWhereUniqueWithoutSettingsInput | layout_colorsUpdateWithWhereUniqueWithoutSettingsInput[]
    updateMany?: layout_colorsUpdateManyWithWhereWithoutSettingsInput | layout_colorsUpdateManyWithWhereWithoutSettingsInput[]
    deleteMany?: layout_colorsScalarWhereInput | layout_colorsScalarWhereInput[]
  }

  export type clientUpdateOneRequiredWithoutSettings_settings_client_idToclientNestedInput = {
    create?: XOR<clientCreateWithoutSettings_settings_client_idToclientInput, clientUncheckedCreateWithoutSettings_settings_client_idToclientInput>
    connectOrCreate?: clientCreateOrConnectWithoutSettings_settings_client_idToclientInput
    upsert?: clientUpsertWithoutSettings_settings_client_idToclientInput
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutSettings_settings_client_idToclientInput, clientUpdateWithoutSettings_settings_client_idToclientInput>, clientUncheckedUpdateWithoutSettings_settings_client_idToclientInput>
  }

  export type operationsUpdateOneWithoutSettingsNestedInput = {
    create?: XOR<operationsCreateWithoutSettingsInput, operationsUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: operationsCreateOrConnectWithoutSettingsInput
    upsert?: operationsUpsertWithoutSettingsInput
    disconnect?: operationsWhereInput | boolean
    delete?: operationsWhereInput | boolean
    connect?: operationsWhereUniqueInput
    update?: XOR<XOR<operationsUpdateToOneWithWhereWithoutSettingsInput, operationsUpdateWithoutSettingsInput>, operationsUncheckedUpdateWithoutSettingsInput>
  }

  export type slot_settingsUpdateOneWithoutSettingsNestedInput = {
    create?: XOR<slot_settingsCreateWithoutSettingsInput, slot_settingsUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: slot_settingsCreateOrConnectWithoutSettingsInput
    upsert?: slot_settingsUpsertWithoutSettingsInput
    disconnect?: slot_settingsWhereInput | boolean
    delete?: slot_settingsWhereInput | boolean
    connect?: slot_settingsWhereUniqueInput
    update?: XOR<XOR<slot_settingsUpdateToOneWithWhereWithoutSettingsInput, slot_settingsUpdateWithoutSettingsInput>, slot_settingsUncheckedUpdateWithoutSettingsInput>
  }

  export type clientUncheckedUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput = {
    create?: XOR<clientCreateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedCreateWithoutSettings_client_settings_idTosettingsInput>
    connectOrCreate?: clientCreateOrConnectWithoutSettings_client_settings_idTosettingsInput
    upsert?: clientUpsertWithoutSettings_client_settings_idTosettingsInput
    disconnect?: clientWhereInput | boolean
    delete?: clientWhereInput | boolean
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutSettings_client_settings_idTosettingsInput, clientUpdateWithoutSettings_client_settings_idTosettingsInput>, clientUncheckedUpdateWithoutSettings_client_settings_idTosettingsInput>
  }

  export type layout_colorsUncheckedUpdateManyWithoutSettingsNestedInput = {
    create?: XOR<layout_colorsCreateWithoutSettingsInput, layout_colorsUncheckedCreateWithoutSettingsInput> | layout_colorsCreateWithoutSettingsInput[] | layout_colorsUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: layout_colorsCreateOrConnectWithoutSettingsInput | layout_colorsCreateOrConnectWithoutSettingsInput[]
    upsert?: layout_colorsUpsertWithWhereUniqueWithoutSettingsInput | layout_colorsUpsertWithWhereUniqueWithoutSettingsInput[]
    createMany?: layout_colorsCreateManySettingsInputEnvelope
    set?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    disconnect?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    delete?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    connect?: layout_colorsWhereUniqueInput | layout_colorsWhereUniqueInput[]
    update?: layout_colorsUpdateWithWhereUniqueWithoutSettingsInput | layout_colorsUpdateWithWhereUniqueWithoutSettingsInput[]
    updateMany?: layout_colorsUpdateManyWithWhereWithoutSettingsInput | layout_colorsUpdateManyWithWhereWithoutSettingsInput[]
    deleteMany?: layout_colorsScalarWhereInput | layout_colorsScalarWhereInput[]
  }

  export type bet_operationsCreateNestedManyWithoutSlot_gamesInput = {
    create?: XOR<bet_operationsCreateWithoutSlot_gamesInput, bet_operationsUncheckedCreateWithoutSlot_gamesInput> | bet_operationsCreateWithoutSlot_gamesInput[] | bet_operationsUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutSlot_gamesInput | bet_operationsCreateOrConnectWithoutSlot_gamesInput[]
    createMany?: bet_operationsCreateManySlot_gamesInputEnvelope
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
  }

  export type casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    createMany?: casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type live_casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type providerCreateNestedOneWithoutSlot_gamesInput = {
    create?: XOR<providerCreateWithoutSlot_gamesInput, providerUncheckedCreateWithoutSlot_gamesInput>
    connectOrCreate?: providerCreateOrConnectWithoutSlot_gamesInput
    connect?: providerWhereUniqueInput
  }

  export type bet_operationsUncheckedCreateNestedManyWithoutSlot_gamesInput = {
    create?: XOR<bet_operationsCreateWithoutSlot_gamesInput, bet_operationsUncheckedCreateWithoutSlot_gamesInput> | bet_operationsCreateWithoutSlot_gamesInput[] | bet_operationsUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutSlot_gamesInput | bet_operationsCreateOrConnectWithoutSlot_gamesInput[]
    createMany?: bet_operationsCreateManySlot_gamesInputEnvelope
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
  }

  export type casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    createMany?: casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
  }

  export type bet_operationsUpdateManyWithoutSlot_gamesNestedInput = {
    create?: XOR<bet_operationsCreateWithoutSlot_gamesInput, bet_operationsUncheckedCreateWithoutSlot_gamesInput> | bet_operationsCreateWithoutSlot_gamesInput[] | bet_operationsUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutSlot_gamesInput | bet_operationsCreateOrConnectWithoutSlot_gamesInput[]
    upsert?: bet_operationsUpsertWithWhereUniqueWithoutSlot_gamesInput | bet_operationsUpsertWithWhereUniqueWithoutSlot_gamesInput[]
    createMany?: bet_operationsCreateManySlot_gamesInputEnvelope
    set?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    disconnect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    delete?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    update?: bet_operationsUpdateWithWhereUniqueWithoutSlot_gamesInput | bet_operationsUpdateWithWhereUniqueWithoutSlot_gamesInput[]
    updateMany?: bet_operationsUpdateManyWithWhereWithoutSlot_gamesInput | bet_operationsUpdateManyWithWhereWithoutSlot_gamesInput[]
    deleteMany?: bet_operationsScalarWhereInput | bet_operationsScalarWhereInput[]
  }

  export type casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    upsert?: casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput | casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput[]
    createMany?: casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    set?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput | casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput[]
    updateMany?: casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput | casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput[]
    deleteMany?: casino_most_popular_slot_gamesScalarWhereInput | casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type live_casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    upsert?: live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    set?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput[]
    updateMany?: live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput[]
    deleteMany?: live_casino_most_popular_slot_gamesScalarWhereInput | live_casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type providerUpdateOneRequiredWithoutSlot_gamesNestedInput = {
    create?: XOR<providerCreateWithoutSlot_gamesInput, providerUncheckedCreateWithoutSlot_gamesInput>
    connectOrCreate?: providerCreateOrConnectWithoutSlot_gamesInput
    upsert?: providerUpsertWithoutSlot_gamesInput
    connect?: providerWhereUniqueInput
    update?: XOR<XOR<providerUpdateToOneWithWhereWithoutSlot_gamesInput, providerUpdateWithoutSlot_gamesInput>, providerUncheckedUpdateWithoutSlot_gamesInput>
  }

  export type bet_operationsUncheckedUpdateManyWithoutSlot_gamesNestedInput = {
    create?: XOR<bet_operationsCreateWithoutSlot_gamesInput, bet_operationsUncheckedCreateWithoutSlot_gamesInput> | bet_operationsCreateWithoutSlot_gamesInput[] | bet_operationsUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutSlot_gamesInput | bet_operationsCreateOrConnectWithoutSlot_gamesInput[]
    upsert?: bet_operationsUpsertWithWhereUniqueWithoutSlot_gamesInput | bet_operationsUpsertWithWhereUniqueWithoutSlot_gamesInput[]
    createMany?: bet_operationsCreateManySlot_gamesInputEnvelope
    set?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    disconnect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    delete?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    update?: bet_operationsUpdateWithWhereUniqueWithoutSlot_gamesInput | bet_operationsUpdateWithWhereUniqueWithoutSlot_gamesInput[]
    updateMany?: bet_operationsUpdateManyWithWhereWithoutSlot_gamesInput | bet_operationsUpdateManyWithWhereWithoutSlot_gamesInput[]
    deleteMany?: bet_operationsScalarWhereInput | bet_operationsScalarWhereInput[]
  }

  export type casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput = {
    create?: XOR<casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    upsert?: casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput | casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput[]
    createMany?: casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    set?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: casino_most_popular_slot_gamesWhereUniqueInput | casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput | casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput[]
    updateMany?: casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput | casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput[]
    deleteMany?: casino_most_popular_slot_gamesScalarWhereInput | casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput = {
    create?: XOR<live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput> | live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput[] | live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput[]
    connectOrCreate?: live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput[]
    upsert?: live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput[]
    createMany?: live_casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope
    set?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    disconnect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    delete?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    connect?: live_casino_most_popular_slot_gamesWhereUniqueInput | live_casino_most_popular_slot_gamesWhereUniqueInput[]
    update?: live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput[]
    updateMany?: live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput | live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput[]
    deleteMany?: live_casino_most_popular_slot_gamesScalarWhereInput | live_casino_most_popular_slot_gamesScalarWhereInput[]
  }

  export type banner_more_profitableCreateNestedManyWithoutSlot_settingsInput = {
    create?: XOR<banner_more_profitableCreateWithoutSlot_settingsInput, banner_more_profitableUncheckedCreateWithoutSlot_settingsInput> | banner_more_profitableCreateWithoutSlot_settingsInput[] | banner_more_profitableUncheckedCreateWithoutSlot_settingsInput[]
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutSlot_settingsInput | banner_more_profitableCreateOrConnectWithoutSlot_settingsInput[]
    createMany?: banner_more_profitableCreateManySlot_settingsInputEnvelope
    connect?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
  }

  export type settingsCreateNestedOneWithoutSlot_settingsInput = {
    create?: XOR<settingsCreateWithoutSlot_settingsInput, settingsUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutSlot_settingsInput
    connect?: settingsWhereUniqueInput
  }

  export type live_casino_most_popularCreateNestedOneWithoutSlot_settingsInput = {
    create?: XOR<live_casino_most_popularCreateWithoutSlot_settingsInput, live_casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: live_casino_most_popularCreateOrConnectWithoutSlot_settingsInput
    connect?: live_casino_most_popularWhereUniqueInput
  }

  export type casino_most_popularCreateNestedOneWithoutSlot_settingsInput = {
    create?: XOR<casino_most_popularCreateWithoutSlot_settingsInput, casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: casino_most_popularCreateOrConnectWithoutSlot_settingsInput
    connect?: casino_most_popularWhereUniqueInput
  }

  export type banner_more_profitableUncheckedCreateNestedManyWithoutSlot_settingsInput = {
    create?: XOR<banner_more_profitableCreateWithoutSlot_settingsInput, banner_more_profitableUncheckedCreateWithoutSlot_settingsInput> | banner_more_profitableCreateWithoutSlot_settingsInput[] | banner_more_profitableUncheckedCreateWithoutSlot_settingsInput[]
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutSlot_settingsInput | banner_more_profitableCreateOrConnectWithoutSlot_settingsInput[]
    createMany?: banner_more_profitableCreateManySlot_settingsInputEnvelope
    connect?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
  }

  export type settingsUncheckedCreateNestedOneWithoutSlot_settingsInput = {
    create?: XOR<settingsCreateWithoutSlot_settingsInput, settingsUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutSlot_settingsInput
    connect?: settingsWhereUniqueInput
  }

  export type banner_more_profitableUpdateManyWithoutSlot_settingsNestedInput = {
    create?: XOR<banner_more_profitableCreateWithoutSlot_settingsInput, banner_more_profitableUncheckedCreateWithoutSlot_settingsInput> | banner_more_profitableCreateWithoutSlot_settingsInput[] | banner_more_profitableUncheckedCreateWithoutSlot_settingsInput[]
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutSlot_settingsInput | banner_more_profitableCreateOrConnectWithoutSlot_settingsInput[]
    upsert?: banner_more_profitableUpsertWithWhereUniqueWithoutSlot_settingsInput | banner_more_profitableUpsertWithWhereUniqueWithoutSlot_settingsInput[]
    createMany?: banner_more_profitableCreateManySlot_settingsInputEnvelope
    set?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    disconnect?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    delete?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    connect?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    update?: banner_more_profitableUpdateWithWhereUniqueWithoutSlot_settingsInput | banner_more_profitableUpdateWithWhereUniqueWithoutSlot_settingsInput[]
    updateMany?: banner_more_profitableUpdateManyWithWhereWithoutSlot_settingsInput | banner_more_profitableUpdateManyWithWhereWithoutSlot_settingsInput[]
    deleteMany?: banner_more_profitableScalarWhereInput | banner_more_profitableScalarWhereInput[]
  }

  export type settingsUpdateOneWithoutSlot_settingsNestedInput = {
    create?: XOR<settingsCreateWithoutSlot_settingsInput, settingsUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutSlot_settingsInput
    upsert?: settingsUpsertWithoutSlot_settingsInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutSlot_settingsInput, settingsUpdateWithoutSlot_settingsInput>, settingsUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type live_casino_most_popularUpdateOneWithoutSlot_settingsNestedInput = {
    create?: XOR<live_casino_most_popularCreateWithoutSlot_settingsInput, live_casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: live_casino_most_popularCreateOrConnectWithoutSlot_settingsInput
    upsert?: live_casino_most_popularUpsertWithoutSlot_settingsInput
    disconnect?: live_casino_most_popularWhereInput | boolean
    delete?: live_casino_most_popularWhereInput | boolean
    connect?: live_casino_most_popularWhereUniqueInput
    update?: XOR<XOR<live_casino_most_popularUpdateToOneWithWhereWithoutSlot_settingsInput, live_casino_most_popularUpdateWithoutSlot_settingsInput>, live_casino_most_popularUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type casino_most_popularUpdateOneWithoutSlot_settingsNestedInput = {
    create?: XOR<casino_most_popularCreateWithoutSlot_settingsInput, casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: casino_most_popularCreateOrConnectWithoutSlot_settingsInput
    upsert?: casino_most_popularUpsertWithoutSlot_settingsInput
    disconnect?: casino_most_popularWhereInput | boolean
    delete?: casino_most_popularWhereInput | boolean
    connect?: casino_most_popularWhereUniqueInput
    update?: XOR<XOR<casino_most_popularUpdateToOneWithWhereWithoutSlot_settingsInput, casino_most_popularUpdateWithoutSlot_settingsInput>, casino_most_popularUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type banner_more_profitableUncheckedUpdateManyWithoutSlot_settingsNestedInput = {
    create?: XOR<banner_more_profitableCreateWithoutSlot_settingsInput, banner_more_profitableUncheckedCreateWithoutSlot_settingsInput> | banner_more_profitableCreateWithoutSlot_settingsInput[] | banner_more_profitableUncheckedCreateWithoutSlot_settingsInput[]
    connectOrCreate?: banner_more_profitableCreateOrConnectWithoutSlot_settingsInput | banner_more_profitableCreateOrConnectWithoutSlot_settingsInput[]
    upsert?: banner_more_profitableUpsertWithWhereUniqueWithoutSlot_settingsInput | banner_more_profitableUpsertWithWhereUniqueWithoutSlot_settingsInput[]
    createMany?: banner_more_profitableCreateManySlot_settingsInputEnvelope
    set?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    disconnect?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    delete?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    connect?: banner_more_profitableWhereUniqueInput | banner_more_profitableWhereUniqueInput[]
    update?: banner_more_profitableUpdateWithWhereUniqueWithoutSlot_settingsInput | banner_more_profitableUpdateWithWhereUniqueWithoutSlot_settingsInput[]
    updateMany?: banner_more_profitableUpdateManyWithWhereWithoutSlot_settingsInput | banner_more_profitableUpdateManyWithWhereWithoutSlot_settingsInput[]
    deleteMany?: banner_more_profitableScalarWhereInput | banner_more_profitableScalarWhereInput[]
  }

  export type settingsUncheckedUpdateOneWithoutSlot_settingsNestedInput = {
    create?: XOR<settingsCreateWithoutSlot_settingsInput, settingsUncheckedCreateWithoutSlot_settingsInput>
    connectOrCreate?: settingsCreateOrConnectWithoutSlot_settingsInput
    upsert?: settingsUpsertWithoutSlot_settingsInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutSlot_settingsInput, settingsUpdateWithoutSlot_settingsInput>, settingsUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type bet_operationsCreateNestedManyWithoutUserInput = {
    create?: XOR<bet_operationsCreateWithoutUserInput, bet_operationsUncheckedCreateWithoutUserInput> | bet_operationsCreateWithoutUserInput[] | bet_operationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutUserInput | bet_operationsCreateOrConnectWithoutUserInput[]
    createMany?: bet_operationsCreateManyUserInputEnvelope
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
  }

  export type referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput> | referral_historyCreateWithoutUser_referral_history_referral_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_referral_idTouserInputEnvelope
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
  }

  export type referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput> | referral_historyCreateWithoutUser_referral_history_user_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_user_idTouserInputEnvelope
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
  }

  export type clientCreateNestedOneWithoutUserInput = {
    create?: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
    connectOrCreate?: clientCreateOrConnectWithoutUserInput
    connect?: clientWhereUniqueInput
  }

  export type userCreateNestedOneWithoutOther_userInput = {
    create?: XOR<userCreateWithoutOther_userInput, userUncheckedCreateWithoutOther_userInput>
    connectOrCreate?: userCreateOrConnectWithoutOther_userInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedManyWithoutUserInput = {
    create?: XOR<userCreateWithoutUserInput, userUncheckedCreateWithoutUserInput> | userCreateWithoutUserInput[] | userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUserInput | userCreateOrConnectWithoutUserInput[]
    createMany?: userCreateManyUserInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type referral_settingsCreateNestedOneWithoutUserInput = {
    create?: XOR<referral_settingsCreateWithoutUserInput, referral_settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: referral_settingsCreateOrConnectWithoutUserInput
    connect?: referral_settingsWhereUniqueInput
  }

  export type walletCreateNestedOneWithoutUserInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    connectOrCreate?: walletCreateOrConnectWithoutUserInput
    connect?: walletWhereUniqueInput
  }

  export type wallet_transactionCreateNestedManyWithoutUserInput = {
    create?: XOR<wallet_transactionCreateWithoutUserInput, wallet_transactionUncheckedCreateWithoutUserInput> | wallet_transactionCreateWithoutUserInput[] | wallet_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutUserInput | wallet_transactionCreateOrConnectWithoutUserInput[]
    createMany?: wallet_transactionCreateManyUserInputEnvelope
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
  }

  export type bet_operationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<bet_operationsCreateWithoutUserInput, bet_operationsUncheckedCreateWithoutUserInput> | bet_operationsCreateWithoutUserInput[] | bet_operationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutUserInput | bet_operationsCreateOrConnectWithoutUserInput[]
    createMany?: bet_operationsCreateManyUserInputEnvelope
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
  }

  export type referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput> | referral_historyCreateWithoutUser_referral_history_referral_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_referral_idTouserInputEnvelope
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
  }

  export type referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput> | referral_historyCreateWithoutUser_referral_history_user_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_user_idTouserInputEnvelope
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userCreateWithoutUserInput, userUncheckedCreateWithoutUserInput> | userCreateWithoutUserInput[] | userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUserInput | userCreateOrConnectWithoutUserInput[]
    createMany?: userCreateManyUserInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type wallet_transactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<wallet_transactionCreateWithoutUserInput, wallet_transactionUncheckedCreateWithoutUserInput> | wallet_transactionCreateWithoutUserInput[] | wallet_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutUserInput | wallet_transactionCreateOrConnectWithoutUserInput[]
    createMany?: wallet_transactionCreateManyUserInputEnvelope
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type bet_operationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<bet_operationsCreateWithoutUserInput, bet_operationsUncheckedCreateWithoutUserInput> | bet_operationsCreateWithoutUserInput[] | bet_operationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutUserInput | bet_operationsCreateOrConnectWithoutUserInput[]
    upsert?: bet_operationsUpsertWithWhereUniqueWithoutUserInput | bet_operationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bet_operationsCreateManyUserInputEnvelope
    set?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    disconnect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    delete?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    update?: bet_operationsUpdateWithWhereUniqueWithoutUserInput | bet_operationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bet_operationsUpdateManyWithWhereWithoutUserInput | bet_operationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bet_operationsScalarWhereInput | bet_operationsScalarWhereInput[]
  }

  export type referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput> | referral_historyCreateWithoutUser_referral_history_referral_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput[]
    upsert?: referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput | referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_referral_idTouserInputEnvelope
    set?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    disconnect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    delete?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    update?: referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput | referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput[]
    updateMany?: referral_historyUpdateManyWithWhereWithoutUser_referral_history_referral_idTouserInput | referral_historyUpdateManyWithWhereWithoutUser_referral_history_referral_idTouserInput[]
    deleteMany?: referral_historyScalarWhereInput | referral_historyScalarWhereInput[]
  }

  export type referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput> | referral_historyCreateWithoutUser_referral_history_user_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput[]
    upsert?: referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_user_idTouserInput | referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_user_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_user_idTouserInputEnvelope
    set?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    disconnect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    delete?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    update?: referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_user_idTouserInput | referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_user_idTouserInput[]
    updateMany?: referral_historyUpdateManyWithWhereWithoutUser_referral_history_user_idTouserInput | referral_historyUpdateManyWithWhereWithoutUser_referral_history_user_idTouserInput[]
    deleteMany?: referral_historyScalarWhereInput | referral_historyScalarWhereInput[]
  }

  export type clientUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
    connectOrCreate?: clientCreateOrConnectWithoutUserInput
    upsert?: clientUpsertWithoutUserInput
    connect?: clientWhereUniqueInput
    update?: XOR<XOR<clientUpdateToOneWithWhereWithoutUserInput, clientUpdateWithoutUserInput>, clientUncheckedUpdateWithoutUserInput>
  }

  export type userUpdateOneWithoutOther_userNestedInput = {
    create?: XOR<userCreateWithoutOther_userInput, userUncheckedCreateWithoutOther_userInput>
    connectOrCreate?: userCreateOrConnectWithoutOther_userInput
    upsert?: userUpsertWithoutOther_userInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOther_userInput, userUpdateWithoutOther_userInput>, userUncheckedUpdateWithoutOther_userInput>
  }

  export type userUpdateManyWithoutUserNestedInput = {
    create?: XOR<userCreateWithoutUserInput, userUncheckedCreateWithoutUserInput> | userCreateWithoutUserInput[] | userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUserInput | userCreateOrConnectWithoutUserInput[]
    upsert?: userUpsertWithWhereUniqueWithoutUserInput | userUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userCreateManyUserInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutUserInput | userUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userUpdateManyWithWhereWithoutUserInput | userUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type referral_settingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<referral_settingsCreateWithoutUserInput, referral_settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: referral_settingsCreateOrConnectWithoutUserInput
    upsert?: referral_settingsUpsertWithoutUserInput
    disconnect?: referral_settingsWhereInput | boolean
    delete?: referral_settingsWhereInput | boolean
    connect?: referral_settingsWhereUniqueInput
    update?: XOR<XOR<referral_settingsUpdateToOneWithWhereWithoutUserInput, referral_settingsUpdateWithoutUserInput>, referral_settingsUncheckedUpdateWithoutUserInput>
  }

  export type walletUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    connectOrCreate?: walletCreateOrConnectWithoutUserInput
    upsert?: walletUpsertWithoutUserInput
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutUserInput, walletUpdateWithoutUserInput>, walletUncheckedUpdateWithoutUserInput>
  }

  export type wallet_transactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<wallet_transactionCreateWithoutUserInput, wallet_transactionUncheckedCreateWithoutUserInput> | wallet_transactionCreateWithoutUserInput[] | wallet_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutUserInput | wallet_transactionCreateOrConnectWithoutUserInput[]
    upsert?: wallet_transactionUpsertWithWhereUniqueWithoutUserInput | wallet_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: wallet_transactionCreateManyUserInputEnvelope
    set?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    disconnect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    delete?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    update?: wallet_transactionUpdateWithWhereUniqueWithoutUserInput | wallet_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: wallet_transactionUpdateManyWithWhereWithoutUserInput | wallet_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: wallet_transactionScalarWhereInput | wallet_transactionScalarWhereInput[]
  }

  export type bet_operationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<bet_operationsCreateWithoutUserInput, bet_operationsUncheckedCreateWithoutUserInput> | bet_operationsCreateWithoutUserInput[] | bet_operationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bet_operationsCreateOrConnectWithoutUserInput | bet_operationsCreateOrConnectWithoutUserInput[]
    upsert?: bet_operationsUpsertWithWhereUniqueWithoutUserInput | bet_operationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bet_operationsCreateManyUserInputEnvelope
    set?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    disconnect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    delete?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    connect?: bet_operationsWhereUniqueInput | bet_operationsWhereUniqueInput[]
    update?: bet_operationsUpdateWithWhereUniqueWithoutUserInput | bet_operationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bet_operationsUpdateManyWithWhereWithoutUserInput | bet_operationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bet_operationsScalarWhereInput | bet_operationsScalarWhereInput[]
  }

  export type referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput> | referral_historyCreateWithoutUser_referral_history_referral_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput[]
    upsert?: referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput | referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_referral_idTouserInputEnvelope
    set?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    disconnect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    delete?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    update?: referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput | referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput[]
    updateMany?: referral_historyUpdateManyWithWhereWithoutUser_referral_history_referral_idTouserInput | referral_historyUpdateManyWithWhereWithoutUser_referral_history_referral_idTouserInput[]
    deleteMany?: referral_historyScalarWhereInput | referral_historyScalarWhereInput[]
  }

  export type referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput = {
    create?: XOR<referral_historyCreateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput> | referral_historyCreateWithoutUser_referral_history_user_idTouserInput[] | referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput[]
    connectOrCreate?: referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput | referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput[]
    upsert?: referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_user_idTouserInput | referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_user_idTouserInput[]
    createMany?: referral_historyCreateManyUser_referral_history_user_idTouserInputEnvelope
    set?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    disconnect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    delete?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    connect?: referral_historyWhereUniqueInput | referral_historyWhereUniqueInput[]
    update?: referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_user_idTouserInput | referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_user_idTouserInput[]
    updateMany?: referral_historyUpdateManyWithWhereWithoutUser_referral_history_user_idTouserInput | referral_historyUpdateManyWithWhereWithoutUser_referral_history_user_idTouserInput[]
    deleteMany?: referral_historyScalarWhereInput | referral_historyScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userCreateWithoutUserInput, userUncheckedCreateWithoutUserInput> | userCreateWithoutUserInput[] | userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUserInput | userCreateOrConnectWithoutUserInput[]
    upsert?: userUpsertWithWhereUniqueWithoutUserInput | userUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userCreateManyUserInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutUserInput | userUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userUpdateManyWithWhereWithoutUserInput | userUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type wallet_transactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<wallet_transactionCreateWithoutUserInput, wallet_transactionUncheckedCreateWithoutUserInput> | wallet_transactionCreateWithoutUserInput[] | wallet_transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutUserInput | wallet_transactionCreateOrConnectWithoutUserInput[]
    upsert?: wallet_transactionUpsertWithWhereUniqueWithoutUserInput | wallet_transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: wallet_transactionCreateManyUserInputEnvelope
    set?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    disconnect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    delete?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    update?: wallet_transactionUpdateWithWhereUniqueWithoutUserInput | wallet_transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: wallet_transactionUpdateManyWithWhereWithoutUserInput | wallet_transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: wallet_transactionScalarWhereInput | wallet_transactionScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutWalletInput = {
    create?: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    connectOrCreate?: userCreateOrConnectWithoutWalletInput
    connect?: userWhereUniqueInput
  }

  export type wallet_transactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<wallet_transactionCreateWithoutWalletInput, wallet_transactionUncheckedCreateWithoutWalletInput> | wallet_transactionCreateWithoutWalletInput[] | wallet_transactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutWalletInput | wallet_transactionCreateOrConnectWithoutWalletInput[]
    createMany?: wallet_transactionCreateManyWalletInputEnvelope
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedOneWithoutWalletInput = {
    create?: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    connectOrCreate?: userCreateOrConnectWithoutWalletInput
    connect?: userWhereUniqueInput
  }

  export type wallet_transactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<wallet_transactionCreateWithoutWalletInput, wallet_transactionUncheckedCreateWithoutWalletInput> | wallet_transactionCreateWithoutWalletInput[] | wallet_transactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutWalletInput | wallet_transactionCreateOrConnectWithoutWalletInput[]
    createMany?: wallet_transactionCreateManyWalletInputEnvelope
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
  }

  export type userUpdateOneWithoutWalletNestedInput = {
    create?: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    connectOrCreate?: userCreateOrConnectWithoutWalletInput
    upsert?: userUpsertWithoutWalletInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutWalletInput, userUpdateWithoutWalletInput>, userUncheckedUpdateWithoutWalletInput>
  }

  export type wallet_transactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<wallet_transactionCreateWithoutWalletInput, wallet_transactionUncheckedCreateWithoutWalletInput> | wallet_transactionCreateWithoutWalletInput[] | wallet_transactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutWalletInput | wallet_transactionCreateOrConnectWithoutWalletInput[]
    upsert?: wallet_transactionUpsertWithWhereUniqueWithoutWalletInput | wallet_transactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: wallet_transactionCreateManyWalletInputEnvelope
    set?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    disconnect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    delete?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    update?: wallet_transactionUpdateWithWhereUniqueWithoutWalletInput | wallet_transactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: wallet_transactionUpdateManyWithWhereWithoutWalletInput | wallet_transactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: wallet_transactionScalarWhereInput | wallet_transactionScalarWhereInput[]
  }

  export type userUncheckedUpdateOneWithoutWalletNestedInput = {
    create?: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    connectOrCreate?: userCreateOrConnectWithoutWalletInput
    upsert?: userUpsertWithoutWalletInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutWalletInput, userUpdateWithoutWalletInput>, userUncheckedUpdateWithoutWalletInput>
  }

  export type wallet_transactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<wallet_transactionCreateWithoutWalletInput, wallet_transactionUncheckedCreateWithoutWalletInput> | wallet_transactionCreateWithoutWalletInput[] | wallet_transactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_transactionCreateOrConnectWithoutWalletInput | wallet_transactionCreateOrConnectWithoutWalletInput[]
    upsert?: wallet_transactionUpsertWithWhereUniqueWithoutWalletInput | wallet_transactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: wallet_transactionCreateManyWalletInputEnvelope
    set?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    disconnect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    delete?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    connect?: wallet_transactionWhereUniqueInput | wallet_transactionWhereUniqueInput[]
    update?: wallet_transactionUpdateWithWhereUniqueWithoutWalletInput | wallet_transactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: wallet_transactionUpdateManyWithWhereWithoutWalletInput | wallet_transactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: wallet_transactionScalarWhereInput | wallet_transactionScalarWhereInput[]
  }

  export type walletCreateNestedOneWithoutWallet_transactionInput = {
    create?: XOR<walletCreateWithoutWallet_transactionInput, walletUncheckedCreateWithoutWallet_transactionInput>
    connectOrCreate?: walletCreateOrConnectWithoutWallet_transactionInput
    connect?: walletWhereUniqueInput
  }

  export type userCreateNestedOneWithoutWallet_transactionInput = {
    create?: XOR<userCreateWithoutWallet_transactionInput, userUncheckedCreateWithoutWallet_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutWallet_transactionInput
    connect?: userWhereUniqueInput
  }

  export type walletUpdateOneRequiredWithoutWallet_transactionNestedInput = {
    create?: XOR<walletCreateWithoutWallet_transactionInput, walletUncheckedCreateWithoutWallet_transactionInput>
    connectOrCreate?: walletCreateOrConnectWithoutWallet_transactionInput
    upsert?: walletUpsertWithoutWallet_transactionInput
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutWallet_transactionInput, walletUpdateWithoutWallet_transactionInput>, walletUncheckedUpdateWithoutWallet_transactionInput>
  }

  export type userUpdateOneWithoutWallet_transactionNestedInput = {
    create?: XOR<userCreateWithoutWallet_transactionInput, userUncheckedCreateWithoutWallet_transactionInput>
    connectOrCreate?: userCreateOrConnectWithoutWallet_transactionInput
    upsert?: userUpsertWithoutWallet_transactionInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutWallet_transactionInput, userUpdateWithoutWallet_transactionInput>, userUncheckedUpdateWithoutWallet_transactionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type client_auth_userCreateWithoutAuth_userInput = {
    client: clientCreateNestedOneWithoutClient_auth_userInput
  }

  export type client_auth_userUncheckedCreateWithoutAuth_userInput = {
    client_id: number
  }

  export type client_auth_userCreateOrConnectWithoutAuth_userInput = {
    where: client_auth_userWhereUniqueInput
    create: XOR<client_auth_userCreateWithoutAuth_userInput, client_auth_userUncheckedCreateWithoutAuth_userInput>
  }

  export type client_auth_userCreateManyAuth_userInputEnvelope = {
    data: client_auth_userCreateManyAuth_userInput | client_auth_userCreateManyAuth_userInput[]
    skipDuplicates?: boolean
  }

  export type client_auth_userUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: client_auth_userWhereUniqueInput
    update: XOR<client_auth_userUpdateWithoutAuth_userInput, client_auth_userUncheckedUpdateWithoutAuth_userInput>
    create: XOR<client_auth_userCreateWithoutAuth_userInput, client_auth_userUncheckedCreateWithoutAuth_userInput>
  }

  export type client_auth_userUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: client_auth_userWhereUniqueInput
    data: XOR<client_auth_userUpdateWithoutAuth_userInput, client_auth_userUncheckedUpdateWithoutAuth_userInput>
  }

  export type client_auth_userUpdateManyWithWhereWithoutAuth_userInput = {
    where: client_auth_userScalarWhereInput
    data: XOR<client_auth_userUpdateManyMutationInput, client_auth_userUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type client_auth_userScalarWhereInput = {
    AND?: client_auth_userScalarWhereInput | client_auth_userScalarWhereInput[]
    OR?: client_auth_userScalarWhereInput[]
    NOT?: client_auth_userScalarWhereInput | client_auth_userScalarWhereInput[]
    client_id?: IntFilter<"client_auth_user"> | number
    auth_user_id?: IntFilter<"client_auth_user"> | number
  }

  export type banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    file: string
    upload_at: Date | string
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    id?: number
    file: string
    upload_at: Date | string
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableUncheckedCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitable_fileCreateOrConnectWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    where: banner_more_profitable_fileWhereUniqueInput
    create: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
  }

  export type slot_settingsCreateWithoutBanner_more_profitableInput = {
    settings?: settingsCreateNestedOneWithoutSlot_settingsInput
    live_casino_most_popular?: live_casino_most_popularCreateNestedOneWithoutSlot_settingsInput
    casino_most_popular?: casino_most_popularCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsUncheckedCreateWithoutBanner_more_profitableInput = {
    id?: number
    casino_most_popular_id?: number | null
    live_casino_most_popular_id?: number | null
    settings?: settingsUncheckedCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsCreateOrConnectWithoutBanner_more_profitableInput = {
    where: slot_settingsWhereUniqueInput
    create: XOR<slot_settingsCreateWithoutBanner_more_profitableInput, slot_settingsUncheckedCreateWithoutBanner_more_profitableInput>
  }

  export type banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    file: string
    upload_at: Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    id?: number
    file: string
    upload_at: Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableUncheckedCreateNestedOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitable_fileCreateOrConnectWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    where: banner_more_profitable_fileWhereUniqueInput
    create: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitable_fileUpsertWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    update: XOR<banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    create: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    where?: banner_more_profitable_fileWhereInput
  }

  export type banner_more_profitable_fileUpdateToOneWithWhereWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    where?: banner_more_profitable_fileWhereInput
    data: XOR<banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitableUncheckedUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput
  }

  export type slot_settingsUpsertWithoutBanner_more_profitableInput = {
    update: XOR<slot_settingsUpdateWithoutBanner_more_profitableInput, slot_settingsUncheckedUpdateWithoutBanner_more_profitableInput>
    create: XOR<slot_settingsCreateWithoutBanner_more_profitableInput, slot_settingsUncheckedCreateWithoutBanner_more_profitableInput>
    where?: slot_settingsWhereInput
  }

  export type slot_settingsUpdateToOneWithWhereWithoutBanner_more_profitableInput = {
    where?: slot_settingsWhereInput
    data: XOR<slot_settingsUpdateWithoutBanner_more_profitableInput, slot_settingsUncheckedUpdateWithoutBanner_more_profitableInput>
  }

  export type slot_settingsUpdateWithoutBanner_more_profitableInput = {
    settings?: settingsUpdateOneWithoutSlot_settingsNestedInput
    live_casino_most_popular?: live_casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
    casino_most_popular?: casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
  }

  export type slot_settingsUncheckedUpdateWithoutBanner_more_profitableInput = {
    id?: IntFieldUpdateOperationsInput | number
    casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    live_casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    settings?: settingsUncheckedUpdateOneWithoutSlot_settingsNestedInput
  }

  export type banner_more_profitable_fileUpsertWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    update: XOR<banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    create: XOR<banner_more_profitable_fileCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedCreateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    where?: banner_more_profitable_fileWhereInput
  }

  export type banner_more_profitable_fileUpdateToOneWithWhereWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    where?: banner_more_profitable_fileWhereInput
    data: XOR<banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitable_fileUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitable_fileUncheckedUpdateWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    id?: IntFieldUpdateOperationsInput | number
    file?: StringFieldUpdateOperationsInput | string
    upload_at?: DateTimeFieldUpdateOperationsInput | Date | string
    banner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitableUncheckedUpdateOneWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
    slot_settings?: slot_settingsCreateNestedOneWithoutBanner_more_profitableInput
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    id?: number
    slot_settings_id?: number | null
    banner_file_id?: number | null
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
  }

  export type banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    where: banner_more_profitableWhereUniqueInput
    create: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    slot_settings?: slot_settingsCreateNestedOneWithoutBanner_more_profitableInput
  }

  export type banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    id?: number
    banner_id?: number | null
    slot_settings_id?: number | null
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
  }

  export type banner_more_profitableCreateOrConnectWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    where: banner_more_profitableWhereUniqueInput
    create: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitableUpsertWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    update: XOR<banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    create: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
    where?: banner_more_profitableWhereInput
  }

  export type banner_more_profitableUpdateToOneWithWhereWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    where?: banner_more_profitableWhereInput
    data: XOR<banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    slot_settings?: slot_settingsUpdateOneWithoutBanner_more_profitableNestedInput
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_fileInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_file_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type banner_more_profitableUpsertWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    update: XOR<banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    create: XOR<banner_more_profitableCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedCreateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
    where?: banner_more_profitableWhereInput
  }

  export type banner_more_profitableUpdateToOneWithWhereWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    where?: banner_more_profitableWhereInput
    data: XOR<banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput, banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput>
  }

  export type banner_more_profitableUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutBanner_more_profitableNestedInput
  }

  export type banner_more_profitableUncheckedUpdateWithoutBanner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput = {
    id?: IntFieldUpdateOperationsInput | number
    banner_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userCreateWithoutBet_operationsInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutBet_operationsInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBet_operationsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBet_operationsInput, userUncheckedCreateWithoutBet_operationsInput>
  }

  export type slot_gamesCreateWithoutBet_operationsInput = {
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
    provider: providerCreateNestedOneWithoutSlot_gamesInput
  }

  export type slot_gamesUncheckedCreateWithoutBet_operationsInput = {
    id?: number
    provider_id: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
  }

  export type slot_gamesCreateOrConnectWithoutBet_operationsInput = {
    where: slot_gamesWhereUniqueInput
    create: XOR<slot_gamesCreateWithoutBet_operationsInput, slot_gamesUncheckedCreateWithoutBet_operationsInput>
  }

  export type userUpsertWithoutBet_operationsInput = {
    update: XOR<userUpdateWithoutBet_operationsInput, userUncheckedUpdateWithoutBet_operationsInput>
    create: XOR<userCreateWithoutBet_operationsInput, userUncheckedCreateWithoutBet_operationsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBet_operationsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBet_operationsInput, userUncheckedUpdateWithoutBet_operationsInput>
  }

  export type userUpdateWithoutBet_operationsInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBet_operationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type slot_gamesUpsertWithoutBet_operationsInput = {
    update: XOR<slot_gamesUpdateWithoutBet_operationsInput, slot_gamesUncheckedUpdateWithoutBet_operationsInput>
    create: XOR<slot_gamesCreateWithoutBet_operationsInput, slot_gamesUncheckedCreateWithoutBet_operationsInput>
    where?: slot_gamesWhereInput
  }

  export type slot_gamesUpdateToOneWithWhereWithoutBet_operationsInput = {
    where?: slot_gamesWhereInput
    data: XOR<slot_gamesUpdateWithoutBet_operationsInput, slot_gamesUncheckedUpdateWithoutBet_operationsInput>
  }

  export type slot_gamesUpdateWithoutBet_operationsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
    provider?: providerUpdateOneRequiredWithoutSlot_gamesNestedInput
  }

  export type slot_gamesUncheckedUpdateWithoutBet_operationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
  }

  export type casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput = {
    slot_games: slot_gamesCreateNestedOneWithoutCasino_most_popular_slot_gamesInput
  }

  export type casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput = {
    slot_games_id: number
  }

  export type casino_most_popular_slot_gamesCreateOrConnectWithoutCasino_most_popularInput = {
    where: casino_most_popular_slot_gamesWhereUniqueInput
    create: XOR<casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput>
  }

  export type casino_most_popular_slot_gamesCreateManyCasino_most_popularInputEnvelope = {
    data: casino_most_popular_slot_gamesCreateManyCasino_most_popularInput | casino_most_popular_slot_gamesCreateManyCasino_most_popularInput[]
    skipDuplicates?: boolean
  }

  export type slot_settingsCreateWithoutCasino_most_popularInput = {
    banner_more_profitable?: banner_more_profitableCreateNestedManyWithoutSlot_settingsInput
    settings?: settingsCreateNestedOneWithoutSlot_settingsInput
    live_casino_most_popular?: live_casino_most_popularCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsUncheckedCreateWithoutCasino_most_popularInput = {
    id?: number
    live_casino_most_popular_id?: number | null
    banner_more_profitable?: banner_more_profitableUncheckedCreateNestedManyWithoutSlot_settingsInput
    settings?: settingsUncheckedCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsCreateOrConnectWithoutCasino_most_popularInput = {
    where: slot_settingsWhereUniqueInput
    create: XOR<slot_settingsCreateWithoutCasino_most_popularInput, slot_settingsUncheckedCreateWithoutCasino_most_popularInput>
  }

  export type casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutCasino_most_popularInput = {
    where: casino_most_popular_slot_gamesWhereUniqueInput
    update: XOR<casino_most_popular_slot_gamesUpdateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedUpdateWithoutCasino_most_popularInput>
    create: XOR<casino_most_popular_slot_gamesCreateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedCreateWithoutCasino_most_popularInput>
  }

  export type casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutCasino_most_popularInput = {
    where: casino_most_popular_slot_gamesWhereUniqueInput
    data: XOR<casino_most_popular_slot_gamesUpdateWithoutCasino_most_popularInput, casino_most_popular_slot_gamesUncheckedUpdateWithoutCasino_most_popularInput>
  }

  export type casino_most_popular_slot_gamesUpdateManyWithWhereWithoutCasino_most_popularInput = {
    where: casino_most_popular_slot_gamesScalarWhereInput
    data: XOR<casino_most_popular_slot_gamesUpdateManyMutationInput, casino_most_popular_slot_gamesUncheckedUpdateManyWithoutCasino_most_popularInput>
  }

  export type casino_most_popular_slot_gamesScalarWhereInput = {
    AND?: casino_most_popular_slot_gamesScalarWhereInput | casino_most_popular_slot_gamesScalarWhereInput[]
    OR?: casino_most_popular_slot_gamesScalarWhereInput[]
    NOT?: casino_most_popular_slot_gamesScalarWhereInput | casino_most_popular_slot_gamesScalarWhereInput[]
    casino_most_popular_id?: IntFilter<"casino_most_popular_slot_games"> | number
    slot_games_id?: IntFilter<"casino_most_popular_slot_games"> | number
  }

  export type slot_settingsUpsertWithoutCasino_most_popularInput = {
    update: XOR<slot_settingsUpdateWithoutCasino_most_popularInput, slot_settingsUncheckedUpdateWithoutCasino_most_popularInput>
    create: XOR<slot_settingsCreateWithoutCasino_most_popularInput, slot_settingsUncheckedCreateWithoutCasino_most_popularInput>
    where?: slot_settingsWhereInput
  }

  export type slot_settingsUpdateToOneWithWhereWithoutCasino_most_popularInput = {
    where?: slot_settingsWhereInput
    data: XOR<slot_settingsUpdateWithoutCasino_most_popularInput, slot_settingsUncheckedUpdateWithoutCasino_most_popularInput>
  }

  export type slot_settingsUpdateWithoutCasino_most_popularInput = {
    banner_more_profitable?: banner_more_profitableUpdateManyWithoutSlot_settingsNestedInput
    settings?: settingsUpdateOneWithoutSlot_settingsNestedInput
    live_casino_most_popular?: live_casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
  }

  export type slot_settingsUncheckedUpdateWithoutCasino_most_popularInput = {
    id?: IntFieldUpdateOperationsInput | number
    live_casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_more_profitable?: banner_more_profitableUncheckedUpdateManyWithoutSlot_settingsNestedInput
    settings?: settingsUncheckedUpdateOneWithoutSlot_settingsNestedInput
  }

  export type slot_gamesCreateWithoutCasino_most_popular_slot_gamesInput = {
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
    provider: providerCreateNestedOneWithoutSlot_gamesInput
  }

  export type slot_gamesUncheckedCreateWithoutCasino_most_popular_slot_gamesInput = {
    id?: number
    provider_id: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
  }

  export type slot_gamesCreateOrConnectWithoutCasino_most_popular_slot_gamesInput = {
    where: slot_gamesWhereUniqueInput
    create: XOR<slot_gamesCreateWithoutCasino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
  }

  export type casino_most_popularCreateWithoutCasino_most_popular_slot_gamesInput = {
    qty_lines: number
    qty_columns: number
    slot_settings?: slot_settingsCreateNestedOneWithoutCasino_most_popularInput
  }

  export type casino_most_popularUncheckedCreateWithoutCasino_most_popular_slot_gamesInput = {
    id?: number
    qty_lines: number
    qty_columns: number
    slot_settings?: slot_settingsUncheckedCreateNestedOneWithoutCasino_most_popularInput
  }

  export type casino_most_popularCreateOrConnectWithoutCasino_most_popular_slot_gamesInput = {
    where: casino_most_popularWhereUniqueInput
    create: XOR<casino_most_popularCreateWithoutCasino_most_popular_slot_gamesInput, casino_most_popularUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
  }

  export type slot_gamesUpsertWithoutCasino_most_popular_slot_gamesInput = {
    update: XOR<slot_gamesUpdateWithoutCasino_most_popular_slot_gamesInput, slot_gamesUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput>
    create: XOR<slot_gamesCreateWithoutCasino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
    where?: slot_gamesWhereInput
  }

  export type slot_gamesUpdateToOneWithWhereWithoutCasino_most_popular_slot_gamesInput = {
    where?: slot_gamesWhereInput
    data: XOR<slot_gamesUpdateWithoutCasino_most_popular_slot_gamesInput, slot_gamesUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput>
  }

  export type slot_gamesUpdateWithoutCasino_most_popular_slot_gamesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
    provider?: providerUpdateOneRequiredWithoutSlot_gamesNestedInput
  }

  export type slot_gamesUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
  }

  export type casino_most_popularUpsertWithoutCasino_most_popular_slot_gamesInput = {
    update: XOR<casino_most_popularUpdateWithoutCasino_most_popular_slot_gamesInput, casino_most_popularUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput>
    create: XOR<casino_most_popularCreateWithoutCasino_most_popular_slot_gamesInput, casino_most_popularUncheckedCreateWithoutCasino_most_popular_slot_gamesInput>
    where?: casino_most_popularWhereInput
  }

  export type casino_most_popularUpdateToOneWithWhereWithoutCasino_most_popular_slot_gamesInput = {
    where?: casino_most_popularWhereInput
    data: XOR<casino_most_popularUpdateWithoutCasino_most_popular_slot_gamesInput, casino_most_popularUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput>
  }

  export type casino_most_popularUpdateWithoutCasino_most_popular_slot_gamesInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    slot_settings?: slot_settingsUpdateOneWithoutCasino_most_popularNestedInput
  }

  export type casino_most_popularUncheckedUpdateWithoutCasino_most_popular_slot_gamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    slot_settings?: slot_settingsUncheckedUpdateOneWithoutCasino_most_popularNestedInput
  }

  export type settingsCreateWithoutClient_client_settings_idTosettingsInput = {
    created_at: Date | string
    updated_at: Date | string
    layout_colors?: layout_colorsCreateNestedManyWithoutSettingsInput
    client_settings_client_idToclient: clientCreateNestedOneWithoutSettings_settings_client_idToclientInput
    operations?: operationsCreateNestedOneWithoutSettingsInput
    slot_settings?: slot_settingsCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateWithoutClient_client_settings_idTosettingsInput = {
    id?: number
    operations_id?: number | null
    slot_settings_id?: number | null
    client_id: number
    created_at: Date | string
    updated_at: Date | string
    layout_colors?: layout_colorsUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type settingsCreateOrConnectWithoutClient_client_settings_idTosettingsInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutClient_client_settings_idTosettingsInput, settingsUncheckedCreateWithoutClient_client_settings_idTosettingsInput>
  }

  export type client_auth_userCreateWithoutClientInput = {
    auth_user: auth_userCreateNestedOneWithoutClient_auth_userInput
  }

  export type client_auth_userUncheckedCreateWithoutClientInput = {
    auth_user_id: number
  }

  export type client_auth_userCreateOrConnectWithoutClientInput = {
    where: client_auth_userWhereUniqueInput
    create: XOR<client_auth_userCreateWithoutClientInput, client_auth_userUncheckedCreateWithoutClientInput>
  }

  export type client_auth_userCreateManyClientInputEnvelope = {
    data: client_auth_userCreateManyClientInput | client_auth_userCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type settingsCreateWithoutClient_settings_client_idToclientInput = {
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsCreateNestedManyWithoutSettingsInput
    operations?: operationsCreateNestedOneWithoutSettingsInput
    slot_settings?: slot_settingsCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateWithoutClient_settings_client_idToclientInput = {
    id?: number
    operations_id?: number | null
    slot_settings_id?: number | null
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientUncheckedCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type settingsCreateOrConnectWithoutClient_settings_client_idToclientInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutClient_settings_client_idToclientInput, settingsUncheckedCreateWithoutClient_settings_client_idToclientInput>
  }

  export type settingsCreateManyClient_settings_client_idToclientInputEnvelope = {
    data: settingsCreateManyClient_settings_client_idToclientInput | settingsCreateManyClient_settings_client_idToclientInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutClientInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutClientInput = {
    id?: number
    wallet_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutClientInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
  }

  export type userCreateManyClientInputEnvelope = {
    data: userCreateManyClientInput | userCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type settingsUpsertWithoutClient_client_settings_idTosettingsInput = {
    update: XOR<settingsUpdateWithoutClient_client_settings_idTosettingsInput, settingsUncheckedUpdateWithoutClient_client_settings_idTosettingsInput>
    create: XOR<settingsCreateWithoutClient_client_settings_idTosettingsInput, settingsUncheckedCreateWithoutClient_client_settings_idTosettingsInput>
    where?: settingsWhereInput
  }

  export type settingsUpdateToOneWithWhereWithoutClient_client_settings_idTosettingsInput = {
    where?: settingsWhereInput
    data: XOR<settingsUpdateWithoutClient_client_settings_idTosettingsInput, settingsUncheckedUpdateWithoutClient_client_settings_idTosettingsInput>
  }

  export type settingsUpdateWithoutClient_client_settings_idTosettingsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    layout_colors?: layout_colorsUpdateManyWithoutSettingsNestedInput
    client_settings_client_idToclient?: clientUpdateOneRequiredWithoutSettings_settings_client_idToclientNestedInput
    operations?: operationsUpdateOneWithoutSettingsNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateWithoutClient_client_settings_idTosettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operations_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    layout_colors?: layout_colorsUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type client_auth_userUpsertWithWhereUniqueWithoutClientInput = {
    where: client_auth_userWhereUniqueInput
    update: XOR<client_auth_userUpdateWithoutClientInput, client_auth_userUncheckedUpdateWithoutClientInput>
    create: XOR<client_auth_userCreateWithoutClientInput, client_auth_userUncheckedCreateWithoutClientInput>
  }

  export type client_auth_userUpdateWithWhereUniqueWithoutClientInput = {
    where: client_auth_userWhereUniqueInput
    data: XOR<client_auth_userUpdateWithoutClientInput, client_auth_userUncheckedUpdateWithoutClientInput>
  }

  export type client_auth_userUpdateManyWithWhereWithoutClientInput = {
    where: client_auth_userScalarWhereInput
    data: XOR<client_auth_userUpdateManyMutationInput, client_auth_userUncheckedUpdateManyWithoutClientInput>
  }

  export type settingsUpsertWithWhereUniqueWithoutClient_settings_client_idToclientInput = {
    where: settingsWhereUniqueInput
    update: XOR<settingsUpdateWithoutClient_settings_client_idToclientInput, settingsUncheckedUpdateWithoutClient_settings_client_idToclientInput>
    create: XOR<settingsCreateWithoutClient_settings_client_idToclientInput, settingsUncheckedCreateWithoutClient_settings_client_idToclientInput>
  }

  export type settingsUpdateWithWhereUniqueWithoutClient_settings_client_idToclientInput = {
    where: settingsWhereUniqueInput
    data: XOR<settingsUpdateWithoutClient_settings_client_idToclientInput, settingsUncheckedUpdateWithoutClient_settings_client_idToclientInput>
  }

  export type settingsUpdateManyWithWhereWithoutClient_settings_client_idToclientInput = {
    where: settingsScalarWhereInput
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyWithoutClient_settings_client_idToclientInput>
  }

  export type settingsScalarWhereInput = {
    AND?: settingsScalarWhereInput | settingsScalarWhereInput[]
    OR?: settingsScalarWhereInput[]
    NOT?: settingsScalarWhereInput | settingsScalarWhereInput[]
    id?: IntFilter<"settings"> | number
    operations_id?: IntNullableFilter<"settings"> | number | null
    slot_settings_id?: IntNullableFilter<"settings"> | number | null
    client_id?: IntFilter<"settings"> | number
    created_at?: DateTimeFilter<"settings"> | Date | string
    updated_at?: DateTimeFilter<"settings"> | Date | string
  }

  export type userUpsertWithWhereUniqueWithoutClientInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutClientInput, userUncheckedUpdateWithoutClientInput>
    create: XOR<userCreateWithoutClientInput, userUncheckedCreateWithoutClientInput>
  }

  export type userUpdateWithWhereUniqueWithoutClientInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutClientInput, userUncheckedUpdateWithoutClientInput>
  }

  export type userUpdateManyWithWhereWithoutClientInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutClientInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: IntFilter<"user"> | number
    wallet_id?: IntFilter<"user"> | number
    client_id?: IntFilter<"user"> | number
    referral_id?: IntNullableFilter<"user"> | number | null
    referral_settings_id?: IntNullableFilter<"user"> | number | null
    external_id?: IntFilter<"user"> | number
    username?: StringFilter<"user"> | string
    balance?: DecimalNullableFilter<"user"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    session?: StringNullableFilter<"user"> | string | null
    cpa_collected?: BoolNullableFilter<"user"> | boolean | null
    is_referrer?: BoolNullableFilter<"user"> | boolean | null
  }

  export type clientCreateWithoutClient_auth_userInput = {
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    settings_client_settings_idTosettings?: settingsCreateNestedOneWithoutClient_client_settings_idTosettingsInput
    settings_settings_client_idToclient?: settingsCreateNestedManyWithoutClient_settings_client_idToclientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutClient_auth_userInput = {
    id?: number
    settings_id?: number | null
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    settings_settings_client_idToclient?: settingsUncheckedCreateNestedManyWithoutClient_settings_client_idToclientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutClient_auth_userInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutClient_auth_userInput, clientUncheckedCreateWithoutClient_auth_userInput>
  }

  export type auth_userCreateWithoutClient_auth_userInput = {
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    created_at: Date | string
    updated_at: Date | string
    username: string
  }

  export type auth_userUncheckedCreateWithoutClient_auth_userInput = {
    id?: number
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    created_at: Date | string
    updated_at: Date | string
    username: string
  }

  export type auth_userCreateOrConnectWithoutClient_auth_userInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutClient_auth_userInput, auth_userUncheckedCreateWithoutClient_auth_userInput>
  }

  export type clientUpsertWithoutClient_auth_userInput = {
    update: XOR<clientUpdateWithoutClient_auth_userInput, clientUncheckedUpdateWithoutClient_auth_userInput>
    create: XOR<clientCreateWithoutClient_auth_userInput, clientUncheckedCreateWithoutClient_auth_userInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutClient_auth_userInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutClient_auth_userInput, clientUncheckedUpdateWithoutClient_auth_userInput>
  }

  export type clientUpdateWithoutClient_auth_userInput = {
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    settings_client_settings_idTosettings?: settingsUpdateOneWithoutClient_client_settings_idTosettingsNestedInput
    settings_settings_client_idToclient?: settingsUpdateManyWithoutClient_settings_client_idToclientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutClient_auth_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    settings_settings_client_idToclient?: settingsUncheckedUpdateManyWithoutClient_settings_client_idToclientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type auth_userUpsertWithoutClient_auth_userInput = {
    update: XOR<auth_userUpdateWithoutClient_auth_userInput, auth_userUncheckedUpdateWithoutClient_auth_userInput>
    create: XOR<auth_userCreateWithoutClient_auth_userInput, auth_userUncheckedCreateWithoutClient_auth_userInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutClient_auth_userInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutClient_auth_userInput, auth_userUncheckedUpdateWithoutClient_auth_userInput>
  }

  export type auth_userUpdateWithoutClient_auth_userInput = {
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type auth_userUncheckedUpdateWithoutClient_auth_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
  }

  export type settingsCreateWithoutLayout_colorsInput = {
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    client_settings_client_idToclient: clientCreateNestedOneWithoutSettings_settings_client_idToclientInput
    operations?: operationsCreateNestedOneWithoutSettingsInput
    slot_settings?: slot_settingsCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateWithoutLayout_colorsInput = {
    id?: number
    operations_id?: number | null
    slot_settings_id?: number | null
    client_id: number
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientUncheckedCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
  }

  export type settingsCreateOrConnectWithoutLayout_colorsInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutLayout_colorsInput, settingsUncheckedCreateWithoutLayout_colorsInput>
  }

  export type settingsUpsertWithoutLayout_colorsInput = {
    update: XOR<settingsUpdateWithoutLayout_colorsInput, settingsUncheckedUpdateWithoutLayout_colorsInput>
    create: XOR<settingsCreateWithoutLayout_colorsInput, settingsUncheckedCreateWithoutLayout_colorsInput>
    where?: settingsWhereInput
  }

  export type settingsUpdateToOneWithWhereWithoutLayout_colorsInput = {
    where?: settingsWhereInput
    data: XOR<settingsUpdateWithoutLayout_colorsInput, settingsUncheckedUpdateWithoutLayout_colorsInput>
  }

  export type settingsUpdateWithoutLayout_colorsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    client_settings_client_idToclient?: clientUpdateOneRequiredWithoutSettings_settings_client_idToclientNestedInput
    operations?: operationsUpdateOneWithoutSettingsNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateWithoutLayout_colorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operations_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUncheckedUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
  }

  export type live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput = {
    slot_games: slot_gamesCreateNestedOneWithoutLive_casino_most_popular_slot_gamesInput
  }

  export type live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput = {
    slot_games_id: number
  }

  export type live_casino_most_popular_slot_gamesCreateOrConnectWithoutLive_casino_most_popularInput = {
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
    create: XOR<live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput>
  }

  export type live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInputEnvelope = {
    data: live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInput | live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInput[]
    skipDuplicates?: boolean
  }

  export type slot_settingsCreateWithoutLive_casino_most_popularInput = {
    banner_more_profitable?: banner_more_profitableCreateNestedManyWithoutSlot_settingsInput
    settings?: settingsCreateNestedOneWithoutSlot_settingsInput
    casino_most_popular?: casino_most_popularCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsUncheckedCreateWithoutLive_casino_most_popularInput = {
    id?: number
    casino_most_popular_id?: number | null
    banner_more_profitable?: banner_more_profitableUncheckedCreateNestedManyWithoutSlot_settingsInput
    settings?: settingsUncheckedCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsCreateOrConnectWithoutLive_casino_most_popularInput = {
    where: slot_settingsWhereUniqueInput
    create: XOR<slot_settingsCreateWithoutLive_casino_most_popularInput, slot_settingsUncheckedCreateWithoutLive_casino_most_popularInput>
  }

  export type live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutLive_casino_most_popularInput = {
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
    update: XOR<live_casino_most_popular_slot_gamesUpdateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedUpdateWithoutLive_casino_most_popularInput>
    create: XOR<live_casino_most_popular_slot_gamesCreateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutLive_casino_most_popularInput>
  }

  export type live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutLive_casino_most_popularInput = {
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
    data: XOR<live_casino_most_popular_slot_gamesUpdateWithoutLive_casino_most_popularInput, live_casino_most_popular_slot_gamesUncheckedUpdateWithoutLive_casino_most_popularInput>
  }

  export type live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutLive_casino_most_popularInput = {
    where: live_casino_most_popular_slot_gamesScalarWhereInput
    data: XOR<live_casino_most_popular_slot_gamesUpdateManyMutationInput, live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutLive_casino_most_popularInput>
  }

  export type live_casino_most_popular_slot_gamesScalarWhereInput = {
    AND?: live_casino_most_popular_slot_gamesScalarWhereInput | live_casino_most_popular_slot_gamesScalarWhereInput[]
    OR?: live_casino_most_popular_slot_gamesScalarWhereInput[]
    NOT?: live_casino_most_popular_slot_gamesScalarWhereInput | live_casino_most_popular_slot_gamesScalarWhereInput[]
    live_casino_most_popular_id?: IntFilter<"live_casino_most_popular_slot_games"> | number
    slot_games_id?: IntFilter<"live_casino_most_popular_slot_games"> | number
  }

  export type slot_settingsUpsertWithoutLive_casino_most_popularInput = {
    update: XOR<slot_settingsUpdateWithoutLive_casino_most_popularInput, slot_settingsUncheckedUpdateWithoutLive_casino_most_popularInput>
    create: XOR<slot_settingsCreateWithoutLive_casino_most_popularInput, slot_settingsUncheckedCreateWithoutLive_casino_most_popularInput>
    where?: slot_settingsWhereInput
  }

  export type slot_settingsUpdateToOneWithWhereWithoutLive_casino_most_popularInput = {
    where?: slot_settingsWhereInput
    data: XOR<slot_settingsUpdateWithoutLive_casino_most_popularInput, slot_settingsUncheckedUpdateWithoutLive_casino_most_popularInput>
  }

  export type slot_settingsUpdateWithoutLive_casino_most_popularInput = {
    banner_more_profitable?: banner_more_profitableUpdateManyWithoutSlot_settingsNestedInput
    settings?: settingsUpdateOneWithoutSlot_settingsNestedInput
    casino_most_popular?: casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
  }

  export type slot_settingsUncheckedUpdateWithoutLive_casino_most_popularInput = {
    id?: IntFieldUpdateOperationsInput | number
    casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_more_profitable?: banner_more_profitableUncheckedUpdateManyWithoutSlot_settingsNestedInput
    settings?: settingsUncheckedUpdateOneWithoutSlot_settingsNestedInput
  }

  export type live_casino_most_popularCreateWithoutLive_casino_most_popular_slot_gamesInput = {
    qty_lines: number
    qty_columns: number
    slot_settings?: slot_settingsCreateNestedOneWithoutLive_casino_most_popularInput
  }

  export type live_casino_most_popularUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput = {
    id?: number
    qty_lines: number
    qty_columns: number
    slot_settings?: slot_settingsUncheckedCreateNestedOneWithoutLive_casino_most_popularInput
  }

  export type live_casino_most_popularCreateOrConnectWithoutLive_casino_most_popular_slot_gamesInput = {
    where: live_casino_most_popularWhereUniqueInput
    create: XOR<live_casino_most_popularCreateWithoutLive_casino_most_popular_slot_gamesInput, live_casino_most_popularUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
  }

  export type slot_gamesCreateWithoutLive_casino_most_popular_slot_gamesInput = {
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsCreateNestedManyWithoutSlot_gamesInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
    provider: providerCreateNestedOneWithoutSlot_gamesInput
  }

  export type slot_gamesUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput = {
    id?: number
    provider_id: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutSlot_gamesInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
  }

  export type slot_gamesCreateOrConnectWithoutLive_casino_most_popular_slot_gamesInput = {
    where: slot_gamesWhereUniqueInput
    create: XOR<slot_gamesCreateWithoutLive_casino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
  }

  export type live_casino_most_popularUpsertWithoutLive_casino_most_popular_slot_gamesInput = {
    update: XOR<live_casino_most_popularUpdateWithoutLive_casino_most_popular_slot_gamesInput, live_casino_most_popularUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput>
    create: XOR<live_casino_most_popularCreateWithoutLive_casino_most_popular_slot_gamesInput, live_casino_most_popularUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
    where?: live_casino_most_popularWhereInput
  }

  export type live_casino_most_popularUpdateToOneWithWhereWithoutLive_casino_most_popular_slot_gamesInput = {
    where?: live_casino_most_popularWhereInput
    data: XOR<live_casino_most_popularUpdateWithoutLive_casino_most_popular_slot_gamesInput, live_casino_most_popularUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput>
  }

  export type live_casino_most_popularUpdateWithoutLive_casino_most_popular_slot_gamesInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    slot_settings?: slot_settingsUpdateOneWithoutLive_casino_most_popularNestedInput
  }

  export type live_casino_most_popularUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    slot_settings?: slot_settingsUncheckedUpdateOneWithoutLive_casino_most_popularNestedInput
  }

  export type slot_gamesUpsertWithoutLive_casino_most_popular_slot_gamesInput = {
    update: XOR<slot_gamesUpdateWithoutLive_casino_most_popular_slot_gamesInput, slot_gamesUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput>
    create: XOR<slot_gamesCreateWithoutLive_casino_most_popular_slot_gamesInput, slot_gamesUncheckedCreateWithoutLive_casino_most_popular_slot_gamesInput>
    where?: slot_gamesWhereInput
  }

  export type slot_gamesUpdateToOneWithWhereWithoutLive_casino_most_popular_slot_gamesInput = {
    where?: slot_gamesWhereInput
    data: XOR<slot_gamesUpdateWithoutLive_casino_most_popular_slot_gamesInput, slot_gamesUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput>
  }

  export type slot_gamesUpdateWithoutLive_casino_most_popular_slot_gamesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUpdateManyWithoutSlot_gamesNestedInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
    provider?: providerUpdateOneRequiredWithoutSlot_gamesNestedInput
  }

  export type slot_gamesUncheckedUpdateWithoutLive_casino_most_popular_slot_gamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutSlot_gamesNestedInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
  }

  export type settingsCreateWithoutOperationsInput = {
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsCreateNestedManyWithoutSettingsInput
    client_settings_client_idToclient: clientCreateNestedOneWithoutSettings_settings_client_idToclientInput
    slot_settings?: slot_settingsCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateWithoutOperationsInput = {
    id?: number
    slot_settings_id?: number | null
    client_id: number
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientUncheckedCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type settingsCreateOrConnectWithoutOperationsInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutOperationsInput, settingsUncheckedCreateWithoutOperationsInput>
  }

  export type settingsUpsertWithoutOperationsInput = {
    update: XOR<settingsUpdateWithoutOperationsInput, settingsUncheckedUpdateWithoutOperationsInput>
    create: XOR<settingsCreateWithoutOperationsInput, settingsUncheckedCreateWithoutOperationsInput>
    where?: settingsWhereInput
  }

  export type settingsUpdateToOneWithWhereWithoutOperationsInput = {
    where?: settingsWhereInput
    data: XOR<settingsUpdateWithoutOperationsInput, settingsUncheckedUpdateWithoutOperationsInput>
  }

  export type settingsUpdateWithoutOperationsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUpdateManyWithoutSettingsNestedInput
    client_settings_client_idToclient?: clientUpdateOneRequiredWithoutSettings_settings_client_idToclientNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateWithoutOperationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUncheckedUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type slot_gamesCreateWithoutProviderInput = {
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsCreateNestedManyWithoutSlot_gamesInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesCreateNestedManyWithoutSlot_gamesInput
  }

  export type slot_gamesUncheckedCreateWithoutProviderInput = {
    id?: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutSlot_gamesInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutSlot_gamesInput
  }

  export type slot_gamesCreateOrConnectWithoutProviderInput = {
    where: slot_gamesWhereUniqueInput
    create: XOR<slot_gamesCreateWithoutProviderInput, slot_gamesUncheckedCreateWithoutProviderInput>
  }

  export type slot_gamesCreateManyProviderInputEnvelope = {
    data: slot_gamesCreateManyProviderInput | slot_gamesCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type slot_gamesUpsertWithWhereUniqueWithoutProviderInput = {
    where: slot_gamesWhereUniqueInput
    update: XOR<slot_gamesUpdateWithoutProviderInput, slot_gamesUncheckedUpdateWithoutProviderInput>
    create: XOR<slot_gamesCreateWithoutProviderInput, slot_gamesUncheckedCreateWithoutProviderInput>
  }

  export type slot_gamesUpdateWithWhereUniqueWithoutProviderInput = {
    where: slot_gamesWhereUniqueInput
    data: XOR<slot_gamesUpdateWithoutProviderInput, slot_gamesUncheckedUpdateWithoutProviderInput>
  }

  export type slot_gamesUpdateManyWithWhereWithoutProviderInput = {
    where: slot_gamesScalarWhereInput
    data: XOR<slot_gamesUpdateManyMutationInput, slot_gamesUncheckedUpdateManyWithoutProviderInput>
  }

  export type slot_gamesScalarWhereInput = {
    AND?: slot_gamesScalarWhereInput | slot_gamesScalarWhereInput[]
    OR?: slot_gamesScalarWhereInput[]
    NOT?: slot_gamesScalarWhereInput | slot_gamesScalarWhereInput[]
    id?: IntFilter<"slot_games"> | number
    provider_id?: IntFilter<"slot_games"> | number
    uuid?: StringFilter<"slot_games"> | string
    name?: StringFilter<"slot_games"> | string
    image?: StringFilter<"slot_games"> | string
    type?: StringFilter<"slot_games"> | string
    has_lobby?: BoolFilter<"slot_games"> | boolean
    is_mobile?: BoolFilter<"slot_games"> | boolean
    has_freespins?: BoolFilter<"slot_games"> | boolean
    has_tables?: BoolFilter<"slot_games"> | boolean
    freespin_valid_until_full_day?: BoolFilter<"slot_games"> | boolean
    slug?: StringNullableFilter<"slot_games"> | string | null
  }

  export type userCreateWithoutReferral_history_referral_history_referral_idTouserInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReferral_history_referral_history_referral_idTouserInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReferral_history_referral_history_referral_idTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReferral_history_referral_history_referral_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_referral_idTouserInput>
  }

  export type userCreateWithoutReferral_history_referral_history_user_idTouserInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReferral_history_referral_history_user_idTouserInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReferral_history_referral_history_user_idTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReferral_history_referral_history_user_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_user_idTouserInput>
  }

  export type userUpsertWithoutReferral_history_referral_history_referral_idTouserInput = {
    update: XOR<userUpdateWithoutReferral_history_referral_history_referral_idTouserInput, userUncheckedUpdateWithoutReferral_history_referral_history_referral_idTouserInput>
    create: XOR<userCreateWithoutReferral_history_referral_history_referral_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_referral_idTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReferral_history_referral_history_referral_idTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReferral_history_referral_history_referral_idTouserInput, userUncheckedUpdateWithoutReferral_history_referral_history_referral_idTouserInput>
  }

  export type userUpdateWithoutReferral_history_referral_history_referral_idTouserInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReferral_history_referral_history_referral_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutReferral_history_referral_history_user_idTouserInput = {
    update: XOR<userUpdateWithoutReferral_history_referral_history_user_idTouserInput, userUncheckedUpdateWithoutReferral_history_referral_history_user_idTouserInput>
    create: XOR<userCreateWithoutReferral_history_referral_history_user_idTouserInput, userUncheckedCreateWithoutReferral_history_referral_history_user_idTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReferral_history_referral_history_user_idTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReferral_history_referral_history_user_idTouserInput, userUncheckedUpdateWithoutReferral_history_referral_history_user_idTouserInput>
  }

  export type userUpdateWithoutReferral_history_referral_history_user_idTouserInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReferral_history_referral_history_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutReferral_settingsInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReferral_settingsInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReferral_settingsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReferral_settingsInput, userUncheckedCreateWithoutReferral_settingsInput>
  }

  export type userUpsertWithoutReferral_settingsInput = {
    update: XOR<userUpdateWithoutReferral_settingsInput, userUncheckedUpdateWithoutReferral_settingsInput>
    create: XOR<userCreateWithoutReferral_settingsInput, userUncheckedCreateWithoutReferral_settingsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReferral_settingsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReferral_settingsInput, userUncheckedUpdateWithoutReferral_settingsInput>
  }

  export type userUpdateWithoutReferral_settingsInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReferral_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type clientCreateWithoutSettings_client_settings_idTosettingsInput = {
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    client_auth_user?: client_auth_userCreateNestedManyWithoutClientInput
    settings_settings_client_idToclient?: settingsCreateNestedManyWithoutClient_settings_client_idToclientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutSettings_client_settings_idTosettingsInput = {
    id?: number
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    client_auth_user?: client_auth_userUncheckedCreateNestedManyWithoutClientInput
    settings_settings_client_idToclient?: settingsUncheckedCreateNestedManyWithoutClient_settings_client_idToclientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutSettings_client_settings_idTosettingsInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedCreateWithoutSettings_client_settings_idTosettingsInput>
  }

  export type layout_colorsCreateWithoutSettingsInput = {
    name: string
    hexadecimal: string
  }

  export type layout_colorsUncheckedCreateWithoutSettingsInput = {
    id?: number
    name: string
    hexadecimal: string
  }

  export type layout_colorsCreateOrConnectWithoutSettingsInput = {
    where: layout_colorsWhereUniqueInput
    create: XOR<layout_colorsCreateWithoutSettingsInput, layout_colorsUncheckedCreateWithoutSettingsInput>
  }

  export type layout_colorsCreateManySettingsInputEnvelope = {
    data: layout_colorsCreateManySettingsInput | layout_colorsCreateManySettingsInput[]
    skipDuplicates?: boolean
  }

  export type clientCreateWithoutSettings_settings_client_idToclientInput = {
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    settings_client_settings_idTosettings?: settingsCreateNestedOneWithoutClient_client_settings_idTosettingsInput
    client_auth_user?: client_auth_userCreateNestedManyWithoutClientInput
    user?: userCreateNestedManyWithoutClientInput
  }

  export type clientUncheckedCreateWithoutSettings_settings_client_idToclientInput = {
    id?: number
    settings_id?: number | null
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    client_auth_user?: client_auth_userUncheckedCreateNestedManyWithoutClientInput
    user?: userUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientCreateOrConnectWithoutSettings_settings_client_idToclientInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutSettings_settings_client_idToclientInput, clientUncheckedCreateWithoutSettings_settings_client_idToclientInput>
  }

  export type operationsCreateWithoutSettingsInput = {
    active: boolean
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: Date | string
    updated_at: Date | string
  }

  export type operationsUncheckedCreateWithoutSettingsInput = {
    id?: number
    active: boolean
    whithdraw_minimum: number
    withdraw_maximum: number
    withdraw_fee: number
    deposit_minimum: number
    deposit_maximum: number
    created_at: Date | string
    updated_at: Date | string
  }

  export type operationsCreateOrConnectWithoutSettingsInput = {
    where: operationsWhereUniqueInput
    create: XOR<operationsCreateWithoutSettingsInput, operationsUncheckedCreateWithoutSettingsInput>
  }

  export type slot_settingsCreateWithoutSettingsInput = {
    banner_more_profitable?: banner_more_profitableCreateNestedManyWithoutSlot_settingsInput
    live_casino_most_popular?: live_casino_most_popularCreateNestedOneWithoutSlot_settingsInput
    casino_most_popular?: casino_most_popularCreateNestedOneWithoutSlot_settingsInput
  }

  export type slot_settingsUncheckedCreateWithoutSettingsInput = {
    id?: number
    casino_most_popular_id?: number | null
    live_casino_most_popular_id?: number | null
    banner_more_profitable?: banner_more_profitableUncheckedCreateNestedManyWithoutSlot_settingsInput
  }

  export type slot_settingsCreateOrConnectWithoutSettingsInput = {
    where: slot_settingsWhereUniqueInput
    create: XOR<slot_settingsCreateWithoutSettingsInput, slot_settingsUncheckedCreateWithoutSettingsInput>
  }

  export type clientUpsertWithoutSettings_client_settings_idTosettingsInput = {
    update: XOR<clientUpdateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedUpdateWithoutSettings_client_settings_idTosettingsInput>
    create: XOR<clientCreateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedCreateWithoutSettings_client_settings_idTosettingsInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutSettings_client_settings_idTosettingsInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutSettings_client_settings_idTosettingsInput, clientUncheckedUpdateWithoutSettings_client_settings_idTosettingsInput>
  }

  export type clientUpdateWithoutSettings_client_settings_idTosettingsInput = {
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    client_auth_user?: client_auth_userUpdateManyWithoutClientNestedInput
    settings_settings_client_idToclient?: settingsUpdateManyWithoutClient_settings_client_idToclientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutSettings_client_settings_idTosettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    client_auth_user?: client_auth_userUncheckedUpdateManyWithoutClientNestedInput
    settings_settings_client_idToclient?: settingsUncheckedUpdateManyWithoutClient_settings_client_idToclientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type layout_colorsUpsertWithWhereUniqueWithoutSettingsInput = {
    where: layout_colorsWhereUniqueInput
    update: XOR<layout_colorsUpdateWithoutSettingsInput, layout_colorsUncheckedUpdateWithoutSettingsInput>
    create: XOR<layout_colorsCreateWithoutSettingsInput, layout_colorsUncheckedCreateWithoutSettingsInput>
  }

  export type layout_colorsUpdateWithWhereUniqueWithoutSettingsInput = {
    where: layout_colorsWhereUniqueInput
    data: XOR<layout_colorsUpdateWithoutSettingsInput, layout_colorsUncheckedUpdateWithoutSettingsInput>
  }

  export type layout_colorsUpdateManyWithWhereWithoutSettingsInput = {
    where: layout_colorsScalarWhereInput
    data: XOR<layout_colorsUpdateManyMutationInput, layout_colorsUncheckedUpdateManyWithoutSettingsInput>
  }

  export type layout_colorsScalarWhereInput = {
    AND?: layout_colorsScalarWhereInput | layout_colorsScalarWhereInput[]
    OR?: layout_colorsScalarWhereInput[]
    NOT?: layout_colorsScalarWhereInput | layout_colorsScalarWhereInput[]
    id?: IntFilter<"layout_colors"> | number
    settings_id?: IntNullableFilter<"layout_colors"> | number | null
    name?: StringFilter<"layout_colors"> | string
    hexadecimal?: StringFilter<"layout_colors"> | string
  }

  export type clientUpsertWithoutSettings_settings_client_idToclientInput = {
    update: XOR<clientUpdateWithoutSettings_settings_client_idToclientInput, clientUncheckedUpdateWithoutSettings_settings_client_idToclientInput>
    create: XOR<clientCreateWithoutSettings_settings_client_idToclientInput, clientUncheckedCreateWithoutSettings_settings_client_idToclientInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutSettings_settings_client_idToclientInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutSettings_settings_client_idToclientInput, clientUncheckedUpdateWithoutSettings_settings_client_idToclientInput>
  }

  export type clientUpdateWithoutSettings_settings_client_idToclientInput = {
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    settings_client_settings_idTosettings?: settingsUpdateOneWithoutClient_client_settings_idTosettingsNestedInput
    client_auth_user?: client_auth_userUpdateManyWithoutClientNestedInput
    user?: userUpdateManyWithoutClientNestedInput
  }

  export type clientUncheckedUpdateWithoutSettings_settings_client_idToclientInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    client_auth_user?: client_auth_userUncheckedUpdateManyWithoutClientNestedInput
    user?: userUncheckedUpdateManyWithoutClientNestedInput
  }

  export type operationsUpsertWithoutSettingsInput = {
    update: XOR<operationsUpdateWithoutSettingsInput, operationsUncheckedUpdateWithoutSettingsInput>
    create: XOR<operationsCreateWithoutSettingsInput, operationsUncheckedCreateWithoutSettingsInput>
    where?: operationsWhereInput
  }

  export type operationsUpdateToOneWithWhereWithoutSettingsInput = {
    where?: operationsWhereInput
    data: XOR<operationsUpdateWithoutSettingsInput, operationsUncheckedUpdateWithoutSettingsInput>
  }

  export type operationsUpdateWithoutSettingsInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    whithdraw_minimum?: FloatFieldUpdateOperationsInput | number
    withdraw_maximum?: FloatFieldUpdateOperationsInput | number
    withdraw_fee?: FloatFieldUpdateOperationsInput | number
    deposit_minimum?: FloatFieldUpdateOperationsInput | number
    deposit_maximum?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type operationsUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    whithdraw_minimum?: FloatFieldUpdateOperationsInput | number
    withdraw_maximum?: FloatFieldUpdateOperationsInput | number
    withdraw_fee?: FloatFieldUpdateOperationsInput | number
    deposit_minimum?: FloatFieldUpdateOperationsInput | number
    deposit_maximum?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type slot_settingsUpsertWithoutSettingsInput = {
    update: XOR<slot_settingsUpdateWithoutSettingsInput, slot_settingsUncheckedUpdateWithoutSettingsInput>
    create: XOR<slot_settingsCreateWithoutSettingsInput, slot_settingsUncheckedCreateWithoutSettingsInput>
    where?: slot_settingsWhereInput
  }

  export type slot_settingsUpdateToOneWithWhereWithoutSettingsInput = {
    where?: slot_settingsWhereInput
    data: XOR<slot_settingsUpdateWithoutSettingsInput, slot_settingsUncheckedUpdateWithoutSettingsInput>
  }

  export type slot_settingsUpdateWithoutSettingsInput = {
    banner_more_profitable?: banner_more_profitableUpdateManyWithoutSlot_settingsNestedInput
    live_casino_most_popular?: live_casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
    casino_most_popular?: casino_most_popularUpdateOneWithoutSlot_settingsNestedInput
  }

  export type slot_settingsUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    live_casino_most_popular_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_more_profitable?: banner_more_profitableUncheckedUpdateManyWithoutSlot_settingsNestedInput
  }

  export type bet_operationsCreateWithoutSlot_gamesInput = {
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    user: userCreateNestedOneWithoutBet_operationsInput
  }

  export type bet_operationsUncheckedCreateWithoutSlot_gamesInput = {
    id?: number
    user_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type bet_operationsCreateOrConnectWithoutSlot_gamesInput = {
    where: bet_operationsWhereUniqueInput
    create: XOR<bet_operationsCreateWithoutSlot_gamesInput, bet_operationsUncheckedCreateWithoutSlot_gamesInput>
  }

  export type bet_operationsCreateManySlot_gamesInputEnvelope = {
    data: bet_operationsCreateManySlot_gamesInput | bet_operationsCreateManySlot_gamesInput[]
    skipDuplicates?: boolean
  }

  export type casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput = {
    casino_most_popular: casino_most_popularCreateNestedOneWithoutCasino_most_popular_slot_gamesInput
  }

  export type casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput = {
    casino_most_popular_id: number
  }

  export type casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput = {
    where: casino_most_popular_slot_gamesWhereUniqueInput
    create: XOR<casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput>
  }

  export type casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope = {
    data: casino_most_popular_slot_gamesCreateManySlot_gamesInput | casino_most_popular_slot_gamesCreateManySlot_gamesInput[]
    skipDuplicates?: boolean
  }

  export type live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput = {
    live_casino_most_popular: live_casino_most_popularCreateNestedOneWithoutLive_casino_most_popular_slot_gamesInput
  }

  export type live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput = {
    live_casino_most_popular_id: number
  }

  export type live_casino_most_popular_slot_gamesCreateOrConnectWithoutSlot_gamesInput = {
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
    create: XOR<live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput>
  }

  export type live_casino_most_popular_slot_gamesCreateManySlot_gamesInputEnvelope = {
    data: live_casino_most_popular_slot_gamesCreateManySlot_gamesInput | live_casino_most_popular_slot_gamesCreateManySlot_gamesInput[]
    skipDuplicates?: boolean
  }

  export type providerCreateWithoutSlot_gamesInput = {
    name: string
    client_percent?: number | null
    base_percent?: number | null
  }

  export type providerUncheckedCreateWithoutSlot_gamesInput = {
    id?: number
    name: string
    client_percent?: number | null
    base_percent?: number | null
  }

  export type providerCreateOrConnectWithoutSlot_gamesInput = {
    where: providerWhereUniqueInput
    create: XOR<providerCreateWithoutSlot_gamesInput, providerUncheckedCreateWithoutSlot_gamesInput>
  }

  export type bet_operationsUpsertWithWhereUniqueWithoutSlot_gamesInput = {
    where: bet_operationsWhereUniqueInput
    update: XOR<bet_operationsUpdateWithoutSlot_gamesInput, bet_operationsUncheckedUpdateWithoutSlot_gamesInput>
    create: XOR<bet_operationsCreateWithoutSlot_gamesInput, bet_operationsUncheckedCreateWithoutSlot_gamesInput>
  }

  export type bet_operationsUpdateWithWhereUniqueWithoutSlot_gamesInput = {
    where: bet_operationsWhereUniqueInput
    data: XOR<bet_operationsUpdateWithoutSlot_gamesInput, bet_operationsUncheckedUpdateWithoutSlot_gamesInput>
  }

  export type bet_operationsUpdateManyWithWhereWithoutSlot_gamesInput = {
    where: bet_operationsScalarWhereInput
    data: XOR<bet_operationsUpdateManyMutationInput, bet_operationsUncheckedUpdateManyWithoutSlot_gamesInput>
  }

  export type bet_operationsScalarWhereInput = {
    AND?: bet_operationsScalarWhereInput | bet_operationsScalarWhereInput[]
    OR?: bet_operationsScalarWhereInput[]
    NOT?: bet_operationsScalarWhereInput | bet_operationsScalarWhereInput[]
    id?: IntFilter<"bet_operations"> | number
    user_id?: IntFilter<"bet_operations"> | number
    slot_game_id?: IntFilter<"bet_operations"> | number
    bet_transaction_id?: StringFilter<"bet_operations"> | string
    status?: StringFilter<"bet_operations"> | string
    amount?: FloatFilter<"bet_operations"> | number
    round_id?: StringNullableFilter<"bet_operations"> | string | null
    created_at?: DateTimeFilter<"bet_operations"> | Date | string
    updated_at?: DateTimeFilter<"bet_operations"> | Date | string
  }

  export type casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput = {
    where: casino_most_popular_slot_gamesWhereUniqueInput
    update: XOR<casino_most_popular_slot_gamesUpdateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedUpdateWithoutSlot_gamesInput>
    create: XOR<casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput>
  }

  export type casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput = {
    where: casino_most_popular_slot_gamesWhereUniqueInput
    data: XOR<casino_most_popular_slot_gamesUpdateWithoutSlot_gamesInput, casino_most_popular_slot_gamesUncheckedUpdateWithoutSlot_gamesInput>
  }

  export type casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput = {
    where: casino_most_popular_slot_gamesScalarWhereInput
    data: XOR<casino_most_popular_slot_gamesUpdateManyMutationInput, casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesInput>
  }

  export type live_casino_most_popular_slot_gamesUpsertWithWhereUniqueWithoutSlot_gamesInput = {
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
    update: XOR<live_casino_most_popular_slot_gamesUpdateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedUpdateWithoutSlot_gamesInput>
    create: XOR<live_casino_most_popular_slot_gamesCreateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedCreateWithoutSlot_gamesInput>
  }

  export type live_casino_most_popular_slot_gamesUpdateWithWhereUniqueWithoutSlot_gamesInput = {
    where: live_casino_most_popular_slot_gamesWhereUniqueInput
    data: XOR<live_casino_most_popular_slot_gamesUpdateWithoutSlot_gamesInput, live_casino_most_popular_slot_gamesUncheckedUpdateWithoutSlot_gamesInput>
  }

  export type live_casino_most_popular_slot_gamesUpdateManyWithWhereWithoutSlot_gamesInput = {
    where: live_casino_most_popular_slot_gamesScalarWhereInput
    data: XOR<live_casino_most_popular_slot_gamesUpdateManyMutationInput, live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesInput>
  }

  export type providerUpsertWithoutSlot_gamesInput = {
    update: XOR<providerUpdateWithoutSlot_gamesInput, providerUncheckedUpdateWithoutSlot_gamesInput>
    create: XOR<providerCreateWithoutSlot_gamesInput, providerUncheckedCreateWithoutSlot_gamesInput>
    where?: providerWhereInput
  }

  export type providerUpdateToOneWithWhereWithoutSlot_gamesInput = {
    where?: providerWhereInput
    data: XOR<providerUpdateWithoutSlot_gamesInput, providerUncheckedUpdateWithoutSlot_gamesInput>
  }

  export type providerUpdateWithoutSlot_gamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    client_percent?: NullableIntFieldUpdateOperationsInput | number | null
    base_percent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type providerUncheckedUpdateWithoutSlot_gamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    client_percent?: NullableIntFieldUpdateOperationsInput | number | null
    base_percent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type banner_more_profitableCreateWithoutSlot_settingsInput = {
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileInput
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitable_fileCreateNestedOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileInput
  }

  export type banner_more_profitableUncheckedCreateWithoutSlot_settingsInput = {
    id?: number
    banner_id?: number | null
    banner_file_id?: number | null
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
  }

  export type banner_more_profitableCreateOrConnectWithoutSlot_settingsInput = {
    where: banner_more_profitableWhereUniqueInput
    create: XOR<banner_more_profitableCreateWithoutSlot_settingsInput, banner_more_profitableUncheckedCreateWithoutSlot_settingsInput>
  }

  export type banner_more_profitableCreateManySlot_settingsInputEnvelope = {
    data: banner_more_profitableCreateManySlot_settingsInput | banner_more_profitableCreateManySlot_settingsInput[]
    skipDuplicates?: boolean
  }

  export type settingsCreateWithoutSlot_settingsInput = {
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsCreateNestedManyWithoutSettingsInput
    client_settings_client_idToclient: clientCreateNestedOneWithoutSettings_settings_client_idToclientInput
    operations?: operationsCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateWithoutSlot_settingsInput = {
    id?: number
    operations_id?: number | null
    client_id: number
    created_at: Date | string
    updated_at: Date | string
    client_client_settings_idTosettings?: clientUncheckedCreateNestedOneWithoutSettings_client_settings_idTosettingsInput
    layout_colors?: layout_colorsUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type settingsCreateOrConnectWithoutSlot_settingsInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutSlot_settingsInput, settingsUncheckedCreateWithoutSlot_settingsInput>
  }

  export type live_casino_most_popularCreateWithoutSlot_settingsInput = {
    qty_lines: number
    qty_columns: number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesCreateNestedManyWithoutLive_casino_most_popularInput
  }

  export type live_casino_most_popularUncheckedCreateWithoutSlot_settingsInput = {
    id?: number
    qty_lines: number
    qty_columns: number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutLive_casino_most_popularInput
  }

  export type live_casino_most_popularCreateOrConnectWithoutSlot_settingsInput = {
    where: live_casino_most_popularWhereUniqueInput
    create: XOR<live_casino_most_popularCreateWithoutSlot_settingsInput, live_casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
  }

  export type casino_most_popularCreateWithoutSlot_settingsInput = {
    qty_lines: number
    qty_columns: number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesCreateNestedManyWithoutCasino_most_popularInput
  }

  export type casino_most_popularUncheckedCreateWithoutSlot_settingsInput = {
    id?: number
    qty_lines: number
    qty_columns: number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedCreateNestedManyWithoutCasino_most_popularInput
  }

  export type casino_most_popularCreateOrConnectWithoutSlot_settingsInput = {
    where: casino_most_popularWhereUniqueInput
    create: XOR<casino_most_popularCreateWithoutSlot_settingsInput, casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
  }

  export type banner_more_profitableUpsertWithWhereUniqueWithoutSlot_settingsInput = {
    where: banner_more_profitableWhereUniqueInput
    update: XOR<banner_more_profitableUpdateWithoutSlot_settingsInput, banner_more_profitableUncheckedUpdateWithoutSlot_settingsInput>
    create: XOR<banner_more_profitableCreateWithoutSlot_settingsInput, banner_more_profitableUncheckedCreateWithoutSlot_settingsInput>
  }

  export type banner_more_profitableUpdateWithWhereUniqueWithoutSlot_settingsInput = {
    where: banner_more_profitableWhereUniqueInput
    data: XOR<banner_more_profitableUpdateWithoutSlot_settingsInput, banner_more_profitableUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type banner_more_profitableUpdateManyWithWhereWithoutSlot_settingsInput = {
    where: banner_more_profitableScalarWhereInput
    data: XOR<banner_more_profitableUpdateManyMutationInput, banner_more_profitableUncheckedUpdateManyWithoutSlot_settingsInput>
  }

  export type banner_more_profitableScalarWhereInput = {
    AND?: banner_more_profitableScalarWhereInput | banner_more_profitableScalarWhereInput[]
    OR?: banner_more_profitableScalarWhereInput[]
    NOT?: banner_more_profitableScalarWhereInput | banner_more_profitableScalarWhereInput[]
    id?: IntFilter<"banner_more_profitable"> | number
    banner_id?: IntNullableFilter<"banner_more_profitable"> | number | null
    slot_settings_id?: IntNullableFilter<"banner_more_profitable"> | number | null
    banner_file_id?: IntNullableFilter<"banner_more_profitable"> | number | null
    name?: StringFilter<"banner_more_profitable"> | string
    game_url?: StringFilter<"banner_more_profitable"> | string
    created_at?: DateTimeFilter<"banner_more_profitable"> | Date | string
    updated_at?: DateTimeFilter<"banner_more_profitable"> | Date | string
    active?: BoolFilter<"banner_more_profitable"> | boolean
  }

  export type settingsUpsertWithoutSlot_settingsInput = {
    update: XOR<settingsUpdateWithoutSlot_settingsInput, settingsUncheckedUpdateWithoutSlot_settingsInput>
    create: XOR<settingsCreateWithoutSlot_settingsInput, settingsUncheckedCreateWithoutSlot_settingsInput>
    where?: settingsWhereInput
  }

  export type settingsUpdateToOneWithWhereWithoutSlot_settingsInput = {
    where?: settingsWhereInput
    data: XOR<settingsUpdateWithoutSlot_settingsInput, settingsUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type settingsUpdateWithoutSlot_settingsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUpdateManyWithoutSettingsNestedInput
    client_settings_client_idToclient?: clientUpdateOneRequiredWithoutSettings_settings_client_idToclientNestedInput
    operations?: operationsUpdateOneWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateWithoutSlot_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operations_id?: NullableIntFieldUpdateOperationsInput | number | null
    client_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUncheckedUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type live_casino_most_popularUpsertWithoutSlot_settingsInput = {
    update: XOR<live_casino_most_popularUpdateWithoutSlot_settingsInput, live_casino_most_popularUncheckedUpdateWithoutSlot_settingsInput>
    create: XOR<live_casino_most_popularCreateWithoutSlot_settingsInput, live_casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
    where?: live_casino_most_popularWhereInput
  }

  export type live_casino_most_popularUpdateToOneWithWhereWithoutSlot_settingsInput = {
    where?: live_casino_most_popularWhereInput
    data: XOR<live_casino_most_popularUpdateWithoutSlot_settingsInput, live_casino_most_popularUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type live_casino_most_popularUpdateWithoutSlot_settingsInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUpdateManyWithoutLive_casino_most_popularNestedInput
  }

  export type live_casino_most_popularUncheckedUpdateWithoutSlot_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutLive_casino_most_popularNestedInput
  }

  export type casino_most_popularUpsertWithoutSlot_settingsInput = {
    update: XOR<casino_most_popularUpdateWithoutSlot_settingsInput, casino_most_popularUncheckedUpdateWithoutSlot_settingsInput>
    create: XOR<casino_most_popularCreateWithoutSlot_settingsInput, casino_most_popularUncheckedCreateWithoutSlot_settingsInput>
    where?: casino_most_popularWhereInput
  }

  export type casino_most_popularUpdateToOneWithWhereWithoutSlot_settingsInput = {
    where?: casino_most_popularWhereInput
    data: XOR<casino_most_popularUpdateWithoutSlot_settingsInput, casino_most_popularUncheckedUpdateWithoutSlot_settingsInput>
  }

  export type casino_most_popularUpdateWithoutSlot_settingsInput = {
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUpdateManyWithoutCasino_most_popularNestedInput
  }

  export type casino_most_popularUncheckedUpdateWithoutSlot_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    qty_lines?: IntFieldUpdateOperationsInput | number
    qty_columns?: IntFieldUpdateOperationsInput | number
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedUpdateManyWithoutCasino_most_popularNestedInput
  }

  export type bet_operationsCreateWithoutUserInput = {
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    slot_games: slot_gamesCreateNestedOneWithoutBet_operationsInput
  }

  export type bet_operationsUncheckedCreateWithoutUserInput = {
    id?: number
    slot_game_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type bet_operationsCreateOrConnectWithoutUserInput = {
    where: bet_operationsWhereUniqueInput
    create: XOR<bet_operationsCreateWithoutUserInput, bet_operationsUncheckedCreateWithoutUserInput>
  }

  export type bet_operationsCreateManyUserInputEnvelope = {
    data: bet_operationsCreateManyUserInput | bet_operationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type referral_historyCreateWithoutUser_referral_history_referral_idTouserInput = {
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_referral_history_user_idTouser?: userCreateNestedOneWithoutReferral_history_referral_history_user_idTouserInput
  }

  export type referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput = {
    id?: number
    user_id?: number | null
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type referral_historyCreateOrConnectWithoutUser_referral_history_referral_idTouserInput = {
    where: referral_historyWhereUniqueInput
    create: XOR<referral_historyCreateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput>
  }

  export type referral_historyCreateManyUser_referral_history_referral_idTouserInputEnvelope = {
    data: referral_historyCreateManyUser_referral_history_referral_idTouserInput | referral_historyCreateManyUser_referral_history_referral_idTouserInput[]
    skipDuplicates?: boolean
  }

  export type referral_historyCreateWithoutUser_referral_history_user_idTouserInput = {
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_referral_history_referral_idTouser: userCreateNestedOneWithoutReferral_history_referral_history_referral_idTouserInput
  }

  export type referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput = {
    id?: number
    referral_id: number
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type referral_historyCreateOrConnectWithoutUser_referral_history_user_idTouserInput = {
    where: referral_historyWhereUniqueInput
    create: XOR<referral_historyCreateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput>
  }

  export type referral_historyCreateManyUser_referral_history_user_idTouserInputEnvelope = {
    data: referral_historyCreateManyUser_referral_history_user_idTouserInput | referral_historyCreateManyUser_referral_history_user_idTouserInput[]
    skipDuplicates?: boolean
  }

  export type clientCreateWithoutUserInput = {
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    settings_client_settings_idTosettings?: settingsCreateNestedOneWithoutClient_client_settings_idTosettingsInput
    client_auth_user?: client_auth_userCreateNestedManyWithoutClientInput
    settings_settings_client_idToclient?: settingsCreateNestedManyWithoutClient_settings_client_idToclientInput
  }

  export type clientUncheckedCreateWithoutUserInput = {
    id?: number
    settings_id?: number | null
    key_id_prod?: string | null
    key_secret_prod?: string | null
    key_id_stage?: string | null
    key_secret_stage?: string | null
    currency?: string | null
    language?: string | null
    url_return?: string | null
    created_at: Date | string
    updated_at: Date | string
    name?: string | null
    prod_callback?: string | null
    stage_callback?: string | null
    client_auth_user?: client_auth_userUncheckedCreateNestedManyWithoutClientInput
    settings_settings_client_idToclient?: settingsUncheckedCreateNestedManyWithoutClient_settings_client_idToclientInput
  }

  export type clientCreateOrConnectWithoutUserInput = {
    where: clientWhereUniqueInput
    create: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
  }

  export type userCreateWithoutOther_userInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutOther_userInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOther_userInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOther_userInput, userUncheckedCreateWithoutOther_userInput>
  }

  export type userCreateWithoutUserInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserInput, userUncheckedCreateWithoutUserInput>
  }

  export type userCreateManyUserInputEnvelope = {
    data: userCreateManyUserInput | userCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type referral_settingsCreateWithoutUserInput = {
    cpa?: number | null
    rev_share_percent?: number | null
    referral_type?: string | null
  }

  export type referral_settingsUncheckedCreateWithoutUserInput = {
    id?: number
    cpa?: number | null
    rev_share_percent?: number | null
    referral_type?: string | null
  }

  export type referral_settingsCreateOrConnectWithoutUserInput = {
    where: referral_settingsWhereUniqueInput
    create: XOR<referral_settingsCreateWithoutUserInput, referral_settingsUncheckedCreateWithoutUserInput>
  }

  export type walletCreateWithoutUserInput = {
    balance?: number | null
    bonus?: number | null
    bet?: number | null
    withdraw?: number | null
    deposit?: number | null
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutUserInput = {
    id?: number
    balance?: number | null
    bonus?: number | null
    bet?: number | null
    withdraw?: number | null
    deposit?: number | null
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type walletCreateOrConnectWithoutUserInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
  }

  export type wallet_transactionCreateWithoutUserInput = {
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    uuid: string
    wallet: walletCreateNestedOneWithoutWallet_transactionInput
  }

  export type wallet_transactionUncheckedCreateWithoutUserInput = {
    id?: number
    wallet_id: number
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    uuid: string
  }

  export type wallet_transactionCreateOrConnectWithoutUserInput = {
    where: wallet_transactionWhereUniqueInput
    create: XOR<wallet_transactionCreateWithoutUserInput, wallet_transactionUncheckedCreateWithoutUserInput>
  }

  export type wallet_transactionCreateManyUserInputEnvelope = {
    data: wallet_transactionCreateManyUserInput | wallet_transactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type bet_operationsUpsertWithWhereUniqueWithoutUserInput = {
    where: bet_operationsWhereUniqueInput
    update: XOR<bet_operationsUpdateWithoutUserInput, bet_operationsUncheckedUpdateWithoutUserInput>
    create: XOR<bet_operationsCreateWithoutUserInput, bet_operationsUncheckedCreateWithoutUserInput>
  }

  export type bet_operationsUpdateWithWhereUniqueWithoutUserInput = {
    where: bet_operationsWhereUniqueInput
    data: XOR<bet_operationsUpdateWithoutUserInput, bet_operationsUncheckedUpdateWithoutUserInput>
  }

  export type bet_operationsUpdateManyWithWhereWithoutUserInput = {
    where: bet_operationsScalarWhereInput
    data: XOR<bet_operationsUpdateManyMutationInput, bet_operationsUncheckedUpdateManyWithoutUserInput>
  }

  export type referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput = {
    where: referral_historyWhereUniqueInput
    update: XOR<referral_historyUpdateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedUpdateWithoutUser_referral_history_referral_idTouserInput>
    create: XOR<referral_historyCreateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_referral_idTouserInput>
  }

  export type referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_referral_idTouserInput = {
    where: referral_historyWhereUniqueInput
    data: XOR<referral_historyUpdateWithoutUser_referral_history_referral_idTouserInput, referral_historyUncheckedUpdateWithoutUser_referral_history_referral_idTouserInput>
  }

  export type referral_historyUpdateManyWithWhereWithoutUser_referral_history_referral_idTouserInput = {
    where: referral_historyScalarWhereInput
    data: XOR<referral_historyUpdateManyMutationInput, referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserInput>
  }

  export type referral_historyScalarWhereInput = {
    AND?: referral_historyScalarWhereInput | referral_historyScalarWhereInput[]
    OR?: referral_historyScalarWhereInput[]
    NOT?: referral_historyScalarWhereInput | referral_historyScalarWhereInput[]
    id?: IntFilter<"referral_history"> | number
    referral_id?: IntFilter<"referral_history"> | number
    user_id?: IntNullableFilter<"referral_history"> | number | null
    game?: StringNullableFilter<"referral_history"> | string | null
    amount?: FloatNullableFilter<"referral_history"> | number | null
    type?: StringNullableFilter<"referral_history"> | string | null
    available?: BoolNullableFilter<"referral_history"> | boolean | null
    created_at?: DateTimeNullableFilter<"referral_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"referral_history"> | Date | string | null
  }

  export type referral_historyUpsertWithWhereUniqueWithoutUser_referral_history_user_idTouserInput = {
    where: referral_historyWhereUniqueInput
    update: XOR<referral_historyUpdateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedUpdateWithoutUser_referral_history_user_idTouserInput>
    create: XOR<referral_historyCreateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedCreateWithoutUser_referral_history_user_idTouserInput>
  }

  export type referral_historyUpdateWithWhereUniqueWithoutUser_referral_history_user_idTouserInput = {
    where: referral_historyWhereUniqueInput
    data: XOR<referral_historyUpdateWithoutUser_referral_history_user_idTouserInput, referral_historyUncheckedUpdateWithoutUser_referral_history_user_idTouserInput>
  }

  export type referral_historyUpdateManyWithWhereWithoutUser_referral_history_user_idTouserInput = {
    where: referral_historyScalarWhereInput
    data: XOR<referral_historyUpdateManyMutationInput, referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserInput>
  }

  export type clientUpsertWithoutUserInput = {
    update: XOR<clientUpdateWithoutUserInput, clientUncheckedUpdateWithoutUserInput>
    create: XOR<clientCreateWithoutUserInput, clientUncheckedCreateWithoutUserInput>
    where?: clientWhereInput
  }

  export type clientUpdateToOneWithWhereWithoutUserInput = {
    where?: clientWhereInput
    data: XOR<clientUpdateWithoutUserInput, clientUncheckedUpdateWithoutUserInput>
  }

  export type clientUpdateWithoutUserInput = {
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    settings_client_settings_idTosettings?: settingsUpdateOneWithoutClient_client_settings_idTosettingsNestedInput
    client_auth_user?: client_auth_userUpdateManyWithoutClientNestedInput
    settings_settings_client_idToclient?: settingsUpdateManyWithoutClient_settings_client_idToclientNestedInput
  }

  export type clientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    key_id_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_prod?: NullableStringFieldUpdateOperationsInput | string | null
    key_id_stage?: NullableStringFieldUpdateOperationsInput | string | null
    key_secret_stage?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    url_return?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prod_callback?: NullableStringFieldUpdateOperationsInput | string | null
    stage_callback?: NullableStringFieldUpdateOperationsInput | string | null
    client_auth_user?: client_auth_userUncheckedUpdateManyWithoutClientNestedInput
    settings_settings_client_idToclient?: settingsUncheckedUpdateManyWithoutClient_settings_client_idToclientNestedInput
  }

  export type userUpsertWithoutOther_userInput = {
    update: XOR<userUpdateWithoutOther_userInput, userUncheckedUpdateWithoutOther_userInput>
    create: XOR<userCreateWithoutOther_userInput, userUncheckedCreateWithoutOther_userInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOther_userInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOther_userInput, userUncheckedUpdateWithoutOther_userInput>
  }

  export type userUpdateWithoutOther_userInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOther_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithWhereUniqueWithoutUserInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutUserInput, userUncheckedUpdateWithoutUserInput>
    create: XOR<userCreateWithoutUserInput, userUncheckedCreateWithoutUserInput>
  }

  export type userUpdateWithWhereUniqueWithoutUserInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutUserInput, userUncheckedUpdateWithoutUserInput>
  }

  export type userUpdateManyWithWhereWithoutUserInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutUserInput>
  }

  export type referral_settingsUpsertWithoutUserInput = {
    update: XOR<referral_settingsUpdateWithoutUserInput, referral_settingsUncheckedUpdateWithoutUserInput>
    create: XOR<referral_settingsCreateWithoutUserInput, referral_settingsUncheckedCreateWithoutUserInput>
    where?: referral_settingsWhereInput
  }

  export type referral_settingsUpdateToOneWithWhereWithoutUserInput = {
    where?: referral_settingsWhereInput
    data: XOR<referral_settingsUpdateWithoutUserInput, referral_settingsUncheckedUpdateWithoutUserInput>
  }

  export type referral_settingsUpdateWithoutUserInput = {
    cpa?: NullableIntFieldUpdateOperationsInput | number | null
    rev_share_percent?: NullableIntFieldUpdateOperationsInput | number | null
    referral_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type referral_settingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpa?: NullableIntFieldUpdateOperationsInput | number | null
    rev_share_percent?: NullableIntFieldUpdateOperationsInput | number | null
    referral_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletUpsertWithoutUserInput = {
    update: XOR<walletUpdateWithoutUserInput, walletUncheckedUpdateWithoutUserInput>
    create: XOR<walletCreateWithoutUserInput, walletUncheckedCreateWithoutUserInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutUserInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutUserInput, walletUncheckedUpdateWithoutUserInput>
  }

  export type walletUpdateWithoutUserInput = {
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet_transaction?: wallet_transactionUpdateManyWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type wallet_transactionUpsertWithWhereUniqueWithoutUserInput = {
    where: wallet_transactionWhereUniqueInput
    update: XOR<wallet_transactionUpdateWithoutUserInput, wallet_transactionUncheckedUpdateWithoutUserInput>
    create: XOR<wallet_transactionCreateWithoutUserInput, wallet_transactionUncheckedCreateWithoutUserInput>
  }

  export type wallet_transactionUpdateWithWhereUniqueWithoutUserInput = {
    where: wallet_transactionWhereUniqueInput
    data: XOR<wallet_transactionUpdateWithoutUserInput, wallet_transactionUncheckedUpdateWithoutUserInput>
  }

  export type wallet_transactionUpdateManyWithWhereWithoutUserInput = {
    where: wallet_transactionScalarWhereInput
    data: XOR<wallet_transactionUpdateManyMutationInput, wallet_transactionUncheckedUpdateManyWithoutUserInput>
  }

  export type wallet_transactionScalarWhereInput = {
    AND?: wallet_transactionScalarWhereInput | wallet_transactionScalarWhereInput[]
    OR?: wallet_transactionScalarWhereInput[]
    NOT?: wallet_transactionScalarWhereInput | wallet_transactionScalarWhereInput[]
    id?: IntFilter<"wallet_transaction"> | number
    wallet_id?: IntFilter<"wallet_transaction"> | number
    amount?: FloatFilter<"wallet_transaction"> | number
    created_at?: DateTimeFilter<"wallet_transaction"> | Date | string
    updated_at?: DateTimeFilter<"wallet_transaction"> | Date | string
    deleted_at?: DateTimeNullableFilter<"wallet_transaction"> | Date | string | null
    type?: StringFilter<"wallet_transaction"> | string
    api_collected?: BoolNullableFilter<"wallet_transaction"> | boolean | null
    user_id?: IntNullableFilter<"wallet_transaction"> | number | null
    uuid?: StringFilter<"wallet_transaction"> | string
  }

  export type userCreateWithoutWalletInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet_transaction?: wallet_transactionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutWalletInput = {
    id?: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
    wallet_transaction?: wallet_transactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutWalletInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
  }

  export type wallet_transactionCreateWithoutWalletInput = {
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    uuid: string
    user?: userCreateNestedOneWithoutWallet_transactionInput
  }

  export type wallet_transactionUncheckedCreateWithoutWalletInput = {
    id?: number
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    user_id?: number | null
    uuid: string
  }

  export type wallet_transactionCreateOrConnectWithoutWalletInput = {
    where: wallet_transactionWhereUniqueInput
    create: XOR<wallet_transactionCreateWithoutWalletInput, wallet_transactionUncheckedCreateWithoutWalletInput>
  }

  export type wallet_transactionCreateManyWalletInputEnvelope = {
    data: wallet_transactionCreateManyWalletInput | wallet_transactionCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutWalletInput = {
    update: XOR<userUpdateWithoutWalletInput, userUncheckedUpdateWithoutWalletInput>
    create: XOR<userCreateWithoutWalletInput, userUncheckedCreateWithoutWalletInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutWalletInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutWalletInput, userUncheckedUpdateWithoutWalletInput>
  }

  export type userUpdateWithoutWalletInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type wallet_transactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: wallet_transactionWhereUniqueInput
    update: XOR<wallet_transactionUpdateWithoutWalletInput, wallet_transactionUncheckedUpdateWithoutWalletInput>
    create: XOR<wallet_transactionCreateWithoutWalletInput, wallet_transactionUncheckedCreateWithoutWalletInput>
  }

  export type wallet_transactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: wallet_transactionWhereUniqueInput
    data: XOR<wallet_transactionUpdateWithoutWalletInput, wallet_transactionUncheckedUpdateWithoutWalletInput>
  }

  export type wallet_transactionUpdateManyWithWhereWithoutWalletInput = {
    where: wallet_transactionScalarWhereInput
    data: XOR<wallet_transactionUpdateManyMutationInput, wallet_transactionUncheckedUpdateManyWithoutWalletInput>
  }

  export type walletCreateWithoutWallet_transactionInput = {
    balance?: number | null
    bonus?: number | null
    bet?: number | null
    withdraw?: number | null
    deposit?: number | null
    user?: userCreateNestedOneWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutWallet_transactionInput = {
    id?: number
    balance?: number | null
    bonus?: number | null
    bet?: number | null
    withdraw?: number | null
    deposit?: number | null
    user?: userUncheckedCreateNestedOneWithoutWalletInput
  }

  export type walletCreateOrConnectWithoutWallet_transactionInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutWallet_transactionInput, walletUncheckedCreateWithoutWallet_transactionInput>
  }

  export type userCreateWithoutWallet_transactionInput = {
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    client: clientCreateNestedOneWithoutUserInput
    user?: userCreateNestedOneWithoutOther_userInput
    other_user?: userCreateNestedManyWithoutUserInput
    referral_settings?: referral_settingsCreateNestedOneWithoutUserInput
    wallet: walletCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutWallet_transactionInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
    bet_operations?: bet_operationsUncheckedCreateNestedManyWithoutUserInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_referral_idTouserInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedCreateNestedManyWithoutUser_referral_history_user_idTouserInput
    other_user?: userUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutWallet_transactionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutWallet_transactionInput, userUncheckedCreateWithoutWallet_transactionInput>
  }

  export type walletUpsertWithoutWallet_transactionInput = {
    update: XOR<walletUpdateWithoutWallet_transactionInput, walletUncheckedUpdateWithoutWallet_transactionInput>
    create: XOR<walletCreateWithoutWallet_transactionInput, walletUncheckedCreateWithoutWallet_transactionInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutWallet_transactionInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutWallet_transactionInput, walletUncheckedUpdateWithoutWallet_transactionInput>
  }

  export type walletUpdateWithoutWallet_transactionInput = {
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: userUpdateOneWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutWallet_transactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    bonus?: NullableFloatFieldUpdateOperationsInput | number | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    withdraw?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: userUncheckedUpdateOneWithoutWalletNestedInput
  }

  export type userUpsertWithoutWallet_transactionInput = {
    update: XOR<userUpdateWithoutWallet_transactionInput, userUncheckedUpdateWithoutWallet_transactionInput>
    create: XOR<userCreateWithoutWallet_transactionInput, userUncheckedCreateWithoutWallet_transactionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutWallet_transactionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutWallet_transactionInput, userUncheckedUpdateWithoutWallet_transactionInput>
  }

  export type userUpdateWithoutWallet_transactionInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutWallet_transactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
  }

  export type client_auth_userCreateManyAuth_userInput = {
    client_id: number
  }

  export type client_auth_userUpdateWithoutAuth_userInput = {
    client?: clientUpdateOneRequiredWithoutClient_auth_userNestedInput
  }

  export type client_auth_userUncheckedUpdateWithoutAuth_userInput = {
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type client_auth_userUncheckedUpdateManyWithoutAuth_userInput = {
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type casino_most_popular_slot_gamesCreateManyCasino_most_popularInput = {
    slot_games_id: number
  }

  export type casino_most_popular_slot_gamesUpdateWithoutCasino_most_popularInput = {
    slot_games?: slot_gamesUpdateOneRequiredWithoutCasino_most_popular_slot_gamesNestedInput
  }

  export type casino_most_popular_slot_gamesUncheckedUpdateWithoutCasino_most_popularInput = {
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type casino_most_popular_slot_gamesUncheckedUpdateManyWithoutCasino_most_popularInput = {
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type client_auth_userCreateManyClientInput = {
    auth_user_id: number
  }

  export type settingsCreateManyClient_settings_client_idToclientInput = {
    id?: number
    operations_id?: number | null
    slot_settings_id?: number | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type userCreateManyClientInput = {
    id?: number
    wallet_id: number
    referral_id?: number | null
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
  }

  export type client_auth_userUpdateWithoutClientInput = {
    auth_user?: auth_userUpdateOneRequiredWithoutClient_auth_userNestedInput
  }

  export type client_auth_userUncheckedUpdateWithoutClientInput = {
    auth_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type client_auth_userUncheckedUpdateManyWithoutClientInput = {
    auth_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type settingsUpdateWithoutClient_settings_client_idToclientInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUpdateManyWithoutSettingsNestedInput
    operations?: operationsUpdateOneWithoutSettingsNestedInput
    slot_settings?: slot_settingsUpdateOneWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateWithoutClient_settings_client_idToclientInput = {
    id?: IntFieldUpdateOperationsInput | number
    operations_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client_client_settings_idTosettings?: clientUncheckedUpdateOneWithoutSettings_client_settings_idTosettingsNestedInput
    layout_colors?: layout_colorsUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateManyWithoutClient_settings_client_idToclientInput = {
    id?: IntFieldUpdateOperationsInput | number
    operations_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpdateWithoutClientInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    user?: userUpdateOneWithoutOther_userNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    referral_id?: NullableIntFieldUpdateOperationsInput | number | null
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type live_casino_most_popular_slot_gamesCreateManyLive_casino_most_popularInput = {
    slot_games_id: number
  }

  export type live_casino_most_popular_slot_gamesUpdateWithoutLive_casino_most_popularInput = {
    slot_games?: slot_gamesUpdateOneRequiredWithoutLive_casino_most_popular_slot_gamesNestedInput
  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateWithoutLive_casino_most_popularInput = {
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutLive_casino_most_popularInput = {
    slot_games_id?: IntFieldUpdateOperationsInput | number
  }

  export type slot_gamesCreateManyProviderInput = {
    id?: number
    uuid: string
    name: string
    image: string
    type: string
    has_lobby: boolean
    is_mobile: boolean
    has_freespins: boolean
    has_tables: boolean
    freespin_valid_until_full_day: boolean
    slug?: string | null
  }

  export type slot_gamesUpdateWithoutProviderInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUpdateManyWithoutSlot_gamesNestedInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUpdateManyWithoutSlot_gamesNestedInput
  }

  export type slot_gamesUncheckedUpdateWithoutProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutSlot_gamesNestedInput
    casino_most_popular_slot_games?: casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
    live_casino_most_popular_slot_games?: live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesNestedInput
  }

  export type slot_gamesUncheckedUpdateManyWithoutProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    has_lobby?: BoolFieldUpdateOperationsInput | boolean
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    has_freespins?: BoolFieldUpdateOperationsInput | boolean
    has_tables?: BoolFieldUpdateOperationsInput | boolean
    freespin_valid_until_full_day?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type layout_colorsCreateManySettingsInput = {
    id?: number
    name: string
    hexadecimal: string
  }

  export type layout_colorsUpdateWithoutSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    hexadecimal?: StringFieldUpdateOperationsInput | string
  }

  export type layout_colorsUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hexadecimal?: StringFieldUpdateOperationsInput | string
  }

  export type layout_colorsUncheckedUpdateManyWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hexadecimal?: StringFieldUpdateOperationsInput | string
  }

  export type bet_operationsCreateManySlot_gamesInput = {
    id?: number
    user_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type casino_most_popular_slot_gamesCreateManySlot_gamesInput = {
    casino_most_popular_id: number
  }

  export type live_casino_most_popular_slot_gamesCreateManySlot_gamesInput = {
    live_casino_most_popular_id: number
  }

  export type bet_operationsUpdateWithoutSlot_gamesInput = {
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutBet_operationsNestedInput
  }

  export type bet_operationsUncheckedUpdateWithoutSlot_gamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bet_operationsUncheckedUpdateManyWithoutSlot_gamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type casino_most_popular_slot_gamesUpdateWithoutSlot_gamesInput = {
    casino_most_popular?: casino_most_popularUpdateOneRequiredWithoutCasino_most_popular_slot_gamesNestedInput
  }

  export type casino_most_popular_slot_gamesUncheckedUpdateWithoutSlot_gamesInput = {
    casino_most_popular_id?: IntFieldUpdateOperationsInput | number
  }

  export type casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesInput = {
    casino_most_popular_id?: IntFieldUpdateOperationsInput | number
  }

  export type live_casino_most_popular_slot_gamesUpdateWithoutSlot_gamesInput = {
    live_casino_most_popular?: live_casino_most_popularUpdateOneRequiredWithoutLive_casino_most_popular_slot_gamesNestedInput
  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateWithoutSlot_gamesInput = {
    live_casino_most_popular_id?: IntFieldUpdateOperationsInput | number
  }

  export type live_casino_most_popular_slot_gamesUncheckedUpdateManyWithoutSlot_gamesInput = {
    live_casino_most_popular_id?: IntFieldUpdateOperationsInput | number
  }

  export type banner_more_profitableCreateManySlot_settingsInput = {
    id?: number
    banner_id?: number | null
    banner_file_id?: number | null
    name: string
    game_url: string
    created_at: Date | string
    updated_at: Date | string
    active: boolean
  }

  export type banner_more_profitableUpdateWithoutSlot_settingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    banner_more_profitable_file_banner_more_profitable_banner_idTobanner_more_profitable_file?: banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_idTobanner_more_profitable_fileNestedInput
    banner_more_profitable_file_banner_more_profitable_banner_file_idTobanner_more_profitable_file?: banner_more_profitable_fileUpdateOneWithoutBanner_more_profitable_banner_more_profitable_banner_file_idTobanner_more_profitable_fileNestedInput
  }

  export type banner_more_profitableUncheckedUpdateWithoutSlot_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    banner_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_file_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type banner_more_profitableUncheckedUpdateManyWithoutSlot_settingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    banner_id?: NullableIntFieldUpdateOperationsInput | number | null
    banner_file_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    game_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type bet_operationsCreateManyUserInput = {
    id?: number
    slot_game_id: number
    bet_transaction_id: string
    status: string
    amount: number
    round_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type referral_historyCreateManyUser_referral_history_referral_idTouserInput = {
    id?: number
    user_id?: number | null
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type referral_historyCreateManyUser_referral_history_user_idTouserInput = {
    id?: number
    referral_id: number
    game?: string | null
    amount?: number | null
    type?: string | null
    available?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type userCreateManyUserInput = {
    id?: number
    wallet_id: number
    client_id: number
    referral_settings_id?: number | null
    external_id: number
    username: string
    balance?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    session?: string | null
    cpa_collected?: boolean | null
    is_referrer?: boolean | null
  }

  export type wallet_transactionCreateManyUserInput = {
    id?: number
    wallet_id: number
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    uuid: string
  }

  export type bet_operationsUpdateWithoutUserInput = {
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_games?: slot_gamesUpdateOneRequiredWithoutBet_operationsNestedInput
  }

  export type bet_operationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot_game_id?: IntFieldUpdateOperationsInput | number
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bet_operationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot_game_id?: IntFieldUpdateOperationsInput | number
    bet_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    round_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_historyUpdateWithoutUser_referral_history_referral_idTouserInput = {
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_referral_history_user_idTouser?: userUpdateOneWithoutReferral_history_referral_history_user_idTouserNestedInput
  }

  export type referral_historyUncheckedUpdateWithoutUser_referral_history_referral_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type referral_historyUpdateWithoutUser_referral_history_user_idTouserInput = {
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_referral_history_referral_idTouser?: userUpdateOneRequiredWithoutReferral_history_referral_history_referral_idTouserNestedInput
  }

  export type referral_historyUncheckedUpdateWithoutUser_referral_history_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referral_id?: IntFieldUpdateOperationsInput | number
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referral_id?: IntFieldUpdateOperationsInput | number
    game?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpdateWithoutUserInput = {
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    client?: clientUpdateOneRequiredWithoutUserNestedInput
    other_user?: userUpdateManyWithoutUserNestedInput
    referral_settings?: referral_settingsUpdateOneWithoutUserNestedInput
    wallet?: walletUpdateOneRequiredWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bet_operations?: bet_operationsUncheckedUpdateManyWithoutUserNestedInput
    referral_history_referral_history_referral_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_referral_idTouserNestedInput
    referral_history_referral_history_user_idTouser?: referral_historyUncheckedUpdateManyWithoutUser_referral_history_user_idTouserNestedInput
    other_user?: userUncheckedUpdateManyWithoutUserNestedInput
    wallet_transaction?: wallet_transactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    referral_settings_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    cpa_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_referrer?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type wallet_transactionUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    wallet?: walletUpdateOneRequiredWithoutWallet_transactionNestedInput
  }

  export type wallet_transactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transactionCreateManyWalletInput = {
    id?: number
    amount: number
    created_at: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    type: string
    api_collected?: boolean | null
    user_id?: number | null
    uuid: string
  }

  export type wallet_transactionUpdateWithoutWalletInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneWithoutWallet_transactionNestedInput
  }

  export type wallet_transactionUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type wallet_transactionUncheckedUpdateManyWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    api_collected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}